/*
 * MRChem, a numerical real-space code for molecular electronic structure
 * calculations within the self-consistent field (SCF) approximations of quantum
 * chemistry (Hartree-Fock and Density Functional Theory).
 * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
 *
 * This file is part of MRChem.
 *
 * MRChem is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MRChem is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
 *
 * For information on the complete list of contributors to MRChem, see:
 * <https://mrchem.readthedocs.io/>

 */
#include "MRCPP/MWOperators"
#include "MRCPP/Printer"
#include "MRCPP/treebuilders/DerivativeCalculator.h"
#include "MRCPP/trees/BandWidth.h"

#include "GGA.h"
#include "xc_utils.h"
#include "mrchem.h"
using namespace std;

namespace mrdft {

GGA::GGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d)
        : Functional(k, f)
        , derivative(std::move(d)) {
    xc_mask = xc_utils::build_output_mask(false, false, this->order);
    d_mask = xc_utils::build_density_mask(false, false, this->order);
    name = "GGA";
    if(mrcpp::mpi::wrk_rank==0) cout<<"created GGA "<<endl;
}

/** @brief Make potential at a given NodeIndex
 *
 *
 */
void GGA::makepot(mrcpp::NodeIndex<3> nodeIdx) {
    cout<<"makepot"<<endl;
    mrcpp::FunctionTree<3> *rho0=std::get<1>(rho[0]);
    mrcpp::MWNode<3> node(rho0->getNode(nodeIdx),true,true); //loose node copy of a node from rho

    //send to xcfun
    int ncoefs = rho0->getTDim() * rho0->getKp1_d();
    Eigen::MatrixXd inp(4,ncoefs);
    cout<<"makepot node "<< node.getCoefs()[0];
    node.mwTransform(mrcpp::Reconstruction);
    node.cvTransform(mrcpp::Forward);
    double* coef = node.getCoefs();
    for (int j = 0; j < ncoefs; j++) inp(0,j) = coef[j];
    for (int j = 0; j < ncoefs; j++) coef[j] = rho0->getNode(nodeIdx).getCoefs()[j];
    for (int d = 0; d < 3; d++) {
        //make gradient of density
        mrcpp::DerivativeCalculator<3> derivcalc(d,*this->derivative, *rho0);
        //derivcalc.calcNode(rho0->getNode(nodeIdx), node);
        //mrcpp::MWNode<3> noded(rho0->getNode(nodeIdx),true,false); //loose node copy of a node from rho
        derivcalc.calcNode(rho0->getNode(nodeIdx), node);
        cout<<"  "<< node.getCoefs()[0];

        node.mwTransform(mrcpp::Reconstruction);
        node.cvTransform(mrcpp::Forward);
        coef = node.getCoefs();
        for (int j = 0; j < ncoefs; j++) inp(d+1,j) = coef[j];
    }
    cout<<endl<<" "<<inp(0,0)<<" "<<inp(1,0)<<" "<<inp(2,0)<<" "<<inp(3,0)<<" "<<endl;
    Eigen::MatrixXd out = Functional::evaluate(inp);
    cout<<" out size "<<out.rows()<<" x "<<out.cols()<<endl;
    cout<<" before transf "<<out(0,0)<<" "<<out(1,0)<<" "<<out(2,0)<<" "<<out(3,0)<<" "<<out(4,0)<<endl;
    cout<<" after transf ";
    for (int i = 0; i < 5; i++) {
        // from cv to node values
        //NB: because the inp matrix is stored as "transposed", 2 consecutive coeff are not consequtive in memeory. Therefore we cannot perform the mw transform without copying the coeff back and forth. TODO: fix this
        for (int j = 0; j < ncoefs; j++) coef[j] = out(i,j);
        node.cvTransform(mrcpp::Backward);
        node.mwTransform(mrcpp::Compression);
        cout<<" "<<coef[0];
        if(i<=1)for (int j = 0; j < ncoefs; j++) out(i,j) = coef[j];
        else {
            int d = i-2;
            mrcpp::DerivativeCalculator<3> derivcalc(d,*this->derivative, *rho0);
            mrcpp::MWNode<3> noded(rho0->getNode(nodeIdx),true,false); //loose node copy of a node from rho
            derivcalc.calcNode(node, noded);
            cout<<" -add "<<noded.getCoefs()[0];
            for (int j = 0; j < ncoefs; j++) out(1,j) -= noded.getCoefs()[j];
        }
    }
    cout<<endl<<" after div "<<out(0,0)<<" "<<out(1,0)<<" "<<out(1,1)<<" "<<out(1,2)<<" "<<out(1,0)<<endl;

}



/** @brief Clear internal functions
 *
 * Ownership of densities is outside MRDFT -> clear
 * Ownership of gradients is inside MRDFT -> free
 */
void GGA::clear() {
    mrcpp::clear(this->rho, false);
    mrcpp::clear(this->grad, true);
}

/** @brief Number of function involved in contraction step */
int GGA::getCtrInputLength() const {
    int length = -1;
    if (this->order < 2) length = 0;
    if (this->order == 2) length = 4;
    if (this->order > 2) NOT_IMPLEMENTED_ABORT;
    return length;
}

/** @brief Collect input functions to xcfun evaluation step
 *
 * For GGA : [rho_0, grad(rho_0)]
 */
mrcpp::FunctionTreeVector<3> GGA::setupXCInput() {
    if (this->rho.size() < 1) MSG_ERROR("Density not initialized");
    if (this->grad.size() < 3) MSG_ERROR("Gradient not initialized");

    mrcpp::FunctionTreeVector<3> out_vec;
    out_vec.push_back(this->rho[0]);
    out_vec.insert(out_vec.end(), this->grad.begin(), this->grad.begin() + 3);
    return out_vec;
}

/** @brief Collect input functions to contraction step
 *
 * For GGA:
 * Ground State: No contraction, empty vector
 * Linear Response: [rho_1, grad(rho_1)]
 * Higher Response: NOT_IMPLEMENTED
 */
mrcpp::FunctionTreeVector<3> GGA::setupCtrInput() {
    if (this->order > 2) NOT_IMPLEMENTED_ABORT;
    mrcpp::FunctionTreeVector<3> out_vec;
    if (this->order == 2) {
        out_vec.push_back(this->rho[1]);
        out_vec.insert(out_vec.end(), this->grad.begin() + 3, this->grad.begin() + 6);
    }
    return out_vec;
}

/** @brief Prepare input functions to xcfun
 *
 * Collects input densities and computes necessary gradients.
 *
 * Ordering of input:
 * inp_vec[0] = alpha_0
 * inp_vec[1] = beta_0
 * inp_vec[2] = alpha_1
 * inp_vec[3] = beta_1
 * ...
 */
void GGA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
    if (inp_vec.size() != this->order) MSG_ERROR("Invalid input length");
    if (this->rho.size() > 0) MSG_ERROR("Density not empty");
    if (this->grad.size() > 0) MSG_ERROR("Gradient not empty");

    int n = 0;
    for (int i = 0; i < this->order; i++) this->rho.push_back(inp_vec[n++]);

    for (int i = 0; i < this->order; i++) {
        mrcpp::FunctionTreeVector<3> tmp;
        if (this->log_grad and i == 0) {
            tmp = xc_utils::log_gradient(*this->derivative, mrcpp::get_func(this->rho, i));
        } else {
            g_flag = 1;
            cout<<"mrcpp::gradient "<<" "<<g_flag<<endl;
            tmp = mrcpp::gradient(*this->derivative, mrcpp::get_func(this->rho, i));
            g_flag = 0;
        }
        this->grad.insert(this->grad.end(), tmp.begin(), tmp.end());
    }
     mrcpp::NodeIndex<3> nodeIdx;
     nodeIdx.setScale(-2);
     nodeIdx.setTranslation({-2, -1, -1});
     makepot(nodeIdx);
}

/** @brief Compute final output functions
 *
 * Combine the raw partial derivatives from xcfun into functional derivatives.
 *
 * For GGA:
 * f_xc       : out[0] = inp[0]
 * df_xc/drho : out[1] = inp[1] - div(inp[2,3,4])
 */
mrcpp::FunctionTreeVector<3> GGA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
    // Energy density
    mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
    inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);

    // Potential part
    mrcpp::FunctionTree<3> &df_dr = mrcpp::get_func(inp_vec, 1);
    mrcpp::FunctionTreeVector<3> df_dg(inp_vec.begin() + 2, inp_vec.begin() + 5);

    auto *tmp = new mrcpp::FunctionTree<3>(df_dr.getMRA());
    std::cout<<" derivative: "<<this->derivative->getMaxBandWidth(0)<<" "<<this->derivative->getMaxBandWidth(5)<<" MRA "<<df_dr.getOrder()<<std::endl;
    mrcpp::divergence(*tmp, *this->derivative, df_dg);
    std::cout<<" derivativeafter: "<<this->derivative->getMaxBandWidth(0)<<" "<<this->derivative->getMaxBandWidth(5)<<std::endl;

    auto *v_xc = new mrcpp::FunctionTree<3>(df_dr.getMRA());
    mrcpp::build_grid(*v_xc, df_dr);
    mrcpp::build_grid(*v_xc, *tmp);
    mrcpp::add(-1.0, *v_xc, 1.0, df_dr, -1.0, *tmp);
    delete tmp;
    mrcpp::NodeIndex<3> nodeIdx;
    nodeIdx.setScale(-2);
    nodeIdx.setTranslation({-2, -1, -1});
    std::cout<<" divergence: "<<v_xc->getNode(nodeIdx).getCoefs()[0]<<endl;
    // Collect output
    mrcpp::FunctionTreeVector<3> out_vec;
    out_vec.push_back(std::make_tuple(1.0, &f_xc));
    out_vec.push_back(std::make_tuple(1.0, v_xc));
    v_xc = nullptr;

    return out_vec;
}

/** @brief Fetch density values at given points
 *
 * Points are values for node nIdx
 *
 */
Eigen::MatrixXd GGA::rho_eval(mrcpp::NodeIndex<3> nIdx) const {
    // NB: xcfun uses non-consecutive place in memory for two consecutive rho0 values: need to take transpose of matrix
    mrcpp::FunctionTree<3> *rho0 = std::get<1>(rho[0]);
    int ncoefs = rho0->getTDim() * rho0->getKp1_d();
    Eigen::MatrixXd out(this->order+this->grad.size(),ncoefs);
    mrcpp::MWNode<3> node(rho0->getNode(nIdx),true,false); //we need a node in a tree to be allowed to do a mwtransform
    double* coeftmp = node.getCoefs();
    for (int i = 0; i < this->order; i++) {
        mrcpp::FunctionTree<3> *rhoi = std::get<1>(rho[i]);
        if(rhoi->isLocal){
            rhoi->getNodeCoeff(nIdx, coeftmp); //fetch from Bank (it is allowed to overwrite it)
        } else {
            double *coef = rhoi->getNode(nIdx).getCoefs();
            for (int j = 0; j < ncoefs; j++) coeftmp[j] = coef[j];
            //if(mrcpp::mpi::wrk_rank==0)std::cout<<mrcpp::mpi::wrk_rank<<i<<" GGA::rho_eval "<<coef[0]<<std::endl;
        }
        node.mwTransform(mrcpp::Reconstruction);
        node.cvTransform(mrcpp::Forward);
        //if(mrcpp::mpi::wrk_rank==0)std::cout<<mrcpp::mpi::wrk_rank<<" GGA::rho_eval transf "<<node.getCoefs()[0]<<std::endl;
        for (int j = 0; j < ncoefs; j++) out(i,j) = coeftmp[j];
    }
    for (int i = 0; i < this->grad.size(); i++) {
        mrcpp::FunctionTree<3> *gradi = std::get<1>(grad[i]);
        if(gradi->isLocal){
            gradi->getNodeCoeff(nIdx, coeftmp); //fetch from Bank (it is allowed to overwrite it)
        } else {
            double *coef = gradi->getNode(nIdx).getCoefs();
            for (int j = 0; j < ncoefs; j++) coeftmp[j] = coef[j];
        }
        node.mwTransform(mrcpp::Reconstruction);
        node.cvTransform(mrcpp::Forward);
        for (int j = 0; j < ncoefs; j++) out(i+this->order,j) = coeftmp[j];
    }
    return out;
}

} // namespace mrdft
