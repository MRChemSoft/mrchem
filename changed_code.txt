# Changed Code Dump
# Repo: /home/saikia/MRChem/mrchem
# Generated: 2025-09-07 13:37:14

## Files Included
- bundle_xc.py (62 lines, 1.9 KB)
- cmake/custom/main.cmake (73 lines, 2.6 KB)
- collect_changed_code.py (261 lines, 8.1 KB)
- dump_mrchem_files.py (126 lines, 3.9 KB)
- external/upstream/fetch_libxc.cmake (23 lines, 882.0 B)
- h20_b3lyp.in (14 lines, 158.0 B)
- h2_b3lyp.fixed.json (130 lines, 2.6 KB)
- h2_b3lyp.in (13 lines, 133.0 B)
- h2_b3lyp.json (96 lines, 1.9 KB)
- h2o.json (179 lines, 4.3 KB)
- mrchem_selection_dump_20250825_193702.txt (1275 lines, 45.5 KB)
- src/mrdft/CMakeLists.txt (18 lines, 638.0 B)
- src/mrdft/Factory.cpp (208 lines, 7.7 KB)
- src/mrdft/Factory.h (44 lines, 1.3 KB)
- src/mrdft/Functional.cpp (220 lines, 8.6 KB)
- src/mrdft/Functional.h (98 lines, 3.5 KB)
- src/mrdft/GGA.cpp (125 lines, 3.8 KB)
- src/mrdft/GGA.h (31 lines, 868.0 B)
- src/mrdft/LDA.cpp (103 lines, 2.8 KB)
- src/mrdft/LDA.h (29 lines, 708.0 B)
- src/mrdft/LibXCBackend.cpp (373 lines, 13.4 KB)
- src/mrdft/LibXCBackend.h (83 lines, 2.1 KB)
- src/mrdft/SpinGGA.cpp (158 lines, 5.5 KB)
- src/mrdft/SpinGGA.h (33 lines, 964.0 B)
- src/mrdft/SpinLDA.cpp (112 lines, 3.3 KB)
- src/mrdft/SpinLDA.h (30 lines, 761.0 B)
- src/mrdft/xc_backend.h (38 lines, 1.1 KB)
- src/mrdft/xc_backend_xcfun.cpp (92 lines, 3.0 KB)
- src/mrdft/xc_utils.h (42 lines, 1.7 KB)
- src/mrenv.cpp (312 lines, 13.7 KB)
- src/utils/json_utils.h (120 lines, 5.1 KB)
- tests/hf_grad_blyp_surface_force/reference/hf.json (325 lines, 7.9 KB)
- tests/hf_grad_lda/reference/hf.json (301 lines, 6.9 KB)
- xc_bundle_20250825_012432.txt (2850 lines, 103.0 KB)
- xc_bundle_20250825_142614.txt (2572 lines, 90.7 KB)
- your_b3lyp.inp (7 lines, 181.0 B)
- your_b3lyp.json (182 lines, 4.5 KB)

=== FILE: bundle_xc.py | 1.9 KB ===
     1 | from datetime import datetime
     2 | from pathlib import Path
     3 | 
     4 | out = f"xc_bundle_{datetime.now():%Y%m%d_%H%M%S}.txt"
     5 | files = [
     6 |     # 1) The XC “chokepoint”
     7 |     "src/mrdft/xc_utils.h",
     8 |     "src/mrdft/xc_utils.cpp",
     9 | 
    10 |     # 2) Where functionals are created/parsed
    11 |     "src/mrdft/Functional.h",
    12 |     "src/mrdft/Functional.cpp",
    13 |     "src/mrdft/Factory.h",
    14 |     "src/mrdft/Factory.cpp",
    15 | 
    16 |     # 3) Callers that pass rho/sigma/tau/spin into the XC layer
    17 |     "src/mrdft/LDA.h",
    18 |     "src/mrdft/LDA.cpp",
    19 |     "src/mrdft/GGA.h",
    20 |     "src/mrdft/GGA.cpp",
    21 |     "src/mrdft/SpinLDA.h",
    22 |     "src/mrdft/SpinLDA.cpp",
    23 |     "src/mrdft/SpinGGA.h",
    24 |     "src/mrdft/SpinGGA.cpp",
    25 | 
    26 |     # 4) Operators / properties that might call XC directly
    27 |     "src/qmoperators/xc_operator_lda.cpp",
    28 |     "src/qmoperators/xc_operator_blyp.cpp",
    29 |     "src/qmoperators/xc_hessian_lda.cpp",
    30 |     "src/qmoperators/xc_hessian_pbe.cpp",
    31 |     "src/surface_forces/xcStress.h",
    32 |     "src/surface_forces/xcStress.cpp",
    33 |     "src/qmoperators/two_electron/XCPotential.h",
    34 |     "src/qmoperators/two_electron/XCPotential.cpp",
    35 |     "src/qmoperators/two_electron/XCPotentialD1.h",
    36 |     "src/qmoperators/two_electron/XCPotentialD1.cpp",
    37 |     "src/qmoperators/two_electron/XCPotentialD2.h",
    38 |     "src/qmoperators/two_electron/XCPotentialD2.cpp",
    39 | 
    40 |     # 5) Build system bits I’ll patch
    41 |     "CMakeLists.txt",
    42 |     "src/mrdft/CMakeLists.txt",
    43 |     "external/upstream/fetch_xcfun.cmake",
    44 |     "cmake/custom/main.cmake",
    45 | ]
    46 | 
    47 | with open(out, "w", encoding="utf-8", errors="replace") as o:
    48 |     for f in files:
    49 |         p = Path(f)
    50 |         if p.is_file():
    51 |             o.write(f"===== BEGIN {f} =====\n")
    52 |             try:
    53 |                 o.write(p.read_text(encoding="utf-8"))
    54 |             except UnicodeDecodeError:
    55 |                 # fallback for odd encodings
    56 |                 o.write(p.read_bytes().decode("utf-8", errors="replace"))
    57 |             o.write(f"\n===== END {f} =====\n\n")
    58 |         else:
    59 |             o.write(f"===== MISSING {f} =====\n\n")
    60 | 
    61 | print(f"Wrote {out}")
    62 | 

=== FILE: cmake/custom/main.cmake | 2.6 KB ===
     1 | file(MAKE_DIRECTORY ${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_INCLUDEDIR}/${PROJECT_NAME})
     2 | 
     3 | file(READ "${PROJECT_SOURCE_DIR}/VERSION" MRCHEM_VERSION)
     4 | string(STRIP "${MRCHEM_VERSION}" MRCHEM_VERSION)
     5 | 
     6 | string(REPLACE "." ";" VERSION_LIST ${MRCHEM_VERSION})
     7 | list(GET VERSION_LIST 0 MRCHEM_VERSION_MAJOR)
     8 | list(GET VERSION_LIST 1 MRCHEM_VERSION_MINOR)
     9 | 
    10 | configure_file (
    11 |   ${PROJECT_SOURCE_DIR}/config.h.in
    12 |   ${PROJECT_BINARY_DIR}/config.h
    13 |   @ONLY
    14 |   )
    15 | 
    16 | add_custom_command(
    17 |   OUTPUT
    18 |     ${PROJECT_BINARY_DIR}/version.h
    19 |   COMMAND
    20 |     ${CMAKE_COMMAND} -DINPUT_DIR=${PROJECT_SOURCE_DIR}
    21 |                      -DTARGET_DIR=${PROJECT_BINARY_DIR}
    22 |                      -DCMAKE_SYSTEM=${CMAKE_SYSTEM}
    23 |                      -DCMAKE_SYSTEM_PROCESSOR=${CMAKE_SYSTEM_PROCESSOR}
    24 |                      -DCMAKE_GENERATOR=${CMAKE_GENERATOR}
    25 |                      -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
    26 |                      -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}
    27 |                      -DCMAKE_CXX_COMPILER_VERSION=${CMAKE_CXX_COMPILER_VERSION}
    28 |                      -DMRCHEM_VERSION=${MRCHEM_VERSION}
    29 |                      -DMW_FILTER_SOURCE_DIR=${MW_FILTER_SOURCE_DIR}
    30 |                      -DMW_FILTER_INSTALL_DIR=${MW_FILTER_INSTALL_DIR}
    31 |                      -P ${CMAKE_CURRENT_LIST_DIR}/binary-info.cmake
    32 |   MAIN_DEPENDENCY
    33 |     ${PROJECT_SOURCE_DIR}/version.h.in
    34 |   WORKING_DIRECTORY
    35 |     ${CMAKE_CURRENT_LIST_DIR}
    36 |   )
    37 | 
    38 | # rebuild version_info.h every time
    39 | add_custom_target(
    40 |   mrchem-info
    41 |   ALL
    42 |   COMMAND
    43 |     ${CMAKE_COMMAND} -E touch_nocreate ${PROJECT_SOURCE_DIR}/version.h.in
    44 |   DEPENDS
    45 |     ${PROJECT_BINARY_DIR}/version.h
    46 |   )
    47 | 
    48 | # See here for the reason why: https://gitlab.kitware.com/cmake/cmake/issues/18399
    49 | set_source_files_properties(${PROJECT_BINARY_DIR}/version.h
    50 |   PROPERTIES
    51 |     GENERATED 1
    52 |   )
    53 | 
    54 | # We save CMAKE_BUILD_TYPE, as we will set it to Release for externals
    55 | 
    56 | # === LibXC backend switch (OFF by default, XCFun remains the default backend) ===
    57 | option(MRCHEM_ENABLE_LIBXC "Enable experimental LibXC backend (in addition to XCFun)" OFF)
    58 | 
    59 | 
    60 | set(_build_type ${CMAKE_BUILD_TYPE})
    61 | # Order IS important here!
    62 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_nlohmann_json.cmake)
    63 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_xcfun.cmake)
    64 | # Optional LibXC (only used if MRCHEM_ENABLE_LIBXC=ON and LibXC is found)
    65 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_libxc.cmake)
    66 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_eigen3.cmake)
    67 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_mrcpp.cmake)
    68 | # reset CMAKE_BUILD_TYPE to whatever it was for MRChem
    69 | set(CMAKE_BUILD_TYPE ${_build_type})
    70 | 
    71 | add_subdirectory(src)
    72 | add_subdirectory(python)
    73 | add_subdirectory(pilot)

=== FILE: collect_changed_code.py | 8.1 KB ===
     1 | #!/usr/bin/env python3
     2 | 
     3 | """
     4 | collect_changed_code.py
     5 | 
     6 | Purpose
     7 | -------
     8 | Collect all lines from files you've **changed** in a Git repo and write them
     9 | into a single text file with line numbers, grouped by file.
    10 | 
    11 | By default, it gathers:
    12 | - Unstaged changes (working tree vs HEAD)
    13 | - Staged changes (index vs HEAD)
    14 | - Untracked files (not ignored)
    15 | 
    16 | You can also compare against a specific ref/branch with --ref (e.g., main).
    17 | 
    18 | Usage
    19 | -----
    20 | # From the repo root:
    21 | python3 collect_changed_code.py
    22 | 
    23 | # Compare against a branch/ref:
    24 | python3 collect_changed_code.py --ref main
    25 | 
    26 | # Save to a custom outfile:
    27 | python3 collect_changed_code.py --outfile changed_code.txt
    28 | 
    29 | # Only include specific extensions:
    30 | python3 collect_changed_code.py --ext .py,.js,.ts
    31 | 
    32 | # Remove the default 5 MB per-file size guard:
    33 | python3 collect_changed_code.py --no-size-limit
    34 | """
    35 | import argparse
    36 | import os
    37 | import subprocess
    38 | import sys
    39 | import time
    40 | from typing import List, Set, Tuple
    41 | 
    42 | 
    43 | def run(cmd: List[str]) -> str:
    44 |     """Run a command and return stdout (text). Raise on non-zero exit."""
    45 |     r = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    46 |     if r.returncode != 0:
    47 |         raise RuntimeError(f"Command {' '.join(cmd)} failed:\n{r.stderr.strip()}")
    48 |     return r.stdout
    49 | 
    50 | 
    51 | def get_repo_root() -> str:
    52 |     """Return absolute path to the repository root."""
    53 |     root = run(["git", "rev-parse", "--show-toplevel"]).strip()
    54 |     return root
    55 | 
    56 | 
    57 | def list_changed_files(ref: str = None) -> List[str]:
    58 |     """
    59 |     Return a sorted list of changed/untracked file paths (relative to repo root).
    60 | 
    61 |     If ref is provided, returns files changed between ref...HEAD.
    62 |     Otherwise, combines:
    63 |       - Unstaged changes (git diff --name-only)
    64 |       - Staged changes (git diff --name-only --cached)
    65 |       - Untracked files (git ls-files --others --exclude-standard)
    66 |     """
    67 |     files: Set[str] = set()
    68 |     if ref:
    69 |         out = run(["git", "diff", "--name-only", f"{ref}...HEAD"])
    70 |         files.update([line.strip() for line in out.splitlines() if line.strip()])
    71 |     else:
    72 |         for cmd in [
    73 |             ["git", "diff", "--name-only"],
    74 |             ["git", "diff", "--name-only", "--cached"],
    75 |             ["git", "ls-files", "--others", "--exclude-standard"],
    76 |         ]:
    77 |             out = run(cmd)
    78 |             files.update([line.strip() for line in out.splitlines() if line.strip()])
    79 | 
    80 |     # Filter out paths that no longer exist (deleted, etc.)
    81 |     existing = [p for p in files if os.path.exists(p)]
    82 |     existing.sort()
    83 |     return existing
    84 | 
    85 | 
    86 | def looks_text(sample: bytes) -> bool:
    87 |     """Heuristic to check if a byte sample is text-like (not binary)."""
    88 |     if b"\x00" in sample:
    89 |         return False
    90 |     if not sample:
    91 |         return True
    92 |     # Allow typical printable ASCII and common whitespace/newlines
    93 |     text_like = sum((32 <= b <= 126) or b in (9, 10, 13) for b in sample)
    94 |     ratio = text_like / len(sample)
    95 |     return ratio >= 0.70
    96 | 
    97 | 
    98 | def is_binary_file(path: str, sample_size: int = 8192) -> bool:
    99 |     try:
   100 |         with open(path, "rb") as f:
   101 |             sample = f.read(sample_size)
   102 |         return not looks_text(sample)
   103 |     except Exception:
   104 |         # If we can't read or something goes wrong, assume binary to be safe.
   105 |         return True
   106 | 
   107 | 
   108 | def should_include(path: str, exts: List[str]) -> bool:
   109 |     if not os.path.isfile(path):
   110 |         return False
   111 |     if exts:
   112 |         plower = path.lower()
   113 |         return any(plower.endswith(e.lower().strip()) for e in exts if e.strip())
   114 |     return True
   115 | 
   116 | 
   117 | def human_size(bytes_num: int) -> str:
   118 |     for unit in ["B", "KB", "MB", "GB"]:
   119 |         if bytes_num < 1024.0:
   120 |             return f"{bytes_num:.1f} {unit}"
   121 |         bytes_num /= 1024.0
   122 |     return f"{bytes_num:.1f} TB"
   123 | 
   124 | 
   125 | def collect_lines(
   126 |     files: List[str],
   127 |     outfile: str,
   128 |     exts: List[str],
   129 |     no_size_limit: bool,
   130 |     max_mb: float = 5.0,
   131 | ) -> Tuple[int, int, int]:
   132 |     """
   133 |     Write all lines from target files into outfile.
   134 |     Returns (num_files_included, total_lines_written, num_files_skipped).
   135 |     """
   136 |     repo_root = get_repo_root()
   137 |     abs_out = os.path.abspath(outfile)
   138 | 
   139 |     included = 0
   140 |     skipped = 0
   141 |     total_lines = 0
   142 |     max_bytes = int(max_mb * 1024 * 1024)
   143 | 
   144 |     timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
   145 |     with open(outfile, "w", encoding="utf-8", errors="replace") as out:
   146 |         out.write(f"# Changed Code Dump\n")
   147 |         out.write(f"# Repo: {repo_root}\n")
   148 |         out.write(f"# Generated: {timestamp}\n\n")
   149 | 
   150 |         # Index
   151 |         out.write("## Files Included\n")
   152 | 
   153 |         index_entries = []
   154 |         file_infos = []  # (path, is_binary, size_bytes, line_count)
   155 |         for rel in files:
   156 |             # Respect extension filter
   157 |             if not should_include(rel, exts):
   158 |                 skipped += 1
   159 |                 continue
   160 | 
   161 |             size_bytes = 0
   162 |             try:
   163 |                 size_bytes = os.path.getsize(rel)
   164 |             except OSError:
   165 |                 skipped += 1
   166 |                 continue
   167 | 
   168 |             if not no_size_limit and size_bytes > max_bytes:
   169 |                 file_infos.append((rel, False, size_bytes, -1))
   170 |                 skipped += 1
   171 |                 continue
   172 | 
   173 |             binary = is_binary_file(rel)
   174 |             if binary:
   175 |                 file_infos.append((rel, True, size_bytes, 0))
   176 |                 skipped += 1
   177 |                 continue
   178 | 
   179 |             # Count lines to put in index (we'll read again later)
   180 |             try:
   181 |                 with open(rel, "r", encoding="utf-8", errors="replace") as f:
   182 |                     lines = f.read().splitlines()
   183 |                 file_infos.append((rel, False, size_bytes, len(lines)))
   184 |             except Exception:
   185 |                 file_infos.append((rel, False, size_bytes, -1))
   186 |                 skipped += 1
   187 | 
   188 |         for rel, binary, size_bytes, line_count in file_infos:
   189 |             if binary or line_count <= 0:
   190 |                 continue
   191 |             index_entries.append(f"- {rel} ({line_count} lines, {human_size(size_bytes)})")
   192 | 
   193 |         if index_entries:
   194 |             out.write("\n".join(index_entries) + "\n\n")
   195 |         else:
   196 |             out.write("(no text files to include)\n\n")
   197 | 
   198 |         # Body
   199 |         for rel, binary, size_bytes, line_count in file_infos:
   200 |             if binary or line_count <= 0:
   201 |                 continue
   202 | 
   203 |             included += 1
   204 |             out.write(f"=== FILE: {rel} | {human_size(size_bytes)} ===\n")
   205 |             try:
   206 |                 with open(rel, "r", encoding="utf-8", errors="replace") as f:
   207 |                     for i, line in enumerate(f.read().splitlines(), 1):
   208 |                         out.write(f"{i:6d} | {line}\n")
   209 |                         total_lines += 1
   210 |             except Exception as e:
   211 |                 out.write(f"[ERROR] Could not read file: {e}\n")
   212 |             out.write("\n")
   213 | 
   214 |         out.write(f"# Summary: {included} files, {total_lines} lines written. Skipped {skipped}.\n")
   215 | 
   216 |     return included, total_lines, skipped
   217 | 
   218 | 
   219 | def main():
   220 |     parser = argparse.ArgumentParser(description="Collect lines from changed files into a single text file.")
   221 |     parser.add_argument("--ref", help="Compare against this ref/branch instead of using working-tree status (e.g., 'main').")
   222 |     parser.add_argument("--outfile", default="changed_code.txt", help="Path to output text file (default: changed_code.txt).")
   223 |     parser.add_argument(
   224 |         "--ext",
   225 |         help="Comma-separated list of file extensions to include (e.g., .py,.js,.ts). Default: include all.",
   226 |     )
   227 |     parser.add_argument("--no-size-limit", action="store_true", help="Disable the 5 MB per-file size limit.")
   228 |     args = parser.parse_args()
   229 | 
   230 |     # Ensure we're inside a git repo
   231 |     try:
   232 |         repo_root = get_repo_root()
   233 |     except Exception as e:
   234 |         print(f"Error: {e}", file=sys.stderr)
   235 |         sys.exit(1)
   236 | 
   237 |     os.chdir(repo_root)
   238 | 
   239 |     try:
   240 |         files = list_changed_files(args.ref)
   241 |     except Exception as e:
   242 |         print(f"Error listing changed files: {e}", file=sys.stderr)
   243 |         sys.exit(2)
   244 | 
   245 |     exts = None
   246 |     if args.ext:
   247 |         exts = [e.strip() for e in args.ext.split(",") if e.strip()]
   248 | 
   249 |     included, total_lines, skipped = collect_lines(
   250 |         files=files,
   251 |         outfile=args.outfile,
   252 |         exts=exts,
   253 |         no_size_limit=args.no_size_limit,
   254 |     )
   255 | 
   256 |     print(f"Wrote {total_lines} lines from {included} files to {os.path.abspath(args.outfile)} (skipped {skipped}).")
   257 | 
   258 | 
   259 | if __name__ == "__main__":
   260 |     main()
   261 | 

=== FILE: dump_mrchem_files.py | 3.9 KB ===
     1 | #!/usr/bin/env python3
     2 | """
     3 | Dump selected files' full contents into a single text (and optional Markdown) file.
     4 | 
     5 | Usage:
     6 |   python dump_mrchem_files.py [--markdown]
     7 | 
     8 | - Always writes: mrchem_selection_dump_YYYYMMDD_HHMMSS.txt
     9 | - If --markdown is given, also writes: mrchem_selection_dump_YYYYMMDD_HHMMSS.md
    10 | """
    11 | 
    12 | from __future__ import annotations
    13 | from datetime import datetime
    14 | from pathlib import Path
    15 | import argparse
    16 | import sys
    17 | 
    18 | def infer_lang(path: str) -> str:
    19 |     """
    20 |     Infer a Markdown code fence language from the file extension.
    21 |     Defaults to empty string (no tag) if not recognized.
    22 |     """
    23 |     ext = Path(path).suffix.lower()
    24 |     return {
    25 |         ".h": "cpp",
    26 |         ".hpp": "cpp",
    27 |         ".hh": "cpp",
    28 |         ".c": "c",
    29 |         ".cc": "cpp",
    30 |         ".cpp": "cpp",
    31 |         ".cxx": "cpp",
    32 |         ".cu": "cuda",
    33 |         ".py": "python",
    34 |         ".cmake": "cmake",
    35 |         ".in": "",  # template; leave untagged
    36 |         ".json": "json",
    37 |         ".txt": "",
    38 |         ".md": "markdown",
    39 |         ".toml": "toml",
    40 |         ".yml": "yaml",
    41 |         ".yaml": "yaml",
    42 |     }.get(ext, "")
    43 | 
    44 | def main():
    45 |     parser = argparse.ArgumentParser()
    46 |     parser.add_argument("--markdown", action="store_true", help="Also write a Markdown version with code fences.")
    47 |     args = parser.parse_args()
    48 | 
    49 |     # Exact list (in order) as requested
    50 |     files = [
    51 |         # Core DFT backend selection & wiring
    52 |         "src/mrdft/Factory.h",
    53 |         "src/mrdft/Factory.cpp",
    54 |         "src/mrdft/LibXCBackend.h",
    55 |         "src/mrdft/LibXCBackend.cpp",
    56 |         "src/mrdft/xc_backend.h",
    57 |         "src/mrdft/xc_backend_xcfun.cpp",
    58 | 
    59 |         # Program environment & JSON intake
    60 |         "src/mrenv.h",
    61 |         "src/mrenv.cpp",
    62 |         "src/utils/json_utils.h",
    63 |         "src/utils/json_utils.cpp",  # optional; included if it exists
    64 | 
    65 |         # Build system
    66 |         "CMakeLists.txt",
    67 |         "src/mrdft/CMakeLists.txt",
    68 |         "external/upstream/fetch_libxc.cmake",
    69 |         # Other CMake that may gate/define MRCHEM_ENABLE_LIBXC
    70 |         "cmake/custom/main.cmake",
    71 | 
    72 |         # Optional but helpful (Python front-end)
    73 |         "python/mrchem/cli.py",
    74 |         "python/mrchem/config.py.in",
    75 |     ]
    76 | 
    77 |     ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    78 |     out_txt = f"mrchem_selection_dump_{ts}.txt"
    79 |     out_md = f"mrchem_selection_dump_{ts}.md"
    80 | 
    81 |     missing_any = False
    82 | 
    83 |     # Write TXT bundle
    84 |     with open(out_txt, "w", encoding="utf-8", errors="replace") as o:
    85 |         for f in files:
    86 |             p = Path(f)
    87 |             if p.is_file():
    88 |                 o.write(f"===== BEGIN {f} =====\n")
    89 |                 try:
    90 |                     o.write(p.read_text(encoding="utf-8"))
    91 |                 except UnicodeDecodeError:
    92 |                     o.write(p.read_bytes().decode("utf-8", errors="replace"))
    93 |                 o.write(f"\n===== END {f} =====\n\n")
    94 |             else:
    95 |                 o.write(f"===== MISSING {f} =====\n\n")
    96 |                 missing_any = True
    97 | 
    98 |     # Optional Markdown bundle with code fences
    99 |     if args.markdown:
   100 |         with open(out_md, "w", encoding="utf-8", errors="replace") as m:
   101 |             m.write(f"# MRChem selected files (dumped {ts})\n\n")
   102 |             for f in files:
   103 |                 p = Path(f)
   104 |                 m.write(f"## {f}\n\n")
   105 |                 if p.is_file():
   106 |                     lang = infer_lang(f)
   107 |                     fence = lang if lang else ""
   108 |                     m.write(f"```{fence}\n")
   109 |                     try:
   110 |                         m.write(p.read_text(encoding="utf-8"))
   111 |                     except UnicodeDecodeError:
   112 |                         m.write(p.read_bytes().decode("utf-8", errors="replace"))
   113 |                     m.write("\n```\n\n")
   114 |                 else:
   115 |                     m.write("_Missing file_\n\n")
   116 |                     missing_any = True
   117 | 
   118 |     print(f"Wrote {out_txt}")
   119 |     if args.markdown:
   120 |         print(f"Wrote {out_md}")
   121 |     if missing_any:
   122 |         print("Note: Some files were missing. See markers in the output.", file=sys.stderr)
   123 | 
   124 | if __name__ == "__main__":
   125 |     main()
   126 | 

=== FILE: external/upstream/fetch_libxc.cmake | 882.0 B ===
     1 | # Try to find LibXC. We only enable the backend if we both (a) opt in with
     2 | # MRCHEM_ENABLE_LIBXC=ON and (b) actually find a working Libxc::xc target.
     3 | 
     4 | find_package(Libxc QUIET)
     5 | 
     6 | # Some distros provide an imported target Libxc::xc, some only variables.
     7 | if(TARGET Libxc::xc)
     8 |   set(HAVE_LIBXC TRUE)
     9 |   get_property(_loc TARGET Libxc::xc PROPERTY LOCATION)
    10 |   message(STATUS "Found LibXC: ${_loc}")
    11 | elseif(LIBXC_FOUND)
    12 |   # Compat path: construct an IMPORTED target from legacy variables.
    13 |   add_library(Libxc::xc UNKNOWN IMPORTED)
    14 |   set_target_properties(Libxc::xc PROPERTIES
    15 |     IMPORTED_LOCATION "${LIBXC_LIBRARIES}"
    16 |     INTERFACE_INCLUDE_DIRECTORIES "${LIBXC_INCLUDE_DIRS}"
    17 |   )
    18 |   set(HAVE_LIBXC TRUE)
    19 |   message(STATUS "Found LibXC (legacy variables).")
    20 | else()
    21 |   set(HAVE_LIBXC FALSE)
    22 |   message(STATUS "LibXC not found – LibXC backend will be disabled unless you install it.")
    23 | endif()

=== FILE: h20_b3lyp.in | 158.0 B ===
     1 | world_prec = 1.0e-4
     2 | 
     3 | WaveFunction {
     4 |   method = B3LYP
     5 | }
     6 | 
     7 | Molecule {
     8 | $coords
     9 | O  0.0000  0.0000 -0.125
    10 | H -1.4375  0.0000  1.025
    11 | H  1.4375  0.0000  1.025
    12 | $end
    13 | }
    14 | 

=== FILE: h2_b3lyp.fixed.json | 2.6 KB ===
     1 | {
     2 |   "input": {
     3 |     "schema_name": "mrchem_input",
     4 |     "schema_version": 1,
     5 |     "molecule": {
     6 |       "charge": 0,
     7 |       "multiplicity": 1,
     8 |       "coords": [
     9 |         {
    10 |           "atom": "H",
    11 |           "xyz": [
    12 |             -0.7,
    13 |             0.0,
    14 |             0.0
    15 |           ]
    16 |         },
    17 |         {
    18 |           "atom": "H",
    19 |           "xyz": [
    20 |             0.7,
    21 |             0.0,
    22 |             0.0
    23 |           ]
    24 |         }
    25 |       ]
    26 |     },
    27 |     "mra": {
    28 |       "basis_type": "legendre",
    29 |       "basis_order": 7,
    30 |       "max_scale": 7,
    31 |       "min_scale": 3,
    32 |       "boxes": [
    33 |         1,
    34 |         1,
    35 |         1
    36 |       ],
    37 |       "corner": [
    38 |         0,
    39 |         0,
    40 |         0
    41 |       ]
    42 |     },
    43 |     "scf_calculation": {
    44 |       "fock_operator": {
    45 |         "kinetic_operator": {
    46 |           "derivative": "abgv_00"
    47 |         },
    48 |         "nuclear_operator": {
    49 |           "proj_prec": 0.000001,
    50 |           "smooth_prec": 0.000001,
    51 |           "shared_memory": false
    52 |         },
    53 |         "coulomb_operator": {
    54 |           "poisson_prec": 0.000001,
    55 |           "shared_memory": false
    56 |         },
    57 |         "xc_operator": {
    58 |           "shared_memory": false,
    59 |           "xc_functional": {
    60 |             "spin": false,
    61 |             "cutoff": 1E-12,
    62 |             "functionals": [
    63 |               {
    64 |                 "coef": 1.0,
    65 |                 "name": "B3LYP"
    66 |               }
    67 |             ]
    68 |           }
    69 |         }
    70 |       },
    71 |       "initial_guess": {
    72 |         "type": "sad",
    73 |         "prec": 0.0001,
    74 |         "restricted": true,
    75 |         "screen": null,
    76 |         "localize": null,
    77 |         "rotate": null
    78 |       },
    79 |       "scf_solver": {
    80 |         "method": "DFT",
    81 |         "kain": true,
    82 |         "max_iter": 80,
    83 |         "start_prec": 0.0001,
    84 |         "final_prec": 0.000001,
    85 |         "helmholtz_prec": 0.000001,
    86 |         "orbital_thrs": 0.000001,
    87 |         "energy_thrs": 1E-8,
    88 |         "kain_dim": 7,
    89 |         "localize": null,
    90 |         "checkpoint": null
    91 |       },
    92 |       "plots": {
    93 |         "density": null
    94 |       }
    95 |     },
    96 |     "printer": {
    97 |       "file_name": "h2_b3lyp.out",
    98 |       "print_level": 2,
    99 |       "print_prec": 10,
   100 |       "print_width": 120,
   101 |       "print_mpi": false
   102 |     },
   103 |     "mpi": {
   104 |       "numerically_exact": null
   105 |     },
   106 |     "fock_operator": {
   107 |       "nuclear_operator": {
   108 |         "shared_memory": null
   109 |       },
   110 |       "coulomb_operator": {
   111 |         "shared_memory": null
   112 |       },
   113 |       "xc_operator": {
   114 |         "shared_memory": null,
   115 |         "xc_functional": {
   116 |           "spin": null
   117 |         }
   118 |       },
   119 |       "zora_operator": {
   120 |         "include_nuclear": null,
   121 |         "include_coulomb": null,
   122 |         "include_xc": null,
   123 |         "isAZORA": null
   124 |       },
   125 |       "reaction_operator": {
   126 |         "nonequilibrium": null
   127 |       }
   128 |     }
   129 |   }
   130 | }

=== FILE: h2_b3lyp.in | 133.0 B ===
     1 | world_prec = 1.0e-4
     2 | 
     3 | WaveFunction {
     4 |   method = B3LYP
     5 | }
     6 | 
     7 | Molecule {
     8 | $coords
     9 | H  0.0000  0.0000  -0.35
    10 | H  0.0000  0.0000   0.35
    11 | $end
    12 | }
    13 | 

=== FILE: h2_b3lyp.json | 1.9 KB ===
     1 | {
     2 |   "input": {
     3 |     "schema_name": "mrchem_input",
     4 |     "schema_version": 1,
     5 |     "molecule": {
     6 |       "charge": 0,
     7 |       "multiplicity": 1,
     8 |       "coords": [
     9 |         {
    10 |           "atom": "H",
    11 |           "xyz": [
    12 |             -0.7,
    13 |             0.0,
    14 |             0.0
    15 |           ]
    16 |         },
    17 |         {
    18 |           "atom": "H",
    19 |           "xyz": [
    20 |             0.7,
    21 |             0.0,
    22 |             0.0
    23 |           ]
    24 |         }
    25 |       ]
    26 |     },
    27 |     "mra": {
    28 |       "basis_type": "legendre",
    29 |       "basis_order": 7,
    30 |       "max_scale": 7,
    31 |       "min_scale": 3,
    32 |       "boxes": [
    33 |         1,
    34 |         1,
    35 |         1
    36 |       ],
    37 |       "corner": [
    38 |         0,
    39 |         0,
    40 |         0
    41 |       ]
    42 |     },
    43 |     "scf_calculation": {
    44 |       "fock_operator": {
    45 |         "kinetic_operator": {
    46 |           "derivative": "abgv_00"
    47 |         },
    48 |         "nuclear_operator": {
    49 |           "proj_prec": 0.000001,
    50 |           "smooth_prec": 0.000001,
    51 |           "shared_memory": false
    52 |         },
    53 |         "coulomb_operator": {
    54 |           "poisson_prec": 0.000001,
    55 |           "shared_memory": false
    56 |         },
    57 |         "xc_operator": {
    58 |           "shared_memory": false,
    59 |           "xc_functional": {
    60 |             "spin": false,
    61 |             "cutoff": 1E-12,
    62 |             "functionals": [
    63 |               {
    64 |                 "coef": 1.0,
    65 |                 "name": "B3LYP"
    66 |               }
    67 |             ]
    68 |           }
    69 |         }
    70 |       },
    71 |       "initial_guess": {
    72 |         "type": "sad",
    73 |         "prec": 0.0001,
    74 |         "restricted": true
    75 |       },
    76 |       "scf_solver": {
    77 |         "method": "DFT",
    78 |         "kain": true,
    79 |         "max_iter": 80,
    80 |         "start_prec": 0.0001,
    81 |         "final_prec": 0.000001,
    82 |         "helmholtz_prec": 0.000001,
    83 |         "orbital_thrs": 0.000001,
    84 |         "energy_thrs": 1E-8,
    85 |         "kain_dim": 7
    86 |       }
    87 |     },
    88 |     "printer": {
    89 |       "file_name": "h2_b3lyp.out",
    90 |       "print_level": 2,
    91 |       "print_prec": 10,
    92 |       "print_width": 120,
    93 |       "print_mpi": false
    94 |     }
    95 |   }
    96 | }

=== FILE: h2o.json | 4.3 KB ===
     1 | {
     2 |   "input": {
     3 |     "schema_name": "mrchem_input",
     4 |     "schema_version": 1,
     5 |     "mpi": {
     6 |       "numerically_exact": true,
     7 |       "shared_memory_size": 10000,
     8 |       "bank_size": -1,
     9 |       "omp_threads": -1
    10 |     },
    11 |     "mra": {
    12 |       "basis_type": "interpolating",
    13 |       "basis_order": 6,
    14 |       "boxes": [
    15 |         2,
    16 |         2,
    17 |         2
    18 |       ],
    19 |       "corner": [
    20 |         -1,
    21 |         -1,
    22 |         -1
    23 |       ],
    24 |       "min_scale": -5,
    25 |       "max_scale": 20
    26 |     },
    27 |     "printer": {
    28 |       "print_level": 0,
    29 |       "print_mpi": false,
    30 |       "print_prec": 6,
    31 |       "print_width": 75,
    32 |       "print_constants": false,
    33 |       "file_name": "h2o"
    34 |     },
    35 |     "molecule": {
    36 |       "multiplicity": 1,
    37 |       "charge": 0,
    38 |       "coords": [
    39 |         {
    40 |           "atom": "o",
    41 |           "xyz": [
    42 |             0.0,
    43 |             0.0,
    44 |             -0.12868309568322003
    45 |           ],
    46 |           "r_rms": 5.0580178957e-05
    47 |         },
    48 |         {
    49 |           "atom": "h",
    50 |           "xyz": [
    51 |             -1.4375,
    52 |             0.0,
    53 |             1.0213169043167798
    54 |           ],
    55 |           "r_rms": 2.6569547399e-05
    56 |         },
    57 |         {
    58 |           "atom": "h",
    59 |           "xyz": [
    60 |             1.4375,
    61 |             0.0,
    62 |             1.0213169043167798
    63 |           ],
    64 |           "r_rms": 2.6569547399e-05
    65 |         }
    66 |       ]
    67 |     },
    68 |     "scf_calculation": {
    69 |       "fock_operator": {
    70 |         "kinetic_operator": {
    71 |           "derivative": "abgv_55"
    72 |         },
    73 |         "nuclear_operator": {
    74 |           "proj_prec": 0.001,
    75 |           "smooth_prec": 0.001,
    76 |           "nuclear_model": "point_like",
    77 |           "shared_memory": false
    78 |         },
    79 |         "coulomb_operator": {
    80 |           "poisson_prec": 0.001,
    81 |           "shared_memory": false
    82 |         },
    83 |         "exchange_operator": {
    84 |           "poisson_prec": 0.001,
    85 |           "exchange_prec": -1.0
    86 |         },
    87 |         "xc_operator": {
    88 |           "shared_memory": false,
    89 |           "xc_functional": {
    90 |             "spin": false,
    91 |             "cutoff": 0.0,
    92 |             "functionals": [
    93 |               {
    94 |                 "name": "blyp",
    95 |                 "coef": 1.0
    96 |               }
    97 |             ]
    98 |           }
    99 |         }
   100 |       },
   101 |       "initial_guess": {
   102 |         "zeta": 0,
   103 |         "prec": 0.001,
   104 |         "type": "gto",
   105 |         "method": "DFT",
   106 |         "relativity": "None",
   107 |         "environment": "None",
   108 |         "external_field": "None",
   109 |         "screen": 16.0,
   110 |         "localize": true,
   111 |         "rotate": true,
   112 |         "restricted": true,
   113 |         "file_chk": "checkpoint/phi_scf",
   114 |         "file_basis": "initial_guess/mrchem.bas",
   115 |         "file_gto_p": "initial_guess/mrchem.mop",
   116 |         "file_gto_a": "initial_guess/mrchem.moa",
   117 |         "file_gto_b": "initial_guess/mrchem.mob",
   118 |         "file_phi_p": "initial_guess/phi_p_scf",
   119 |         "file_phi_a": "initial_guess/phi_a_scf",
   120 |         "file_phi_b": "initial_guess/phi_b_scf",
   121 |         "file_CUBE_p": "cube_vectors/CUBE_p_vector.json",
   122 |         "file_CUBE_a": "cube_vectors/CUBE_a_vector.json",
   123 |         "file_CUBE_b": "cube_vectors/CUBE_b_vector.json"
   124 |       },
   125 |       "properties": {
   126 |         "dipole_moment": {
   127 |           "dip-1": {
   128 |             "operator": "h_e_dip",
   129 |             "precision": 0.001,
   130 |             "r_O": [
   131 |               0.0,
   132 |               0.0,
   133 |               0.0
   134 |             ]
   135 |           }
   136 |         },
   137 |         "quadrupole_moment": {
   138 |           "quad-1": {
   139 |             "operator": "h_e_quad",
   140 |             "precision": 0.001,
   141 |             "r_O": [
   142 |               0.0,
   143 |               0.0,
   144 |               0.0
   145 |             ]
   146 |           }
   147 |         }
   148 |       }
   149 |     },
   150 |     "rsp_calculations": {},
   151 |     "geom_opt": {
   152 |       "run": false,
   153 |       "use_previous_guess": false,
   154 |       "init_step_size": -0.5,
   155 |       "minimal_step_size": 0.01,
   156 |       "max_history_length": 10,
   157 |       "subspace_tolerance": 0.001,
   158 |       "max_iter": 100,
   159 |       "max_force_component": 0.005
   160 |     },
   161 |     "constants": {
   162 |       "hartree2simagnetizability": 78.9451185,
   163 |       "light_speed": 137.035999084,
   164 |       "angstrom2bohrs": 1.8897261246257702,
   165 |       "hartree2kjmol": 2625.4996394798254,
   166 |       "hartree2kcalmol": 627.5094740630558,
   167 |       "hartree2ev": 27.211386245988,
   168 |       "hartree2wavenumbers": 219474.6313632,
   169 |       "fine_structure_constant": 0.0072973525693,
   170 |       "electron_g_factor": -2.00231930436256,
   171 |       "dipmom_au2debye": 2.5417464739297717,
   172 |       "boltzmann_constant": 1.380649e-23,
   173 |       "elementary_charge": 1.602176634e-19,
   174 |       "e0": 8.8541878128e-12,
   175 |       "N_a": 6.02214076e+23,
   176 |       "meter2bohr": 18897261246.2577
   177 |     }
   178 |   }
   179 | }

=== FILE: mrchem_selection_dump_20250825_193702.txt | 45.5 KB ===
     1 | ===== BEGIN src/mrdft/Factory.h =====
     2 | #pragma once
     3 | 
     4 | #include <MRCPP/MWOperators>
     5 | #include <XCFun/xcfun.h>
     6 | 
     7 | #include "MRDFT.h"
     8 | 
     9 | namespace mrdft {
    10 | 
    11 | class Factory final {
    12 | public:
    13 |     Factory(const mrcpp::MultiResolutionAnalysis<3> &MRA);
    14 |     ~Factory() = default;
    15 | 
    16 |     void setSpin(bool s) { spin = s; }
    17 |     void setOrder(int k) { order = k; }
    18 |     void setUseGamma(bool g) { gamma = g; }
    19 |     void setLogGradient(bool lg) { log_grad = lg; }
    20 |     void setDensityCutoff(double c) { cutoff = c; }
    21 |     void setDerivative(const std::string &n) { diff_s = n; }
    22 |     void setFunctional(const std::string &n, double c = 1.0) { xcfun_set(xcfun_p.get(), n.c_str(), c); }
    23 | 
    24 |     // Optional: select backend and (for LibXC) functional IDs via code (we also read env vars)
    25 |     void setBackend(const std::string &b) { backend = b; }
    26 |     void setLibXCIDs(const std::vector<int> &ids_in) { libxc_ids = ids_in; }
    27 | 
    28 |     std::unique_ptr<MRDFT> build();
    29 | 
    30 | private:
    31 |     int order{1};
    32 |     bool spin{false};
    33 |     bool gamma{false};
    34 |     bool log_grad{false};
    35 |     double cutoff{-1.0};
    36 |     std::string diff_s{"abgv_00"};
    37 |     std::string backend{"xcfun"};           // "xcfun" (default) or "libxc"
    38 |     std::vector<int> libxc_ids;             // used only if backend == "libxc"
    39 |     const mrcpp::MultiResolutionAnalysis<3> mra;
    40 | 
    41 |     XC_p xcfun_p;
    42 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> diff_p;
    43 | };
    44 | 
    45 | } // namespace mrdft
    46 | 
    47 | ===== END src/mrdft/Factory.h =====
    48 | 
    49 | ===== BEGIN src/mrdft/Factory.cpp =====
    50 | /*
    51 |  * MRChem, a numerical real-space code for molecular electronic structure
    52 |  * calculations within the self-consistent field (SCF) approximations of quantum
    53 |  * chemistry (Hartree-Fock and Density Functional Theory).
    54 |  *
    55 |  * This file is part of MRChem.
    56 |  */
    57 | 
    58 | #include "Factory.h"
    59 | 
    60 | #include <algorithm>
    61 | #include <cctype>
    62 | #include <cstdlib>
    63 | #include <sstream>
    64 | #include <string>
    65 | #include <vector>
    66 | 
    67 | #include <MRCPP/MWOperators>
    68 | #include <MRCPP/Printer>
    69 | #include <XCFun/xcfun.h>
    70 | 
    71 | #include "GGA.h"
    72 | #include "Grid.h"
    73 | #include "LDA.h"
    74 | #include "MRDFT.h"
    75 | #include "SpinGGA.h"
    76 | #include "SpinLDA.h"
    77 | 
    78 | // LibXC adapters (compiled only if enabled at configure time)
    79 | #ifdef MRCHEM_ENABLE_LIBXC
    80 | #  include "LibXCBackend.h"
    81 | #endif
    82 | 
    83 | namespace mrdft {
    84 | 
    85 | // ------------------------------- helpers ---------------------------------
    86 | 
    87 | static std::string to_lower(std::string s) {
    88 |     std::transform(s.begin(), s.end(), s.begin(),
    89 |                    [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
    90 |     return s;
    91 | }
    92 | 
    93 | static std::vector<int> parse_ids_csv(const char* csv_env) {
    94 |     std::vector<int> out;
    95 |     if (!csv_env) return out;
    96 |     std::stringstream ss(csv_env);
    97 |     for (std::string tok; std::getline(ss, tok, ','); ) {
    98 |         if (!tok.empty()) out.push_back(std::stoi(tok));
    99 |     }
   100 |     return out;
   101 | }
   102 | 
   103 | // ------------------------------ Factory ----------------------------------
   104 | 
   105 | Factory::Factory(const mrcpp::MultiResolutionAnalysis<3> &MRA)
   106 |     : mra(MRA)
   107 |     , xcfun_p(xcfun_new(), xcfun_delete) {}
   108 | 
   109 | /** @brief Build a MRDFT object from the currently defined parameters
   110 |  *
   111 |  * Backend selection policy:
   112 |  *  - Default: XCFun
   113 |  *  - If env MRCHEM_XC_BACKEND=libxc (or MRCHEM_FORCE_LIBXC=1), choose LibXC (if compiled)
   114 |  *  - LibXC IDs are taken from Factory::libxc_ids if set; otherwise from env MRCHEM_LIBXC_IDS
   115 |  *  - If LibXC chosen but no IDs available, abort with a clear message
   116 |  */
   117 | std::unique_ptr<MRDFT> Factory::build() {
   118 |     // Init DFT grid
   119 |     auto grid_p = std::make_unique<Grid>(mra);
   120 | 
   121 |     // Decide backend from member + env (env wins)
   122 |     std::string backend_eff = to_lower(backend);
   123 |     if (const char* be = std::getenv("MRCHEM_XC_BACKEND")) {
   124 |         backend_eff = to_lower(std::string(be));
   125 |     }
   126 |     const bool force_libxc = (std::getenv("MRCHEM_FORCE_LIBXC") != nullptr);
   127 |     const bool want_libxc  = force_libxc || (backend_eff == "libxc");
   128 | 
   129 |     // Determine LibXC IDs if needed
   130 |     std::vector<int> ids = libxc_ids; // may be pre-filled by caller
   131 |     if (ids.empty()) {
   132 |         // env override
   133 |         auto env_ids = parse_ids_csv(std::getenv("MRCHEM_LIBXC_IDS"));
   134 |         if (!env_ids.empty()) ids = std::move(env_ids);
   135 |     }
   136 | 
   137 |     // Flag whether LibXC adapters are compiled in
   138 | #ifdef MRCHEM_ENABLE_LIBXC
   139 |     const bool libxc_available = true;
   140 | #else
   141 |     const bool libxc_available = false;
   142 | #endif
   143 |     const bool use_libxc = (want_libxc && libxc_available);
   144 | 
   145 |     // ---------------------------------------------------------------------
   146 |     // XCFun user-eval setup (parity with upstream)
   147 |     // ---------------------------------------------------------------------
   148 |     bool gga = xcfun_is_gga(xcfun_p.get());
   149 |     bool lda = !gga;
   150 | 
   151 |     unsigned int mode          = 1;                    // partial derivative mode
   152 |     unsigned int func_type     = (gga ? 1u : 0u);      // LDA(0) or GGA(1)
   153 |     unsigned int dens_type     = 1 + spin;             // n (1) or alpha&beta (2)
   154 |     unsigned int laplacian     = 0;                    // no laplacian
   155 |     unsigned int kinetic       = 0;                    // no kinetic energy density
   156 |     unsigned int current       = 0;                    // no current density
   157 |     unsigned int exp_deriv     = !gamma;               // use gamma or explicit derivatives
   158 |     if (!gga) exp_deriv = 0;                           // fall back to gamma-type if LDA
   159 | 
   160 |     xcfun_user_eval_setup(xcfun_p.get(), order, func_type, dens_type,
   161 |                           mode, laplacian, kinetic, current, exp_deriv);
   162 | 
   163 |     // ---------------------------------------------------------------------
   164 |     // MW derivative operator if GGA
   165 |     // ---------------------------------------------------------------------
   166 |     if (gga) {
   167 |         if      (diff_s == "bspline") diff_p = std::make_unique<mrcpp::BSOperator<3>>(mra, 1);
   168 |         else if (diff_s == "abgv_00") diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.0, 0.0);
   169 |         else if (diff_s == "abgv_55") diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.5, 0.5);
   170 |         // else leave null; Functional classes can validate as needed
   171 |     }
   172 | 
   173 |     // ---------------------------------------------------------------------
   174 |     // Build Functional (choose LibXC adapters when requested & available)
   175 |     // ---------------------------------------------------------------------
   176 |     std::unique_ptr<Functional> func_p{nullptr};
   177 | 
   178 |     if (spin) {
   179 |         if (gga) {
   180 | #ifdef MRCHEM_ENABLE_LIBXC
   181 |             if (use_libxc) {
   182 |                 if (ids.empty()) {
   183 |                     MSG_ABORT("LibXC backend selected but no LibXC IDs specified. "
   184 |                               "Set MRCHEM_LIBXC_IDS (e.g. 402 for B3LYP, or '106,131' for BLYP), "
   185 |                               "or call Factory::setLibXCIDs().");
   186 |                 }
   187 |                 func_p = std::make_unique<LibXCSpinGGA>(order, xcfun_p, diff_p, ids);
   188 |             } else
   189 | #endif
   190 |             {
   191 |                 func_p = std::make_unique<SpinGGA>(order, xcfun_p, diff_p);
   192 |             }
   193 |         } else if (lda) {
   194 | #ifdef MRCHEM_ENABLE_LIBXC
   195 |             if (use_libxc) {
   196 |                 if (ids.empty()) {
   197 |                     MSG_ABORT("LibXC backend selected but no LibXC IDs specified. "
   198 |                               "Set MRCHEM_LIBXC_IDS (e.g. '1,9' for LDA X+PW92 C), "
   199 |                               "or call Factory::setLibXCIDs().");
   200 |                 }
   201 |                 func_p = std::make_unique<LibXCSpinLDA>(order, xcfun_p, ids);
   202 |             } else
   203 | #endif
   204 |             {
   205 |                 func_p = std::make_unique<SpinLDA>(order, xcfun_p);
   206 |             }
   207 |         }
   208 |     } else {
   209 |         if (gga) {
   210 | #ifdef MRCHEM_ENABLE_LIBXC
   211 |             if (use_libxc) {
   212 |                 if (ids.empty()) {
   213 |                     MSG_ABORT("LibXC backend selected but no LibXC IDs specified. "
   214 |                               "Set MRCHEM_LIBXC_IDS (e.g. 402 for B3LYP, or '106,131' for BLYP), "
   215 |                               "or call Factory::setLibXCIDs().");
   216 |                 }
   217 |                 func_p = std::make_unique<LibXCGGA>(order, xcfun_p, diff_p, ids);
   218 |             } else
   219 | #endif
   220 |             {
   221 |                 func_p = std::make_unique<GGA>(order, xcfun_p, diff_p);
   222 |             }
   223 |         } else if (lda) {
   224 | #ifdef MRCHEM_ENABLE_LIBXC
   225 |             if (use_libxc) {
   226 |                 if (ids.empty()) {
   227 |                     MSG_ABORT("LibXC backend selected but no LibXC IDs specified. "
   228 |                               "Set MRCHEM_LIBXC_IDS (e.g. '1,9' for LDA X+PW92 C), "
   229 |                               "or call Factory::setLibXCIDs().");
   230 |                 }
   231 |                 func_p = std::make_unique<LibXCLDA>(order, xcfun_p, ids);
   232 |             } else
   233 | #endif
   234 |             {
   235 |                 func_p = std::make_unique<LDA>(order, xcfun_p);
   236 |             }
   237 |         }
   238 |     }
   239 | 
   240 |     if (!func_p) {
   241 |         MSG_ABORT("Invalid or unsupported functional type (spin/LDA/GGA combination).");
   242 |     }
   243 | 
   244 |     // ---------------------------------------------------------------------
   245 |     // Keep original behavior: set derivative operator & knobs on the functional
   246 |     // ---------------------------------------------------------------------
   247 |     // (Upstream MRChem sets ABGV(0,0) as a default fallback.)
   248 |     diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.0, 0.0);
   249 |     func_p->setDerivOp(diff_p);
   250 |     func_p->setLogGradient(log_grad);
   251 |     func_p->setDensityCutoff(cutoff);
   252 | 
   253 |     auto mrdft_p = std::make_unique<MRDFT>(grid_p, func_p);
   254 |     return mrdft_p;
   255 | }
   256 | 
   257 | } // namespace mrdft
   258 | 
   259 | ===== END src/mrdft/Factory.cpp =====
   260 | 
   261 | ===== BEGIN src/mrdft/LibXCBackend.h =====
   262 | #pragma once
   263 | 
   264 | #include <vector>
   265 | #include <memory>
   266 | #include <stdexcept>
   267 | #include <Eigen/Core>
   268 | 
   269 | #include <xc.h>  // LibXC C header
   270 | 
   271 | #include "LDA.h"
   272 | #include "GGA.h"
   273 | #include "SpinLDA.h"
   274 | #include "SpinGGA.h"
   275 | 
   276 | namespace mrdft {
   277 | 
   278 | /* Minimal RAII wrapper for LibXC function handles */
   279 | class LibXCHandle {
   280 | public:
   281 |     LibXCHandle(const std::vector<int>& ids, int nspin)
   282 |         : funcs(ids.size()), nspin(nspin) {
   283 |         for (size_t k = 0; k < ids.size(); ++k) {
   284 |             if (xc_func_init(&funcs[k], ids[k], nspin) != 0) {
   285 |                 throw std::runtime_error("LibXC: could not initialize functional id=" + std::to_string(ids[k]));
   286 |             }
   287 |         }
   288 |     }
   289 |     ~LibXCHandle() {
   290 |         for (auto &f : funcs) xc_func_end(&f);
   291 |     }
   292 |     std::vector<xc_func_type> funcs;
   293 |     int nspin{XC_UNPOLARIZED};
   294 | };
   295 | 
   296 | /* -------- Unpolarized LDA -------- */
   297 | class LibXCLDA : public LDA {
   298 | public:
   299 |     LibXCLDA(int k, XC_p &f, const std::vector<int>& ids)
   300 |         : LDA(k, f), handle(ids, XC_UNPOLARIZED) {}
   301 | 
   302 |     Eigen::MatrixXd evaluate_transposed(Eigen::MatrixXd &inp) const override;
   303 | 
   304 | private:
   305 |     LibXCHandle handle;
   306 | };
   307 | 
   308 | /* -------- Unpolarized GGA -------- */
   309 | class LibXCGGA : public GGA {
   310 | public:
   311 |     LibXCGGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d, const std::vector<int>& ids)
   312 |         : GGA(k, f, d), handle(ids, XC_UNPOLARIZED) {}
   313 | 
   314 |     Eigen::MatrixXd evaluate_transposed(Eigen::MatrixXd &inp) const override;
   315 | 
   316 | private:
   317 |     LibXCHandle handle;
   318 | };
   319 | 
   320 | /* -------- Spin LDA -------- */
   321 | class LibXCSpinLDA : public SpinLDA {
   322 | public:
   323 |     LibXCSpinLDA(int k, XC_p &f, const std::vector<int>& ids)
   324 |         : SpinLDA(k, f), handle(ids, XC_POLARIZED) {}
   325 | 
   326 |     Eigen::MatrixXd evaluate_transposed(Eigen::MatrixXd &inp) const override;
   327 | 
   328 | private:
   329 |     LibXCHandle handle;
   330 | };
   331 | 
   332 | /* -------- Spin GGA -------- */
   333 | class LibXCSpinGGA : public SpinGGA {
   334 | public:
   335 |     LibXCSpinGGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d, const std::vector<int>& ids)
   336 |         : SpinGGA(k, f, d), handle(ids, XC_POLARIZED) {}
   337 | 
   338 |     Eigen::MatrixXd evaluate_transposed(Eigen::MatrixXd &inp) const override;
   339 | 
   340 | private:
   341 |     LibXCHandle handle;
   342 | };
   343 | 
   344 | } // namespace mrdft
   345 | 
   346 | ===== END src/mrdft/LibXCBackend.h =====
   347 | 
   348 | ===== BEGIN src/mrdft/LibXCBackend.cpp =====
   349 | #include "LibXCBackend.h"
   350 | 
   351 | namespace mrdft {
   352 | 
   353 | /* For now, these stubs simply delegate to XCFun.
   354 |    Next step we’ll fill them with real LibXC calls (xc_lda_exc_vxc, xc_gga_exc_vxc, etc.). */
   355 | 
   356 | Eigen::MatrixXd LibXCLDA::evaluate_transposed(Eigen::MatrixXd &inp) const {
   357 |     return Functional::evaluate_transposed(inp);
   358 | }
   359 | 
   360 | Eigen::MatrixXd LibXCSpinLDA::evaluate_transposed(Eigen::MatrixXd &inp) const {
   361 |     return Functional::evaluate_transposed(inp);
   362 | }
   363 | 
   364 | Eigen::MatrixXd LibXCGGA::evaluate_transposed(Eigen::MatrixXd &inp) const {
   365 |     return Functional::evaluate_transposed(inp);
   366 | }
   367 | 
   368 | Eigen::MatrixXd LibXCSpinGGA::evaluate_transposed(Eigen::MatrixXd &inp) const {
   369 |     return Functional::evaluate_transposed(inp);
   370 | }
   371 | 
   372 | } // namespace mrdft
   373 | 
   374 | ===== END src/mrdft/LibXCBackend.cpp =====
   375 | 
   376 | ===== BEGIN src/mrdft/xc_backend.h =====
   377 | #pragma once
   378 | 
   379 | #include <Eigen/Core>
   380 | #include <memory>
   381 | #include <string>
   382 | 
   383 | namespace mrdft {
   384 | 
   385 | class XCBackend {
   386 | public:
   387 |     virtual ~XCBackend() = default;
   388 | 
   389 |     // Configure functional & coefficient (same semantics as xcfun_set)
   390 |     virtual void set_functional(const std::string &name, double coeff) = 0;
   391 | 
   392 |     // Configure evaluation layout (order, spin, gamma vs explicit)
   393 |     virtual void configure(int order, bool spin, bool use_gamma) = 0;
   394 | 
   395 |     // Introspection
   396 |     virtual bool  is_gga() const = 0;
   397 |     virtual bool  is_metagga() const = 0;
   398 |     virtual double amount_exx() const = 0;
   399 |     virtual int   input_length() const = 0;
   400 |     virtual int   output_length() const = 0;
   401 | 
   402 |     // Evaluate at many grid points. Each ROW is one grid point.
   403 |     // Returns (nPts x nOut). Applies cutoff identical to old code.
   404 |     virtual Eigen::MatrixXd eval_transposed(const Eigen::MatrixXd &inp,
   405 |                                             double cutoff,
   406 |                                             bool is_spin_sep) const = 0;
   407 | };
   408 | 
   409 | using XCBackend_p = std::shared_ptr<XCBackend>;
   410 | 
   411 | // Stage 1 backend: wraps XCFun
   412 | XCBackend_p make_xcfun_backend();
   413 | 
   414 | } // namespace mrdft
   415 | 
   416 | ===== END src/mrdft/xc_backend.h =====
   417 | 
   418 | ===== BEGIN src/mrdft/xc_backend_xcfun.cpp =====
   419 | #include "xc_backend.h"
   420 | 
   421 | #include <XCFun/xcfun.h>
   422 | #include <memory>
   423 | #include <stdexcept>
   424 | #include <utility>
   425 | 
   426 | namespace mrdft {
   427 | 
   428 | namespace {
   429 | struct XCFunDeleter {
   430 |     void operator()(xcfun_t *p) const { if (p) xcfun_delete(p); }
   431 | };
   432 | } // namespace
   433 | 
   434 | class XCFunBackend final : public XCBackend {
   435 | public:
   436 |     XCFunBackend()
   437 |         : xcfun_(xcfun_new(), XCFunDeleter{}) {}
   438 | 
   439 |     void set_functional(const std::string &name, double coeff) override {
   440 |         xcfun_set(xcfun_.get(), name.c_str(), coeff);
   441 |     }
   442 | 
   443 |     void configure(int order, bool spin, bool use_gamma) override {
   444 |         order_ = order;
   445 |         spin_  = spin;
   446 | 
   447 |         const bool gga = xcfun_is_gga(xcfun_.get());
   448 |         unsigned int mode         = 1;                 // partial derivatives
   449 |         unsigned int func_type    = gga ? 1u : 0u;     // 0=LDA, 1=GGA
   450 |         unsigned int dens_type    = static_cast<unsigned>(1 + (spin ? 1 : 0)); // 1 or 2
   451 |         unsigned int laplacian    = 0;
   452 |         unsigned int kinetic      = 0;
   453 |         unsigned int current      = 0;
   454 |         unsigned int exp_deriv    = static_cast<unsigned>(!use_gamma);
   455 |         if (!gga) exp_deriv = 0; // fall back to gamma-type for LDA
   456 | 
   457 |         xcfun_user_eval_setup(xcfun_.get(), order_, func_type, dens_type,
   458 |                               mode, laplacian, kinetic, current, exp_deriv);
   459 |     }
   460 | 
   461 |     bool is_gga() const override     { return xcfun_is_gga(xcfun_.get()); }
   462 |     bool is_metagga() const override { return xcfun_is_metagga(xcfun_.get()); }
   463 | 
   464 |     double amount_exx() const override {
   465 |         double exx = 0.0;
   466 |         xcfun_get(xcfun_.get(), "exx", &exx);
   467 |         return exx;
   468 |     }
   469 | 
   470 |     int input_length()  const override { return xcfun_input_length(xcfun_.get()); }
   471 |     int output_length() const override { return xcfun_output_length(xcfun_.get()); }
   472 | 
   473 |     Eigen::MatrixXd eval_transposed(const Eigen::MatrixXd &inp,
   474 |                                     double cutoff,
   475 |                                     bool is_spin_sep) const override {
   476 |         const int nInp = input_length();
   477 |         const int nOut = output_length();
   478 |         const int nPts = static_cast<int>(inp.rows());
   479 |         if (inp.cols() != nInp) throw std::runtime_error("XCFunBackend: invalid input shape");
   480 | 
   481 |         Eigen::MatrixXd out(nPts, nOut);
   482 |         out.setZero();
   483 | 
   484 |         Eigen::VectorXd in_row(nInp);
   485 |         Eigen::VectorXd out_row(nOut);
   486 |         for (int i = 0; i < nPts; ++i) {
   487 |             bool calc = true;
   488 |             if (is_spin_sep) {
   489 |                 if (inp(i, 0) < cutoff && inp(i, 1) < cutoff) calc = false;
   490 |             } else {
   491 |                 if (inp(i, 0) < cutoff) calc = false;
   492 |             }
   493 |             for (int j = 0; j < nInp; ++j) in_row(j) = inp(i, j);
   494 |             if (calc) xcfun_eval(xcfun_.get(), in_row.data(), out_row.data());
   495 |             for (int j = 0; j < nOut; ++j) out(i, j) = out_row(j);
   496 |         }
   497 |         return out;
   498 |     }
   499 | 
   500 | private:
   501 |     std::unique_ptr<xcfun_t, XCFunDeleter> xcfun_;
   502 |     int  order_ = 1;
   503 |     bool spin_  = false;
   504 | };
   505 | 
   506 | XCBackend_p make_xcfun_backend() {
   507 |     return std::make_shared<XCFunBackend>();
   508 | }
   509 | 
   510 | } // namespace mrdft
   511 | 
   512 | ===== END src/mrdft/xc_backend_xcfun.cpp =====
   513 | 
   514 | ===== BEGIN src/mrenv.h =====
   515 | /*
   516 |  * MRChem, a numerical real-space code for molecular electronic structure
   517 |  * calculations within the self-consistent field (SCF) approximations of quantum
   518 |  * chemistry (Hartree-Fock and Density Functional Theory).
   519 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
   520 |  *
   521 |  * This file is part of MRChem.
   522 |  *
   523 |  * MRChem is free software: you can redistribute it and/or modify
   524 |  * it under the terms of the GNU Lesser General Public License as published by
   525 |  * the Free Software Foundation, either version 3 of the License, or
   526 |  * (at your option) any later version.
   527 |  *
   528 |  * MRChem is distributed in the hope that it will be useful,
   529 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
   530 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   531 |  * GNU Lesser General Public License for more details.
   532 |  *
   533 |  * You should have received a copy of the GNU Lesser General Public License
   534 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
   535 |  *
   536 |  * For information on the complete list of contributors to MRChem, see:
   537 |  * <https://mrchem.readthedocs.io/>
   538 |  */
   539 | 
   540 | #pragma once
   541 | 
   542 | #include <string>
   543 | 
   544 | #include <nlohmann/json.hpp>
   545 | 
   546 | namespace mrchem {
   547 | namespace mrenv {
   548 | 
   549 | nlohmann::json fetch_json(int argc, char **argv);
   550 | void dump_json(const nlohmann::json &json_inp, const nlohmann::json &json_out);
   551 | 
   552 | void initialize(const nlohmann::json &json_inp);
   553 | void finalize(double wt);
   554 | 
   555 | } // namespace mrenv
   556 | namespace detail {
   557 | std::string remove_extension(const std::string &fname);
   558 | bool all_success(const nlohmann::json &json_out);
   559 | } // namespace detail
   560 | } // namespace mrchem
   561 | 
   562 | ===== END src/mrenv.h =====
   563 | 
   564 | ===== BEGIN src/mrenv.cpp =====
   565 | /*
   566 |  * MRChem, a numerical real-space code for molecular electronic structure
   567 |  * calculations within the self-consistent field (SCF) approximations of quantum
   568 |  * chemistry (Hartree-Fock and Density Functional Theory).
   569 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
   570 |  *
   571 |  * This file is part of MRChem.
   572 |  *
   573 |  * MRChem is free software: you can redistribute it and/or modify
   574 |  * it under the terms of the GNU Lesser General Public License as published by
   575 |  * the Free Software Foundation, either version 3 of the License, or
   576 |  * (at your option) any later version.
   577 |  *
   578 |  * MRChem is distributed in the hope that it will be useful,
   579 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
   580 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   581 |  * GNU Lesser General Public License for more details.
   582 |  *
   583 |  * You should have received a copy of the GNU Lesser General Public License
   584 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
   585 |  *
   586 |  * For information on the complete list of contributors to MRChem, see:
   587 |  * <https://mrchem.readthedocs.io/>
   588 |  */
   589 | 
   590 | #include <MRCPP/Printer>
   591 | #include <XCFun/xcfun.h>
   592 | #include <fstream>
   593 | #include "MRCPP/utils/parallel.h"
   594 | 
   595 | #include "mrchem.h"
   596 | #include "mrenv.h"
   597 | #include "utils/print_utils.h"
   598 | #include "version.h"
   599 | 
   600 | using json = nlohmann::json;
   601 | using Printer = mrcpp::Printer;
   602 | 
   603 | namespace mrchem {
   604 | 
   605 | namespace mrenv {
   606 | void init_printer(const json &json_print);
   607 | void init_mra(const json &json_mra);
   608 | void init_mpi(const json &json_mpi);
   609 | void print_header();
   610 | } // namespace mrenv
   611 | 
   612 | json mrenv::fetch_json(int argc, char **argv) {
   613 |     const char *infile = nullptr;
   614 |     if (argc == 1) {
   615 |         infile = "STDIN";
   616 |     } else if (argc == 2) {
   617 |         infile = argv[1];
   618 |     } else {
   619 |         MSG_ERROR("Ivalid number of arguments!");
   620 |     }
   621 | 
   622 |     // Read JSON input
   623 |     json input;
   624 |     std::ifstream ifs(infile, std::ios_base::in);
   625 |     ifs >> input;
   626 |     ifs.close();
   627 | 
   628 |     return input["input"];
   629 | }
   630 | 
   631 | void mrenv::initialize(const json &json_inp) {
   632 |     auto json_print = json_inp.find("printer");
   633 |     auto json_mra = json_inp.find("mra");
   634 |     auto json_mpi = json_inp.find("mpi");
   635 | 
   636 |     if (json_mra == json_inp.end()) {
   637 |         MSG_ABORT("Missing MRA input!");
   638 |     } else {
   639 |         mrenv::init_mra(*json_mra);
   640 |     }
   641 |     if (json_mpi != json_inp.end()) mrenv::init_mpi(*json_mpi);
   642 |     if (json_print != json_inp.end()) mrenv::init_printer(*json_print);
   643 | 
   644 |     mrenv::print_header();
   645 | }
   646 | 
   647 | void mrenv::init_printer(const json &json_print) {
   648 |     // Initialize printing
   649 |     auto print_level = json_print["print_level"];
   650 |     auto print_prec = json_print["print_prec"];
   651 |     auto print_width = json_print["print_width"];
   652 |     auto print_mpi = json_print["print_mpi"];
   653 |     auto fname = json_print["file_name"].get<std::string>();
   654 |     if (print_mpi) {
   655 |         Printer::init(print_level, mrcpp::mpi::world_rank, mrcpp::mpi::world_size, fname.c_str());
   656 |     } else {
   657 |         Printer::init(print_level, mrcpp::mpi::world_rank, mrcpp::mpi::world_size);
   658 |     }
   659 |     Printer::setPrecision(print_prec);
   660 |     Printer::setWidth(print_width);
   661 | }
   662 | 
   663 | void mrenv::init_mra(const json &json_mra) {
   664 |     // Initialize world box
   665 |     int min_scale = json_mra["min_scale"];
   666 |     int max_scale = json_mra["max_scale"];
   667 |     auto corner = json_mra["corner"];
   668 |     auto boxes = json_mra["boxes"];
   669 |     mrcpp::BoundingBox<3> world(min_scale, corner, boxes);
   670 | 
   671 |     // Initialize scaling basis
   672 |     auto order = json_mra["basis_order"];
   673 |     auto btype = json_mra["basis_type"];
   674 | 
   675 |     auto max_depth = max_scale - min_scale;
   676 |     if (min_scale < mrcpp::MinScale) MSG_ABORT("Root scale too large");
   677 |     if (max_scale > mrcpp::MaxScale) MSG_ABORT("Max scale too large");
   678 |     if (max_depth > mrcpp::MaxDepth) MSG_ABORT("Max depth too large");
   679 | 
   680 |     // Initialize global MRA
   681 |     if (btype == "interpolating") {
   682 |         mrcpp::InterpolatingBasis basis(order);
   683 |         MRA = new mrcpp::MultiResolutionAnalysis<3>(world, basis, max_depth);
   684 |     } else if (btype == "legendre") {
   685 |         mrcpp::LegendreBasis basis(order);
   686 |         MRA = new mrcpp::MultiResolutionAnalysis<3>(world, basis, max_depth);
   687 |     } else {
   688 |         MSG_ABORT("Invalid basis type!");
   689 |     }
   690 |     mrcpp::cplxfunc::SetdefaultMRA(MRA);
   691 | }
   692 | 
   693 | void mrenv::init_mpi(const json &json_mpi) {
   694 |     mrcpp::mpi::numerically_exact = json_mpi["numerically_exact"];
   695 |     mrcpp::mpi::shared_memory_size = json_mpi["shared_memory_size"];
   696 |     mrcpp::mpi::bank_size = json_mpi["bank_size"];
   697 |     mrcpp::mpi::omp_threads = json_mpi["omp_threads"];
   698 |     mrcpp::mpi::initialize(); // NB: must be after bank_size and init_mra but before init_printer and print_header
   699 | }
   700 | 
   701 | void mrenv::print_header() {
   702 |     auto pwidth = Printer::getWidth();
   703 |     auto txt_width = 50;
   704 |     auto pre_spaces = (pwidth - 6 - txt_width) / 2;
   705 |     auto post_spaces = pwidth - 6 - txt_width - pre_spaces;
   706 |     std::string pre_str = std::string(3, '*') + std::string(pre_spaces, ' ');
   707 |     std::string post_str = std::string(post_spaces, ' ') + std::string(3, '*');
   708 |     std::stringstream o_ver, o_branch, o_hash, o_author, o_date;
   709 |     o_ver << "VERSION            " << program_version();
   710 |     o_branch << "Git branch         " << git_branch();
   711 |     o_hash << "Git commit hash    " << git_commit_hash();
   712 |     o_author << "Git commit author  " << git_commit_author();
   713 |     o_date << "Git commit date    " << git_commit_date();
   714 | 
   715 |     int ver_len = o_ver.str().size();
   716 |     int branch_len = o_branch.str().size();
   717 |     int hash_len = o_hash.str().size();
   718 |     int auth_len = o_author.str().size();
   719 |     int date_len = o_date.str().size();
   720 | 
   721 |     o_ver << std::string(std::max(0, txt_width - ver_len), ' ');
   722 |     o_branch << std::string(std::max(0, txt_width - branch_len), ' ');
   723 |     o_hash << std::string(std::max(0, txt_width - hash_len), ' ');
   724 |     o_author << std::string(std::max(0, txt_width - auth_len), ' ');
   725 |     o_date << std::string(std::max(0, txt_width - date_len), ' ');
   726 | 
   727 |     std::stringstream o_bank;
   728 |     if (mrcpp::mpi::bank_size > 0) {
   729 |         o_bank << "(" << mrcpp::mpi::tot_bank_size << " bank)";
   730 |     } else {
   731 |         o_bank << "(no bank)";
   732 |     }
   733 | 
   734 |     mrcpp::print::separator(0, ' ');
   735 |     mrcpp::print::separator(0, ' ');
   736 |     mrcpp::print::separator(0, '*');
   737 |     println(0, pre_str << "                                                  " << post_str);
   738 |     println(0, pre_str << "                                                  " << post_str);
   739 |     println(0, pre_str << " __  __ ____   ____ _                             " << post_str);
   740 |     println(0, pre_str << "|  \\/  |  _ \\ / ___| |__   ___ _ __ ___           " << post_str);
   741 |     println(0, pre_str << "| |\\/| | |_) | |   | '_ \\ / _ \\ '_ ` _ \\          " << post_str);
   742 |     println(0, pre_str << "| |  | |  _ <| |___| | | |  __/ | | | | |         " << post_str);
   743 |     println(0, pre_str << "|_|  |_|_| \\_\\\\____|_| |_|\\___|_| |_| |_|         " << post_str);
   744 |     println(0, pre_str << "                                                  " << post_str);
   745 |     println(0, pre_str << o_ver.str() << post_str);
   746 |     println(0, pre_str << "                                                  " << post_str);
   747 |     println(0, pre_str << o_branch.str() << post_str);
   748 |     println(0, pre_str << o_hash.str() << post_str);
   749 |     println(0, pre_str << o_author.str() << post_str);
   750 |     println(0, pre_str << o_date.str() << post_str);
   751 |     println(0, pre_str << "                                                  " << post_str);
   752 |     println(0, pre_str << "Contact: luca.frediani@uit.no                     " << post_str);
   753 |     println(0, pre_str << "                                                  " << post_str);
   754 |     println(0, pre_str << "Radovan Bast            Magnar Bjorgve            " << post_str);
   755 |     println(0, pre_str << "Roberto Di Remigio      Antoine Durdek            " << post_str);
   756 |     println(0, pre_str << "Luca Frediani           Gabriel Gerez             " << post_str);
   757 |     println(0, pre_str << "Stig Rune Jensen        Jonas Juselius            " << post_str);
   758 |     println(0, pre_str << "Rune Monstad            Peter Wind                " << post_str);
   759 |     println(0, pre_str << "                                                  " << post_str);
   760 |     mrcpp::print::separator(0, '*', 1);
   761 |     mrcpp::print::separator(0, '-', 1);
   762 |     print_utils::scalar(0, "MPI processes  ", mrcpp::mpi::world_size, o_bank.str(), 0, false);
   763 |     print_utils::scalar(0, "OpenMP threads ", mrcpp::omp::n_threads, "", 0, false);
   764 |     print_utils::scalar(0, "Total cores    ", (mrcpp::mpi::world_size - mrcpp::mpi::tot_bank_size) * mrcpp::omp::n_threads + mrcpp::mpi::tot_bank_size, "", 0, false);
   765 |     mrcpp::print::separator(0, ' ');
   766 |     mrcpp::print::separator(0, '-', 1);
   767 |     printout(0, xcfun_splash());
   768 |     mrcpp::print::environment(0);
   769 |     MRA->print();
   770 | }
   771 | 
   772 | void mrenv::finalize(double wt) {
   773 |     // Delete global MRA
   774 |     if (MRA != nullptr) delete MRA;
   775 |     MRA = nullptr;
   776 | 
   777 |     auto pwidth = Printer::getWidth();
   778 |     auto txt_width = 45;
   779 |     auto pre_spaces = (pwidth - 6 - txt_width) / 2;
   780 |     auto post_spaces = pwidth - 6 - txt_width - pre_spaces;
   781 |     std::string pre_str = std::string(3, '*') + std::string(pre_spaces, ' ');
   782 |     std::string post_str = std::string(post_spaces, ' ') + std::string(3, '*');
   783 | 
   784 |     auto hr = static_cast<int>(wt / 3600.0);
   785 |     auto min = static_cast<int>(std::fmod(wt, 3600.0) / 60.0);
   786 |     auto sec = static_cast<int>(std::fmod(wt, 60.0));
   787 | 
   788 |     std::stringstream o_time;
   789 |     o_time << "Wall time : " << std::setw(2) << hr << "h" << std::setw(3) << min << "m" << std::setw(3) << sec << "s";
   790 | 
   791 |     mrcpp::print::separator(0, ' ');
   792 |     mrcpp::print::separator(0, ' ');
   793 |     mrcpp::print::separator(0, '*');
   794 |     println(0, pre_str << "                                             " << post_str);
   795 |     println(0, pre_str << "                Exiting MRChem               " << post_str);
   796 |     println(0, pre_str << "                                             " << post_str);
   797 |     println(0, pre_str << "           " << o_time.str() << "           " << post_str);
   798 |     println(0, pre_str << "                                             " << post_str);
   799 |     mrcpp::print::separator(0, '*');
   800 |     mrcpp::print::separator(0, ' ');
   801 |     mrcpp::print::separator(0, ' ');
   802 | }
   803 | 
   804 | void mrenv::dump_json(const json &json_inp, const json &json_out) {
   805 |     json json_tot;
   806 |     json_tot["input"] = json_inp;
   807 |     json_tot["output"] = json_out;
   808 | 
   809 |     const auto file_name = detail::remove_extension(json_inp["printer"]["file_name"].get<std::string>());
   810 |     if (mrcpp::mpi::grand_master()) {
   811 |         std::ofstream ofs;
   812 |         ofs.open(file_name + ".json", std::ios::out);
   813 |         ofs << json_tot.dump(2) << std::endl;
   814 |         ofs.close();
   815 |     }
   816 | }
   817 | 
   818 | std::string detail::remove_extension(const std::string &fname) {
   819 |     size_t lastdot = fname.find_last_of(".");
   820 |     if (lastdot == std::string::npos) return fname;
   821 |     return fname.substr(0, lastdot);
   822 | }
   823 | 
   824 | bool detail::all_success(const json &json_out) {
   825 |     auto scf_success = json_out["scf_calculation"]["success"].get<bool>();
   826 |     auto rsp_success = true;
   827 |     for (const auto &x : json_out["rsp_calculations"]) { rsp_success &= x["success"].get<bool>(); }
   828 |     return scf_success & rsp_success;
   829 | }
   830 | } // namespace mrchem
   831 | 
   832 | ===== END src/mrenv.cpp =====
   833 | 
   834 | ===== BEGIN src/utils/json_utils.h =====
   835 | #pragma once
   836 | #include <nlohmann/json.hpp>
   837 | #include <string>
   838 | #include <algorithm>
   839 | #include <type_traits>
   840 | #include <cctype>
   841 | #include <unordered_set>
   842 | 
   843 | namespace mrchem::json_utils {
   844 | 
   845 | using json = nlohmann::json;
   846 | 
   847 | // Strict-but-tolerant conversion to bool.
   848 | // Accepts true/false, 0/1, and strings like "on/off", "yes/no".
   849 | inline bool to_bool(const nlohmann::json& j, bool def = false) {
   850 |     if (j.is_boolean()) return j.get<bool>();
   851 |     if (j.is_number_integer()) return j.get<int>() != 0;
   852 |     if (j.is_number_float())   return j.get<double>() != 0.0;
   853 |     if (j.is_string()) {
   854 |         std::string s = j.get<std::string>();
   855 |         std::transform(s.begin(), s.end(), s.begin(),
   856 |                        [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
   857 |         if (s == "true"  || s == "1" || s == "yes" || s == "on")  return true;
   858 |         if (s == "false" || s == "0" || s == "no"  || s == "off") return false;
   859 |         return def;
   860 |     }
   861 |     return def;
   862 | }
   863 | 
   864 | // Safely fetch a value of type T. For bool, uses to_bool.
   865 | // For numbers/strings, only returns if JSON type matches; else returns default.
   866 | template <class T>
   867 | inline T value_loose(const nlohmann::json& jparent, const char* key, const T& def) {
   868 |     if (!jparent.contains(key)) return def;
   869 |     const auto& j = jparent.at(key);
   870 |     if constexpr (std::is_same_v<T,bool>) {
   871 |         return to_bool(j, def);
   872 |     } else if constexpr (std::is_integral_v<T>) {
   873 |         if (j.is_number_integer()) return j.get<T>();
   874 |     } else if constexpr (std::is_floating_point_v<T>) {
   875 |         if (j.is_number()) return j.get<T>();
   876 |     } else if constexpr (std::is_same_v<T,std::string>) {
   877 |         if (j.is_string()) return j.get<std::string>();
   878 |     } else {
   879 |         try { return j.get<T>(); } catch (...) { /* fallthrough */ }
   880 |     }
   881 |     return def;
   882 | }
   883 | 
   884 | // ---------- New: input sanitizer to normalize booleans in the whole tree ----------
   885 | 
   886 | inline bool looks_like_bool_key(const std::string& k) {
   887 |     // common flags across the codebase
   888 |     static const std::unordered_set<std::string> whitelist = {
   889 |         "print_mpi","numerically_exact","restricted","localize","rotate","checkpoint",
   890 |         "dynamic","shared_memory","include_nuclear","include_coulomb","include_xc",
   891 |         "isAZORA","spin","nonequilibrium","density","unrestricted","debug","verbose",
   892 |         "timings","write_orbitals","plots","plot_density","plot_orbitals","enable",
   893 |         "disable","use_gpu","use_mpi","use_omp"
   894 |     };
   895 | 
   896 |     if (whitelist.count(k)) return true;
   897 |     // Heuristics by prefix/suffix
   898 |     auto starts_with = [&](const char* p){
   899 |         return k.rfind(p, 0) == 0;
   900 |     };
   901 |     auto ends_with = [&](const char* sfx){
   902 |         return k.size() >= std::char_traits<char>::length(sfx)
   903 |             && k.compare(k.size()-std::char_traits<char>::length(sfx),
   904 |                          std::char_traits<char>::length(sfx), sfx) == 0;
   905 |     };
   906 | 
   907 |     return starts_with("is_") || starts_with("has_") || starts_with("use_")
   908 |         || starts_with("enable_") || starts_with("disable_") || starts_with("do_")
   909 |         || starts_with("with_") || starts_with("print_") || starts_with("plot_")
   910 |         || ends_with("_enabled") || ends_with("_disabled");
   911 | }
   912 | 
   913 | // Recursively coerce 0/1 and on/off-like strings to booleans for "boolean-ish" keys.
   914 | inline void sanitize_booleans(nlohmann::json& j) {
   915 |     if (j.is_object()) {
   916 |         for (auto it = j.begin(); it != j.end(); ++it) {
   917 |             const std::string key = it.key();
   918 |             auto& val = it.value();
   919 |             // Recurse first
   920 |             if (val.is_object() || val.is_array()) sanitize_booleans(val);
   921 | 
   922 |             if (looks_like_bool_key(key)) {
   923 |                 if (!val.is_boolean()) {
   924 |                     // Only coerce if convertible; otherwise leave as-is
   925 |                     bool coerced = to_bool(val, /*def*/false);
   926 |                     // If val was non-convertible string (e.g., "maybe"), keep old value
   927 |                     if (val.is_boolean() || val.is_number() || val.is_string()) {
   928 |                         // Special case: avoid mis-coercing numbers not 0/1
   929 |                         if (val.is_number_integer()) {
   930 |                             int n = val.get<int>();
   931 |                             if (n == 0 || n == 1) { val = coerced; }
   932 |                         } else if (val.is_number_float()) {
   933 |                             double x = val.get<double>();
   934 |                             if (x == 0.0 || x == 1.0) { val = coerced; }
   935 |                         } else if (val.is_string()) {
   936 |                             // Strings like "on"/"off"/"yes"/"no"/"true"/"false"/"0"/"1"
   937 |                             std::string s = val.get<std::string>();
   938 |                             std::string sl = s;
   939 |                             std::transform(sl.begin(), sl.end(), sl.begin(),
   940 |                                            [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
   941 |                             if (sl=="true"||sl=="false"||sl=="on"||sl=="off"||sl=="yes"||sl=="no"||sl=="0"||sl=="1") {
   942 |                                 val = coerced;
   943 |                             }
   944 |                         }
   945 |                     }
   946 |                 }
   947 |             }
   948 |         }
   949 |     } else if (j.is_array()) {
   950 |         for (auto& x : j) sanitize_booleans(x);
   951 |     }
   952 | }
   953 | 
   954 | } // namespace mrchem::json_utils
   955 | 
   956 | ===== END src/utils/json_utils.h =====
   957 | 
   958 | ===== MISSING src/utils/json_utils.cpp =====
   959 | 
   960 | ===== BEGIN CMakeLists.txt =====
   961 | # This file is autogenerated by Autocmake v1.0.0 http://autocmake.org
   962 | # Copyright (c) 2015-2020 by Radovan Bast, Roberto Di Remigio, Jonas Juselius, and contributors.
   963 | 
   964 | # set minimum cmake version
   965 | cmake_minimum_required(VERSION 3.14 FATAL_ERROR)
   966 | 
   967 | # project name
   968 | project(MRChem LANGUAGES CXX)
   969 | 
   970 | # do not rebuild if rules (compiler flags) change
   971 | set(CMAKE_SKIP_RULE_DEPENDENCY TRUE)
   972 | 
   973 | # if CMAKE_BUILD_TYPE undefined, we set it to Release
   974 | if(NOT CMAKE_BUILD_TYPE)
   975 |     set(CMAKE_BUILD_TYPE "Release")
   976 | endif()
   977 | 
   978 | # Options handling utilities
   979 | include(CMakeDependentOption)
   980 | # Macro for printing an option in a consistent manner
   981 | # Written by Lori A. Burns (@loriab) and Ryan M. Richard (@ryanmrichard)
   982 | # Syntax: print_option(<option to print> <was specified>)
   983 | macro(print_option variable default)
   984 |   if(NOT DEFINED ${variable} OR "${${variable}}" STREQUAL "")
   985 |     message(STATUS "Setting (unspecified) option ${variable}: ${default}")
   986 |   else()
   987 |     message(STATUS "Setting option ${variable}: ${${variable}}")
   988 |   endif()
   989 | endmacro()
   990 | 
   991 | # Wraps an option with default ON/OFF. Adds nice messaging to option()
   992 | # Written by Lori A. Burns (@loriab) and Ryan M. Richard (@ryanmrichard)
   993 | # Syntax: option_with_print(<option name> <description> <default value>)
   994 | macro(option_with_print variable msge default)
   995 |   print_option(${variable} ${default})
   996 |   option(${variable} ${msge} ${default})
   997 | endmacro()
   998 | 
   999 | # Wraps an option with a default other than ON/OFF and prints it
  1000 | # Written by Lori A. Burns (@loriab) and Ryan M. Richard (@ryanmrichard)
  1001 | # NOTE: Can't combine with above b/c CMake handles ON/OFF options specially
  1002 | # NOTE2: CMake variables are always defined so need to further check for if
  1003 | #       they are the NULL string. This is also why we need the force
  1004 | # Syntax: option_with_default(<option name> <description> <default value>)
  1005 | macro(option_with_default variable msge default)
  1006 |   print_option(${variable} "${default}")
  1007 |   if(NOT DEFINED ${variable} OR "${${variable}}" STREQUAL "")
  1008 |     set(${variable} "${default}" CACHE STRING ${msge} FORCE)
  1009 |   endif()
  1010 | endmacro()
  1011 | 
  1012 | # included cmake modules
  1013 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_cxx.cmake)
  1014 | include(${PROJECT_SOURCE_DIR}/cmake/compiler_flags/CXXFlags.cmake)
  1015 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_default_build_paths.cmake)
  1016 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_safeguards.cmake)
  1017 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_code_coverage.cmake)
  1018 | include(${PROJECT_SOURCE_DIR}/cmake/custom/mpi.cmake)
  1019 | include(${PROJECT_SOURCE_DIR}/cmake/custom/omp.cmake)
  1020 | include(${PROJECT_SOURCE_DIR}/cmake/custom/sad_basis.cmake)
  1021 | include(${PROJECT_SOURCE_DIR}/cmake/custom/hirshfeld.cmake)
  1022 | include(${PROJECT_SOURCE_DIR}/cmake/custom/azora_potentials.cmake)
  1023 | include(${PROJECT_SOURCE_DIR}/cmake/custom/main.cmake)
  1024 | include(${PROJECT_SOURCE_DIR}/cmake/custom/feature_summary.cmake)
  1025 | include(${PROJECT_SOURCE_DIR}/cmake/custom/tests.cmake)
  1026 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_save_flags.cmake)
  1027 | 
  1028 | ===== END CMakeLists.txt =====
  1029 | 
  1030 | ===== BEGIN src/mrdft/CMakeLists.txt =====
  1031 | target_sources(mrchem PRIVATE
  1032 |     ${CMAKE_CURRENT_SOURCE_DIR}/Factory.cpp
  1033 |     ${CMAKE_CURRENT_SOURCE_DIR}/MRDFT.cpp
  1034 |     ${CMAKE_CURRENT_SOURCE_DIR}/Functional.cpp
  1035 |     ${CMAKE_CURRENT_SOURCE_DIR}/LDA.cpp
  1036 |     ${CMAKE_CURRENT_SOURCE_DIR}/SpinLDA.cpp
  1037 |     ${CMAKE_CURRENT_SOURCE_DIR}/GGA.cpp
  1038 |     ${CMAKE_CURRENT_SOURCE_DIR}/SpinGGA.cpp
  1039 |     ${CMAKE_CURRENT_SOURCE_DIR}/xc_utils.cpp
  1040 | )
  1041 | 
  1042 | if(MRCHEM_ENABLE_LIBXC AND HAVE_LIBXC)
  1043 |     target_sources(mrchem PRIVATE
  1044 |         ${CMAKE_CURRENT_SOURCE_DIR}/LibXCBackend.cpp
  1045 |     )
  1046 |     target_compile_definitions(mrchem PRIVATE MRCHEM_ENABLE_LIBXC)
  1047 |     target_link_libraries(mrchem PRIVATE Libxc::xc)
  1048 | endif()
  1049 | 
  1050 | ===== END src/mrdft/CMakeLists.txt =====
  1051 | 
  1052 | ===== BEGIN external/upstream/fetch_libxc.cmake =====
  1053 | # Try to find LibXC. We only enable the backend if we both (a) opt in with
  1054 | # MRCHEM_ENABLE_LIBXC=ON and (b) actually find a working Libxc::xc target.
  1055 | 
  1056 | find_package(Libxc QUIET)
  1057 | 
  1058 | # Some distros provide an imported target Libxc::xc, some only variables.
  1059 | if(TARGET Libxc::xc)
  1060 |   set(HAVE_LIBXC TRUE)
  1061 |   get_property(_loc TARGET Libxc::xc PROPERTY LOCATION)
  1062 |   message(STATUS "Found LibXC: ${_loc}")
  1063 | elseif(LIBXC_FOUND)
  1064 |   # Compat path: construct an IMPORTED target from legacy variables.
  1065 |   add_library(Libxc::xc UNKNOWN IMPORTED)
  1066 |   set_target_properties(Libxc::xc PROPERTIES
  1067 |     IMPORTED_LOCATION "${LIBXC_LIBRARIES}"
  1068 |     INTERFACE_INCLUDE_DIRECTORIES "${LIBXC_INCLUDE_DIRS}"
  1069 |   )
  1070 |   set(HAVE_LIBXC TRUE)
  1071 |   message(STATUS "Found LibXC (legacy variables).")
  1072 | else()
  1073 |   set(HAVE_LIBXC FALSE)
  1074 |   message(STATUS "LibXC not found – LibXC backend will be disabled unless you install it.")
  1075 | endif()
  1076 | 
  1077 | ===== END external/upstream/fetch_libxc.cmake =====
  1078 | 
  1079 | ===== BEGIN cmake/custom/main.cmake =====
  1080 | file(MAKE_DIRECTORY ${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_INCLUDEDIR}/${PROJECT_NAME})
  1081 | 
  1082 | file(READ "${PROJECT_SOURCE_DIR}/VERSION" MRCHEM_VERSION)
  1083 | string(STRIP "${MRCHEM_VERSION}" MRCHEM_VERSION)
  1084 | 
  1085 | string(REPLACE "." ";" VERSION_LIST ${MRCHEM_VERSION})
  1086 | list(GET VERSION_LIST 0 MRCHEM_VERSION_MAJOR)
  1087 | list(GET VERSION_LIST 1 MRCHEM_VERSION_MINOR)
  1088 | 
  1089 | configure_file (
  1090 |   ${PROJECT_SOURCE_DIR}/config.h.in
  1091 |   ${PROJECT_BINARY_DIR}/config.h
  1092 |   @ONLY
  1093 |   )
  1094 | 
  1095 | add_custom_command(
  1096 |   OUTPUT
  1097 |     ${PROJECT_BINARY_DIR}/version.h
  1098 |   COMMAND
  1099 |     ${CMAKE_COMMAND} -DINPUT_DIR=${PROJECT_SOURCE_DIR}
  1100 |                      -DTARGET_DIR=${PROJECT_BINARY_DIR}
  1101 |                      -DCMAKE_SYSTEM=${CMAKE_SYSTEM}
  1102 |                      -DCMAKE_SYSTEM_PROCESSOR=${CMAKE_SYSTEM_PROCESSOR}
  1103 |                      -DCMAKE_GENERATOR=${CMAKE_GENERATOR}
  1104 |                      -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
  1105 |                      -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}
  1106 |                      -DCMAKE_CXX_COMPILER_VERSION=${CMAKE_CXX_COMPILER_VERSION}
  1107 |                      -DMRCHEM_VERSION=${MRCHEM_VERSION}
  1108 |                      -DMW_FILTER_SOURCE_DIR=${MW_FILTER_SOURCE_DIR}
  1109 |                      -DMW_FILTER_INSTALL_DIR=${MW_FILTER_INSTALL_DIR}
  1110 |                      -P ${CMAKE_CURRENT_LIST_DIR}/binary-info.cmake
  1111 |   MAIN_DEPENDENCY
  1112 |     ${PROJECT_SOURCE_DIR}/version.h.in
  1113 |   WORKING_DIRECTORY
  1114 |     ${CMAKE_CURRENT_LIST_DIR}
  1115 |   )
  1116 | 
  1117 | # rebuild version_info.h every time
  1118 | add_custom_target(
  1119 |   mrchem-info
  1120 |   ALL
  1121 |   COMMAND
  1122 |     ${CMAKE_COMMAND} -E touch_nocreate ${PROJECT_SOURCE_DIR}/version.h.in
  1123 |   DEPENDS
  1124 |     ${PROJECT_BINARY_DIR}/version.h
  1125 |   )
  1126 | 
  1127 | # See here for the reason why: https://gitlab.kitware.com/cmake/cmake/issues/18399
  1128 | set_source_files_properties(${PROJECT_BINARY_DIR}/version.h
  1129 |   PROPERTIES
  1130 |     GENERATED 1
  1131 |   )
  1132 | 
  1133 | # We save CMAKE_BUILD_TYPE, as we will set it to Release for externals
  1134 | 
  1135 | # === LibXC backend switch (OFF by default, XCFun remains the default backend) ===
  1136 | option(MRCHEM_ENABLE_LIBXC "Enable experimental LibXC backend (in addition to XCFun)" OFF)
  1137 | 
  1138 | 
  1139 | set(_build_type ${CMAKE_BUILD_TYPE})
  1140 | # Order IS important here!
  1141 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_nlohmann_json.cmake)
  1142 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_xcfun.cmake)
  1143 | # Optional LibXC (only used if MRCHEM_ENABLE_LIBXC=ON and LibXC is found)
  1144 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_libxc.cmake)
  1145 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_eigen3.cmake)
  1146 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_mrcpp.cmake)
  1147 | # reset CMAKE_BUILD_TYPE to whatever it was for MRChem
  1148 | set(CMAKE_BUILD_TYPE ${_build_type})
  1149 | 
  1150 | add_subdirectory(src)
  1151 | add_subdirectory(python)
  1152 | add_subdirectory(pilot)
  1153 | 
  1154 | ===== END cmake/custom/main.cmake =====
  1155 | 
  1156 | ===== BEGIN python/mrchem/cli.py =====
  1157 | #
  1158 | # MRChem, a numerical real-space code for molecular electronic structure
  1159 | # calculations within the self-consistent field (SCF) approximations of quantum
  1160 | # chemistry (Hartree-Fock and Density Functional Theory).
  1161 | # Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1162 | #
  1163 | # This file is part of MRChem.
  1164 | #
  1165 | # MRChem is free software: you can redistribute it and/or modify
  1166 | # it under the terms of the GNU Lesser General Public License as published by
  1167 | # the Free Software Foundation, either version 3 of the License, or
  1168 | # (at your option) any later version.
  1169 | #
  1170 | # MRChem is distributed in the hope that it will be useful,
  1171 | # but WITHOUT ANY WARRANTY; without even the implied warranty of
  1172 | # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1173 | # GNU Lesser General Public License for more details.
  1174 | #
  1175 | # You should have received a copy of the GNU Lesser General Public License
  1176 | # along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  1177 | #
  1178 | # For information on the complete list of contributors to MRChem, see:
  1179 | # <https://mrchem.readthedocs.io/>
  1180 | #
  1181 | 
  1182 | import argparse
  1183 | 
  1184 | from .config import MRCHEM_EXECUTABLE, MRCHEM_VERSION, MRCHEM_MODULE
  1185 | 
  1186 | 
  1187 | def cli():
  1188 |     cli = argparse.ArgumentParser(description="Front-end CLI for MRChem")
  1189 |     cli.add_argument("-v", "--version", action="version", version=MRCHEM_VERSION)
  1190 |     cli.add_argument(
  1191 |         "--launcher",
  1192 |         action="store",
  1193 |         dest="launcher",
  1194 |         type=str,
  1195 |         default="",
  1196 |         help="Set program launcher string",
  1197 |     )
  1198 |     cli.add_argument(
  1199 |         "--executable",
  1200 |         "-x",
  1201 |         action="store",
  1202 |         dest="executable",
  1203 |         type=str,
  1204 |         default=MRCHEM_EXECUTABLE,
  1205 |         help="Set executable name",
  1206 |     )
  1207 |     cli.add_argument(
  1208 |         "--dryrun",
  1209 |         "-D",
  1210 |         action="store_true",
  1211 |         dest="dryrun",
  1212 |         default=False,
  1213 |         help="Only process input",
  1214 |     )
  1215 |     cli.add_argument(
  1216 |         "--stdout",
  1217 |         action="store_true",
  1218 |         dest="stdout",
  1219 |         default=False,
  1220 |         help="Print to stdout",
  1221 |     )
  1222 |     cli.add_argument(
  1223 |         "--json",
  1224 |         "-j",
  1225 |         action="store_true",
  1226 |         dest="inp_json",
  1227 |         default=False,
  1228 |         help="Input file is in json format",
  1229 |     )
  1230 |     cli.add_argument("--module", "-m", action="version", version=str(MRCHEM_MODULE))
  1231 |     cli.add_argument("inp_name", type=str, help="Input file in getkw format")
  1232 | 
  1233 |     args = cli.parse_args()
  1234 | 
  1235 |     return args
  1236 | 
  1237 | ===== END python/mrchem/cli.py =====
  1238 | 
  1239 | ===== BEGIN python/mrchem/config.py.in =====
  1240 | #
  1241 | # MRChem, a numerical real-space code for molecular electronic structure
  1242 | # calculations within the self-consistent field (SCF) approximations of quantum
  1243 | # chemistry (Hartree-Fock and Density Functional Theory).
  1244 | # Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1245 | #
  1246 | # This file is part of MRChem.
  1247 | #
  1248 | # MRChem is free software: you can redistribute it and/or modify
  1249 | # it under the terms of the GNU Lesser General Public License as published by
  1250 | # the Free Software Foundation, either version 3 of the License, or
  1251 | # (at your option) any later version.
  1252 | #
  1253 | # MRChem is distributed in the hope that it will be useful,
  1254 | # but WITHOUT ANY WARRANTY; without even the implied warranty of
  1255 | # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1256 | # GNU Lesser General Public License for more details.
  1257 | #
  1258 | # You should have received a copy of the GNU Lesser General Public License
  1259 | # along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  1260 | #
  1261 | # For information on the complete list of contributors to MRChem, see:
  1262 | # <https://mrchem.readthedocs.io/>
  1263 | #
  1264 | 
  1265 | from pathlib import Path
  1266 | 
  1267 | MRCHEM_VERSION = "@MRCHEM_VERSION@"
  1268 | """Version of MRChem"""
  1269 | MRCHEM_EXECUTABLE = "@MRCHEM_EXECUTABLE@"
  1270 | """Full path to the ``mrchem.x`` executable"""
  1271 | MRCHEM_MODULE = Path(__file__).parents[1]
  1272 | """Path to the ``mrchem`` Python frontend module. Do ``sys.path.append(MRCHEM_MODULE)`` to use it"""
  1273 | 
  1274 | ===== END python/mrchem/config.py.in =====
  1275 | 

=== FILE: src/mrdft/CMakeLists.txt | 638.0 B ===
     1 | target_sources(mrchem PRIVATE
     2 |     ${CMAKE_CURRENT_SOURCE_DIR}/Factory.cpp
     3 |     ${CMAKE_CURRENT_SOURCE_DIR}/MRDFT.cpp
     4 |     ${CMAKE_CURRENT_SOURCE_DIR}/Functional.cpp
     5 |     ${CMAKE_CURRENT_SOURCE_DIR}/LDA.cpp
     6 |     ${CMAKE_CURRENT_SOURCE_DIR}/SpinLDA.cpp
     7 |     ${CMAKE_CURRENT_SOURCE_DIR}/GGA.cpp
     8 |     ${CMAKE_CURRENT_SOURCE_DIR}/SpinGGA.cpp
     9 |     ${CMAKE_CURRENT_SOURCE_DIR}/xc_utils.cpp
    10 | )
    11 | 
    12 | if(MRCHEM_ENABLE_LIBXC AND HAVE_LIBXC)
    13 |     target_sources(mrchem PRIVATE
    14 |         ${CMAKE_CURRENT_SOURCE_DIR}/LibXCBackend.cpp
    15 |     )
    16 |     target_compile_definitions(mrchem PRIVATE MRCHEM_ENABLE_LIBXC)
    17 |     target_link_libraries(mrchem PRIVATE Libxc::xc)
    18 | endif()

=== FILE: src/mrdft/Factory.cpp | 7.7 KB ===
     1 | /*
     2 |  * MRChem, a numerical real-space code for molecular electronic structure
     3 |  * calculations within the self-consistent field (SCF) approximations of quantum
     4 |  * chemistry (Hartree-Fock and Density Functional Theory).
     5 |  *
     6 |  * This file is part of MRChem.
     7 |  */
     8 | 
     9 | #include "Factory.h"
    10 | 
    11 | #include <algorithm>
    12 | #include <cctype>
    13 | #include <cstdlib>
    14 | #include <sstream>
    15 | #include <string>
    16 | #include <vector>
    17 | 
    18 | #include <MRCPP/MWOperators>
    19 | #include <MRCPP/Printer>
    20 | #include <XCFun/xcfun.h>
    21 | 
    22 | #include "GGA.h"
    23 | #include "Grid.h"
    24 | #include "LDA.h"
    25 | #include "MRDFT.h"
    26 | #include "SpinGGA.h"
    27 | #include "SpinLDA.h"
    28 | 
    29 | // LibXC adapters (compiled only if enabled at configure time)
    30 | #ifdef MRCHEM_ENABLE_LIBXC
    31 | #  include "LibXCBackend.h"
    32 | #endif
    33 | 
    34 | namespace mrdft {
    35 | 
    36 | // ------------------------------- helpers ---------------------------------
    37 | 
    38 | static std::string to_lower(std::string s) {
    39 |     std::transform(s.begin(), s.end(), s.begin(),
    40 |                    [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
    41 |     return s;
    42 | }
    43 | 
    44 | static std::vector<int> parse_ids_csv(const char* csv_env) {
    45 |     std::vector<int> out;
    46 |     if (!csv_env) return out;
    47 |     std::stringstream ss(csv_env);
    48 |     for (std::string tok; std::getline(ss, tok, ','); ) {
    49 |         if (!tok.empty()) out.push_back(std::stoi(tok));
    50 |     }
    51 |     return out;
    52 | }
    53 | 
    54 | // ------------------------------ Factory ----------------------------------
    55 | 
    56 | Factory::Factory(const mrcpp::MultiResolutionAnalysis<3> &MRA)
    57 |     : mra(MRA)
    58 |     , xcfun_p(xcfun_new(), xcfun_delete) {}
    59 | 
    60 | /** @brief Build a MRDFT object from the currently defined parameters
    61 |  *
    62 |  * Backend selection policy:
    63 |  *  - Default: XCFun
    64 |  *  - If env MRCHEM_XC_BACKEND=libxc (or MRCHEM_FORCE_LIBXC=1), choose LibXC (if compiled)
    65 |  *  - LibXC IDs are taken from Factory::libxc_ids if set; otherwise from env MRCHEM_LIBXC_IDS
    66 |  *  - If LibXC chosen but no IDs available, abort with a clear message
    67 |  */
    68 | std::unique_ptr<MRDFT> Factory::build() {
    69 |     // Init DFT grid
    70 |     auto grid_p = std::make_unique<Grid>(mra);
    71 | 
    72 |     // Decide backend from member + env (env wins)
    73 |     std::string backend_eff = to_lower(backend);
    74 |     if (const char* be = std::getenv("MRCHEM_XC_BACKEND")) {
    75 |         backend_eff = to_lower(std::string(be));
    76 |     }
    77 |     const bool force_libxc = (std::getenv("MRCHEM_FORCE_LIBXC") != nullptr);
    78 |     const bool want_libxc  = force_libxc || (backend_eff == "libxc");
    79 | 
    80 |     // Determine LibXC IDs if needed
    81 |     std::vector<int> ids = libxc_ids; // may be pre-filled by caller
    82 |     if (ids.empty()) {
    83 |         // env override
    84 |         auto env_ids = parse_ids_csv(std::getenv("MRCHEM_LIBXC_IDS"));
    85 |         if (!env_ids.empty()) ids = std::move(env_ids);
    86 |     }
    87 | 
    88 |     // Flag whether LibXC adapters are compiled in
    89 | #ifdef MRCHEM_ENABLE_LIBXC
    90 |     const bool libxc_available = true;
    91 | #else
    92 |     const bool libxc_available = false;
    93 | #endif
    94 |     const bool use_libxc = (want_libxc && libxc_available);
    95 | 
    96 |     // ---------------------------------------------------------------------
    97 |     // XCFun user-eval setup (parity with upstream)
    98 |     // ---------------------------------------------------------------------
    99 |     bool gga = xcfun_is_gga(xcfun_p.get());
   100 |     bool lda = !gga;
   101 | 
   102 |     unsigned int mode          = 1;                    // partial derivative mode
   103 |     unsigned int func_type     = (gga ? 1u : 0u);      // LDA(0) or GGA(1)
   104 |     unsigned int dens_type     = 1 + spin;             // n (1) or alpha&beta (2)
   105 |     unsigned int laplacian     = 0;                    // no laplacian
   106 |     unsigned int kinetic       = 0;                    // no kinetic energy density
   107 |     unsigned int current       = 0;                    // no current density
   108 |     unsigned int exp_deriv     = !gamma;               // use gamma or explicit derivatives
   109 |     if (!gga) exp_deriv = 0;                           // fall back to gamma-type if LDA
   110 | 
   111 |     xcfun_user_eval_setup(xcfun_p.get(), order, func_type, dens_type,
   112 |                           mode, laplacian, kinetic, current, exp_deriv);
   113 | 
   114 |     // ---------------------------------------------------------------------
   115 |     // MW derivative operator if GGA
   116 |     // ---------------------------------------------------------------------
   117 |     if (gga) {
   118 |         if      (diff_s == "bspline") diff_p = std::make_unique<mrcpp::BSOperator<3>>(mra, 1);
   119 |         else if (diff_s == "abgv_00") diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.0, 0.0);
   120 |         else if (diff_s == "abgv_55") diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.5, 0.5);
   121 |         // else leave null; Functional classes can validate as needed
   122 |     }
   123 | 
   124 |     // ---------------------------------------------------------------------
   125 |     // Build Functional (choose LibXC adapters when requested & available)
   126 |     // ---------------------------------------------------------------------
   127 |     std::unique_ptr<Functional> func_p{nullptr};
   128 | 
   129 |     if (spin) {
   130 |         if (gga) {
   131 | #ifdef MRCHEM_ENABLE_LIBXC
   132 |             if (use_libxc) {
   133 |                 if (ids.empty()) {
   134 |                     MSG_ABORT("LibXC backend selected but no LibXC IDs specified. "
   135 |                               "Set MRCHEM_LIBXC_IDS (e.g. 402 for B3LYP, or '106,131' for BLYP), "
   136 |                               "or call Factory::setLibXCIDs().");
   137 |                 }
   138 |                 func_p = std::make_unique<LibXCSpinGGA>(order, xcfun_p, diff_p, ids);
   139 |             } else
   140 | #endif
   141 |             {
   142 |                 func_p = std::make_unique<SpinGGA>(order, xcfun_p, diff_p);
   143 |             }
   144 |         } else if (lda) {
   145 | #ifdef MRCHEM_ENABLE_LIBXC
   146 |             if (use_libxc) {
   147 |                 if (ids.empty()) {
   148 |                     MSG_ABORT("LibXC backend selected but no LibXC IDs specified. "
   149 |                               "Set MRCHEM_LIBXC_IDS (e.g. '1,9' for LDA X+PW92 C), "
   150 |                               "or call Factory::setLibXCIDs().");
   151 |                 }
   152 |                 func_p = std::make_unique<LibXCSpinLDA>(order, xcfun_p, ids);
   153 |             } else
   154 | #endif
   155 |             {
   156 |                 func_p = std::make_unique<SpinLDA>(order, xcfun_p);
   157 |             }
   158 |         }
   159 |     } else {
   160 |         if (gga) {
   161 | #ifdef MRCHEM_ENABLE_LIBXC
   162 |             if (use_libxc) {
   163 |                 if (ids.empty()) {
   164 |                     MSG_ABORT("LibXC backend selected but no LibXC IDs specified. "
   165 |                               "Set MRCHEM_LIBXC_IDS (e.g. 402 for B3LYP, or '106,131' for BLYP), "
   166 |                               "or call Factory::setLibXCIDs().");
   167 |                 }
   168 |                 func_p = std::make_unique<LibXCGGA>(order, xcfun_p, diff_p, ids);
   169 |             } else
   170 | #endif
   171 |             {
   172 |                 func_p = std::make_unique<GGA>(order, xcfun_p, diff_p);
   173 |             }
   174 |         } else if (lda) {
   175 | #ifdef MRCHEM_ENABLE_LIBXC
   176 |             if (use_libxc) {
   177 |                 if (ids.empty()) {
   178 |                     MSG_ABORT("LibXC backend selected but no LibXC IDs specified. "
   179 |                               "Set MRCHEM_LIBXC_IDS (e.g. '1,9' for LDA X+PW92 C), "
   180 |                               "or call Factory::setLibXCIDs().");
   181 |                 }
   182 |                 func_p = std::make_unique<LibXCLDA>(order, xcfun_p, ids);
   183 |             } else
   184 | #endif
   185 |             {
   186 |                 func_p = std::make_unique<LDA>(order, xcfun_p);
   187 |             }
   188 |         }
   189 |     }
   190 | 
   191 |     if (!func_p) {
   192 |         MSG_ABORT("Invalid or unsupported functional type (spin/LDA/GGA combination).");
   193 |     }
   194 | 
   195 |     // ---------------------------------------------------------------------
   196 |     // Keep original behavior: set derivative operator & knobs on the functional
   197 |     // ---------------------------------------------------------------------
   198 |     // (Upstream MRChem sets ABGV(0,0) as a default fallback.)
   199 |     diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.0, 0.0);
   200 |     func_p->setDerivOp(diff_p);
   201 |     func_p->setLogGradient(log_grad);
   202 |     func_p->setDensityCutoff(cutoff);
   203 | 
   204 |     auto mrdft_p = std::make_unique<MRDFT>(grid_p, func_p);
   205 |     return mrdft_p;
   206 | }
   207 | 
   208 | } // namespace mrdft

=== FILE: src/mrdft/Factory.h | 1.3 KB ===
     1 | #pragma once
     2 | 
     3 | #include <MRCPP/MWOperators>
     4 | #include <XCFun/xcfun.h>
     5 | 
     6 | #include "MRDFT.h"
     7 | 
     8 | namespace mrdft {
     9 | 
    10 | class Factory final {
    11 | public:
    12 |     Factory(const mrcpp::MultiResolutionAnalysis<3> &MRA);
    13 |     ~Factory() = default;
    14 | 
    15 |     void setSpin(bool s) { spin = s; }
    16 |     void setOrder(int k) { order = k; }
    17 |     void setUseGamma(bool g) { gamma = g; }
    18 |     void setLogGradient(bool lg) { log_grad = lg; }
    19 |     void setDensityCutoff(double c) { cutoff = c; }
    20 |     void setDerivative(const std::string &n) { diff_s = n; }
    21 |     void setFunctional(const std::string &n, double c = 1.0) { xcfun_set(xcfun_p.get(), n.c_str(), c); }
    22 | 
    23 |     // Optional: select backend and (for LibXC) functional IDs via code (we also read env vars)
    24 |     void setBackend(const std::string &b) { backend = b; }
    25 |     void setLibXCIDs(const std::vector<int> &ids_in) { libxc_ids = ids_in; }
    26 | 
    27 |     std::unique_ptr<MRDFT> build();
    28 | 
    29 | private:
    30 |     int order{1};
    31 |     bool spin{false};
    32 |     bool gamma{false};
    33 |     bool log_grad{false};
    34 |     double cutoff{-1.0};
    35 |     std::string diff_s{"abgv_00"};
    36 |     std::string backend{"xcfun"};           // "xcfun" (default) or "libxc"
    37 |     std::vector<int> libxc_ids;             // used only if backend == "libxc"
    38 |     const mrcpp::MultiResolutionAnalysis<3> mra;
    39 | 
    40 |     XC_p xcfun_p;
    41 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> diff_p;
    42 | };
    43 | 
    44 | } // namespace mrdft

=== FILE: src/mrdft/Functional.cpp | 8.6 KB ===
     1 | /*
     2 |  * MRChem, a numerical real-space code for molecular electronic structure
     3 |  * calculations within the self-consistent field (SCF) approximations of quantum
     4 |  * chemistry (Hartree-Fock and Density Functional Theory).
     5 |  * Copyright (C) ...
     6 |  */
     7 | 
     8 | #include <MRCPP/Printer>
     9 | 
    10 | #include "Functional.h"
    11 | 
    12 | namespace mrdft {
    13 | 
    14 | namespace {
    15 | // Put XCFun into a valid “user eval” mode so input_length/output_length work.
    16 | inline void ensure_xcfun_user_setup(xcfun_t* xf, int order, bool spin, bool is_gga) {
    17 |     const unsigned int mode      = 1u;                    // partial derivatives
    18 |     const unsigned int func_type = is_gga ? 1u : 0u;      // 0=LDA, 1=GGA
    19 |     const unsigned int dens_type = spin ? 2u : 1u;        // 1 (unpol) or 2 (pol)
    20 |     const unsigned int laplacian = 0u;
    21 |     const unsigned int kinetic   = 0u;
    22 |     const unsigned int current   = 0u;
    23 |     const unsigned int exp_deriv = is_gga ? 1u : 0u;      // explicit derivs for GGA only
    24 | 
    25 |     xcfun_user_eval_setup(xf, order, func_type, dens_type,
    26 |                           mode, laplacian, kinetic, current, exp_deriv);
    27 | }
    28 | } // namespace
    29 | 
    30 | /** @brief Run a collection of grid points through XCFun
    31 |  *
    32 |  * Each row corresponds to one grid point.
    33 |  */
    34 | Eigen::MatrixXd Functional::evaluate(Eigen::MatrixXd &inp) const {
    35 |     // Make sure XCFun knows what shape to expect/produce
    36 |     ensure_xcfun_user_setup(xcfun.get(), order, isSpin(), isGGA());
    37 | 
    38 |     int nInp = xcfun_input_length(xcfun.get());   // input parameters to XCFun
    39 |     int nOut = xcfun_output_length(xcfun.get());  // output parameters from XCFun
    40 |     int nPts = inp.cols();
    41 |     if (nInp != inp.rows()) MSG_ABORT("Invalid input");
    42 | 
    43 |     Eigen::MatrixXd out = Eigen::MatrixXd::Zero(nOut, nPts);
    44 |     for (int i = 0; i < nPts; i++) {
    45 |         bool calc = true;
    46 |         if (isSpin()) {
    47 |             if (inp(0, i) < cutoff and inp(1, i) < cutoff) calc = false;
    48 |         } else {
    49 |             if (inp(0, i) < cutoff) calc = false;
    50 |         }
    51 |         if (calc) xcfun_eval(xcfun.get(), inp.col(i).data(), out.col(i).data());
    52 |     }
    53 |     return out;
    54 | }
    55 | 
    56 | /** @brief Run a collection of grid points through XCFun
    57 |  *
    58 |  * Each column corresponds to one grid point.
    59 |  */
    60 | Eigen::MatrixXd Functional::evaluate_transposed(Eigen::MatrixXd &inp) const {
    61 |     // Make sure XCFun knows what shape to expect/produce
    62 |     ensure_xcfun_user_setup(xcfun.get(), order, isSpin(), isGGA());
    63 | 
    64 |     int nInp = xcfun_input_length(xcfun.get());   // input parameters to XCFun
    65 |     int nOut = xcfun_output_length(xcfun.get());  // output parameters from XCFun
    66 |     int nPts = inp.rows();
    67 |     if (nInp != inp.cols()) MSG_ABORT("Invalid input");
    68 | 
    69 |     Eigen::MatrixXd out = Eigen::MatrixXd::Zero(nPts, nOut);
    70 |     Eigen::VectorXd inp_row = Eigen::VectorXd::Zero(nInp);
    71 |     Eigen::VectorXd out_row = Eigen::VectorXd::Zero(nOut);
    72 |     for (int i = 0; i < nPts; i++) {
    73 |         bool calc = true;
    74 |         if (isSpin()) {
    75 |             if (inp(i, 0) < cutoff and inp(i, 1) < cutoff) calc = false;
    76 |         } else {
    77 |             if (inp(i, 0) < cutoff) calc = false;
    78 |         }
    79 |         for (int j = 0; j < nInp; j++) inp_row(j) = inp(i, j);
    80 |         if (calc) xcfun_eval(xcfun.get(), inp_row.data(), out_row.data());
    81 |         for (int j = 0; j < nOut; j++) out(i, j) = out_row(j);
    82 |     }
    83 |     return out;
    84 | }
    85 | 
    86 | /** @brief Contract (row-major) */
    87 | Eigen::MatrixXd Functional::contract(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const {
    88 |     auto nPts = xc_data.cols();
    89 |     auto nFcs = getCtrOutputLength();
    90 |     Eigen::MatrixXd out_data = Eigen::MatrixXd::Zero(nFcs, nPts);
    91 |     out_data.row(0) = xc_data.row(0); // keep energy functional
    92 | 
    93 |     for (int i = 0; i < this->xc_mask.rows(); i++) {
    94 |         Eigen::VectorXd cont_i = Eigen::VectorXd::Zero(nPts);
    95 |         for (int j = 0; j < this->xc_mask.cols(); j++) {
    96 |             Eigen::VectorXd cont_ij = Eigen::VectorXd::Zero(nPts);
    97 |             int xc_idx = this->xc_mask(i, j);
    98 |             int d_idx = this->d_mask(j);
    99 |             if (d_idx >= 0) {
   100 |                 cont_ij = xc_data.row(xc_idx).array() * d_data.row(d_idx).array();
   101 |             } else {
   102 |                 cont_ij = xc_data.row(xc_idx);
   103 |             }
   104 |             cont_i += cont_ij;
   105 |         }
   106 |         out_data.row(i + 1) = cont_i;
   107 |     }
   108 |     return out_data;
   109 | }
   110 | 
   111 | /** @brief Contract (column-major) */
   112 | Eigen::MatrixXd Functional::contract_transposed(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const {
   113 |     auto nPts = xc_data.rows();
   114 |     auto nFcs = getCtrOutputLength();
   115 |     Eigen::MatrixXd out_data = Eigen::MatrixXd::Zero(nPts, nFcs);
   116 |     out_data.col(0) = xc_data.col(0); // keep energy functional
   117 | 
   118 |     for (int i = 0; i < this->xc_mask.rows(); i++) {
   119 |         for (int j = 0; j < this->xc_mask.cols(); j++) {
   120 |             int xc_idx = this->xc_mask(i, j);
   121 |             int d_idx = this->d_mask(j);
   122 |             if (d_idx >= 0) {
   123 |                 out_data.col(i + 1) += xc_data.col(xc_idx).cwiseProduct(d_data.col(d_idx));
   124 |             } else {
   125 |                 out_data.col(i + 1) += xc_data.col(xc_idx);
   126 |             }
   127 |         }
   128 |     }
   129 |     return out_data;
   130 | }
   131 | 
   132 | /** @brief makepot: compute XC and contract */
   133 | void Functional::makepot(mrcpp::FunctionTreeVector<3> &inp, std::vector<mrcpp::FunctionNode<3> *> xcNodes)  const {
   134 |     if (this->log_grad){
   135 |         MSG_ERROR("log_grad not implemented");
   136 |     }
   137 | 
   138 |     mrcpp::NodeIndex<3> nodeIdx = xcNodes[0]->getNodeIndex();
   139 |     mrcpp::FunctionTree<3>* rho0=std::get<1>(inp[0]);
   140 |     mrcpp::MWNode<3> node(rho0->getNode(nodeIdx),true,false);
   141 |     int ncoefs = rho0->getTDim() * rho0->getKp1_d();
   142 |     int xcfun_inpsize = 1; // rho
   143 |     int spinsize = 1; // paired
   144 |     if (isSpin()) spinsize = 2; // alpha, beta
   145 |     xcfun_inpsize *= spinsize; // alpha and beta
   146 |     if (isGGA()) xcfun_inpsize *= 4; // add gradient (3 components for each spin)
   147 | 
   148 |     Eigen::MatrixXd xcfun_inp(ncoefs, xcfun_inpsize);
   149 |     double* coef = node.getCoefs();
   150 | 
   151 |     for (int i = 0; i < spinsize; i++) {
   152 |         mrcpp::FunctionTree<3>* rho=std::get<1>(inp[i]);
   153 |         node.attachCoefs(xcfun_inp.col(i).data());
   154 |         for (int j = 0; j < ncoefs; j++) xcfun_inp(j,i) = rho->getNode(nodeIdx).getCoefs()[j];
   155 |         node.mwTransform(mrcpp::Reconstruction);
   156 |         node.cvTransform(mrcpp::Forward);
   157 | 
   158 |         if (isGGA()) {
   159 |             for (int d = 0; d < 3; d++) {
   160 |                 node.attachCoefs(xcfun_inp.col(spinsize + 3*i + d).data());
   161 |                 mrcpp::DerivativeCalculator<3> derivcalc(d, *this->derivOp, *rho);
   162 |                 derivcalc.calcNode(rho->getNode(nodeIdx), node);
   163 |                 node.mwTransform(mrcpp::Reconstruction);
   164 |                 node.cvTransform(mrcpp::Forward);
   165 |             }
   166 |        }
   167 |     }
   168 | 
   169 |     // NB: VIRTUAL DISPATCH here (so LibXC adapters can override)!
   170 |     Eigen::MatrixXd xc_out = this->evaluate_transposed(xcfun_inp);
   171 | 
   172 |     int ctrsize = inp.size()-spinsize;
   173 |     int d_datasize = ctrsize;
   174 |     if (isGGA()) d_datasize *= 4;
   175 |     Eigen::MatrixXd d_data = Eigen::MatrixXd::Zero(ncoefs, d_datasize);
   176 |     if (d_datasize > 0) {
   177 |         for (int i = 0; i < ctrsize; i++) {
   178 |             mrcpp::FunctionTree<3>* rho = std::get<1>(inp[i+spinsize]);
   179 |             node.attachCoefs(d_data.col(i).data());
   180 |             for (int j = 0; j < ncoefs; j++) d_data(j,i) = rho->getNode(nodeIdx).getCoefs()[j];
   181 |             node.mwTransform(mrcpp::Reconstruction);
   182 |             node.cvTransform(mrcpp::Forward);
   183 |             if (isGGA()) {
   184 |                 for (int d = 0; d < 3; d++) {
   185 |                     node.attachCoefs(d_data.col(ctrsize + 3*i + d).data());
   186 |                     mrcpp::DerivativeCalculator<3> derivcalc(d, *this->derivOp, *rho);
   187 |                     derivcalc.calcNode(rho->getNode(nodeIdx), node);
   188 |                     node.mwTransform(mrcpp::Reconstruction);
   189 |                     node.cvTransform(mrcpp::Forward);
   190 |                 }
   191 |             }
   192 |         }
   193 |     }
   194 | 
   195 |     Eigen::MatrixXd Ctrout = contract_transposed(xc_out, d_data);
   196 | 
   197 |     int xc_outsize = 2;
   198 |     if (isSpin()) xc_outsize = 3;
   199 |     for (int i = 0; i < xc_outsize; i++) {
   200 |         node.attachCoefs(Ctrout.col(i).data());
   201 |         node.cvTransform(mrcpp::Backward);
   202 |         node.mwTransform(mrcpp::Compression);
   203 |         for (int j = 0; j < ncoefs; j++) xcNodes[i]->getCoefs()[j] = Ctrout(j,i);
   204 |         xcNodes[i]->setHasCoefs();
   205 |         if (isGGA() and i>0) {
   206 |             for (int d = 0; d < 3; d++) {
   207 |                 node.attachCoefs(Ctrout.col(xc_outsize + 3*(i-1) + d).data());
   208 |                 node.cvTransform(mrcpp::Backward);
   209 |                 node.mwTransform(mrcpp::Compression);
   210 |                 mrcpp::DerivativeCalculator<3> derivcalc(d,*this->derivOp, *rho0);
   211 |                 mrcpp::MWNode<3> noded(rho0->getNode(nodeIdx),true,false);
   212 |                 derivcalc.calcNode(node, noded);
   213 |                 for (int j = 0; j < ncoefs; j++) xcNodes[i]->getCoefs()[j] -= noded.getCoefs()[j];
   214 |             }
   215 |         }
   216 |     }
   217 |     node.attachCoefs(coef);
   218 | }
   219 | 
   220 | } // namespace mrdft

=== FILE: src/mrdft/Functional.h | 3.5 KB ===
     1 | // ===== BEGIN src/mrdft/Functional.h =====
     2 | /*
     3 |  * MRChem, a numerical real-space code for molecular electronic structure
     4 |  * calculations within the self-consistent field (SCF) approximations of quantum
     5 |  * chemistry (Hartree-Fock and Density Functional Theory).
     6 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
     7 |  *
     8 |  * This file is part of MRChem.
     9 |  *
    10 |  * MRChem is free software: you can redistribute it and/or modify
    11 |  * it under the terms of the GNU Lesser General Public License as published by
    12 |  * the Free Software Foundation, either version 3 of the License, or
    13 |  * (at your option) any later version.
    14 |  *
    15 |  * MRChem is distributed in the hope that it will be useful,
    16 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
    17 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18 |  * GNU Lesser General Public License for more details.
    19 |  *
    20 |  * You should have received a copy of the GNU Lesser General Public License
    21 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
    22 |  *
    23 |  * For information on the complete list of contributors to MRChem, see:
    24 |  * <https://mrchem.readthedocs.io/>
    25 |  */
    26 | 
    27 | #pragma once
    28 | 
    29 | #include <memory>
    30 | 
    31 | #include <Eigen/Core>
    32 | #include <MRCPP/MWFunctions>
    33 | #include <MRCPP/MWOperators>
    34 | #include <MRCPP/trees/FunctionNode.h>
    35 | #include <XCFun/xcfun.h>
    36 | 
    37 | namespace mrdft {
    38 | 
    39 | using XC_p = std::unique_ptr<xcfun_t, decltype(&xcfun_delete)>;
    40 | 
    41 | class Functional {
    42 | public:
    43 |     Functional(int k, XC_p &f)
    44 |             : order(k)
    45 |             , xcfun(std::move(f)) {}
    46 |     virtual ~Functional() = default;
    47 | 
    48 |     void makepot(mrcpp::FunctionTreeVector<3> &inp, std::vector<mrcpp::FunctionNode<3> *> xcNodes) const;
    49 | 
    50 |     void setLogGradient(bool log) { log_grad = log; }
    51 |     void setDensityCutoff(double cut) { cutoff = cut; }
    52 |     void setDerivOp(std::unique_ptr<mrcpp::DerivativeOperator<3>> &d) {derivOp = std::move(d);}
    53 | 
    54 |     virtual bool isSpin() const = 0;
    55 |     bool isLDA() const { return (not(isGGA() or isMetaGGA())); }
    56 |     bool isGGA() const { return xcfun_is_gga(xcfun.get()); }
    57 |     bool isMetaGGA() const { return xcfun_is_metagga(xcfun.get()); }
    58 |     bool isHybrid() const { return (std::abs(amountEXX()) > 1.0e-10); }
    59 |     double amountEXX() const {
    60 |         double exx = 0.0;
    61 |         xcfun_get(xcfun.get(), "exx", &exx);
    62 |         return exx;
    63 |     }
    64 |     double XCenergy = 0.0;
    65 | 
    66 |     // MAKE THESE VIRTUAL so LibXC subclasses can override them
    67 |     virtual Eigen::MatrixXd evaluate(Eigen::MatrixXd &inp) const;
    68 |     virtual Eigen::MatrixXd evaluate_transposed(Eigen::MatrixXd &inp) const;
    69 | 
    70 |     friend class MRDFT;
    71 | 
    72 | protected:
    73 |     const int order;
    74 |     bool log_grad{false};
    75 |     double cutoff{-1.0};
    76 |     Eigen::VectorXi d_mask;
    77 |     Eigen::MatrixXi xc_mask;
    78 |     XC_p xcfun;
    79 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> derivOp{nullptr};
    80 | 
    81 |     int getXCInputLength() const { return xcfun_input_length(xcfun.get()); }
    82 |     int getXCOutputLength() const { return xcfun_output_length(xcfun.get()); }
    83 |     virtual int getCtrInputLength() const = 0;
    84 |     virtual int getCtrOutputLength() const = 0;
    85 | 
    86 |     Eigen::MatrixXd contract(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const;
    87 |     Eigen::MatrixXd contract_transposed(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const;
    88 | 
    89 |     virtual void clear() = 0;
    90 |     virtual mrcpp::FunctionTreeVector<3> setupXCInput() = 0;
    91 |     virtual mrcpp::FunctionTreeVector<3> setupCtrInput() = 0;
    92 | 
    93 |     virtual void preprocess(mrcpp::FunctionTreeVector<3> &inp) = 0;
    94 |     virtual mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) = 0;
    95 | };
    96 | 
    97 | } // namespace mrdft
    98 | // ===== END src/mrdft/Functional.h =====

=== FILE: src/mrdft/GGA.cpp | 3.8 KB ===
     1 | /*
     2 |  * (banner unchanged)
     3 |  */
     4 | #include "MRCPP/MWOperators"
     5 | #include "MRCPP/Printer"
     6 | 
     7 | #include "GGA.h"
     8 | #include "xc_utils.h"
     9 | 
    10 | namespace mrdft {
    11 | 
    12 | GGA::GGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d)
    13 |         : Functional(k, f)
    14 |         , derivative(std::move(d)) {
    15 |     xc_mask = xc_utils::build_output_mask(false, false, this->order);
    16 |     d_mask = xc_utils::build_density_mask(false, false, this->order);
    17 | }
    18 | 
    19 | /** @brief Clear internal functions
    20 |  *
    21 |  * Ownership of densities is outside MRDFT -> clear
    22 |  * Ownership of gradients is inside MRDFT -> free
    23 |  */
    24 | void GGA::clear() {
    25 |     mrcpp::clear(this->rho, false);
    26 |     mrcpp::clear(this->grad, true);
    27 | }
    28 | 
    29 | /** @brief Number of function involved in contraction step */
    30 | int GGA::getCtrInputLength() const {
    31 |     int length = -1;
    32 |     if (this->order < 2) length = 0;
    33 |     if (this->order == 2) length = 4;
    34 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
    35 |     return length;
    36 | }
    37 | 
    38 | /** @brief Collect input functions to xcfun evaluation step
    39 |  *
    40 |  * For GGA : [rho_0, grad(rho_0)]
    41 |  */
    42 | mrcpp::FunctionTreeVector<3> GGA::setupXCInput() {
    43 |     if (this->rho.size() < 1) MSG_ERROR("Density not initialized");
    44 |     if (this->grad.size() < 3) MSG_ERROR("Gradient not initialized");
    45 | 
    46 |     mrcpp::FunctionTreeVector<3> out_vec;
    47 |     out_vec.push_back(this->rho[0]);
    48 |     out_vec.insert(out_vec.end(), this->grad.begin(), this->grad.begin() + 3);
    49 |     return out_vec;
    50 | }
    51 | 
    52 | /** @brief Collect input functions to contraction step
    53 |  *
    54 |  * For GGA:
    55 |  * Ground State: No contraction, empty vector
    56 |  * Linear Response: [rho_1, grad(rho_1)]
    57 |  * Higher Response: NOT_IMPLEMENTED
    58 |  */
    59 | mrcpp::FunctionTreeVector<3> GGA::setupCtrInput() {
    60 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
    61 |     mrcpp::FunctionTreeVector<3> out_vec;
    62 |     if (this->order == 2) {
    63 |         out_vec.push_back(this->rho[1]);
    64 |         out_vec.insert(out_vec.end(), this->grad.begin() + 3, this->grad.begin() + 6);
    65 |     }
    66 |     return out_vec;
    67 | }
    68 | 
    69 | /** @brief Prepare input functions to xcfun
    70 |  *
    71 |  * Collects input densities and computes necessary gradients.
    72 |  */
    73 | void GGA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
    74 |     if (inp_vec.size() != this->order) MSG_ERROR("Invalid input length");
    75 |     if (this->rho.size() > 0) MSG_ERROR("Density not empty");
    76 |     if (this->grad.size() > 0) MSG_ERROR("Gradient not empty");
    77 | 
    78 |     int n = 0;
    79 |     for (int i = 0; i < this->order; i++) this->rho.push_back(inp_vec[n++]);
    80 | 
    81 |     for (int i = 0; i < this->order; i++) {
    82 |         mrcpp::FunctionTreeVector<3> tmp;
    83 |         if (this->log_grad and i == 0) {
    84 |             tmp = xc_utils::log_gradient(*this->derivative, mrcpp::get_func(this->rho, i));
    85 |         } else {
    86 |             tmp = mrcpp::gradient(*this->derivative, mrcpp::get_func(this->rho, i));
    87 |         }
    88 |         this->grad.insert(this->grad.end(), tmp.begin(), tmp.end());
    89 |     }
    90 | }
    91 | 
    92 | /** @brief Compute final output functions
    93 |  *
    94 |  * For GGA:
    95 |  * f_xc       : out[0] = inp[0]
    96 |  * df_xc/drho : out[1] = inp[1] - div(inp[2,3,4])
    97 |  */
    98 | mrcpp::FunctionTreeVector<3> GGA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
    99 |     // Energy density
   100 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
   101 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
   102 | 
   103 |     // Potential part
   104 |     mrcpp::FunctionTree<3> &df_dr = mrcpp::get_func(inp_vec, 1);
   105 |     mrcpp::FunctionTreeVector<3> df_dg(inp_vec.begin() + 2, inp_vec.begin() + 5);
   106 | 
   107 |     auto *tmp = new mrcpp::FunctionTree<3>(df_dr.getMRA());
   108 |     mrcpp::divergence(*tmp, *this->derivative, df_dg);
   109 | 
   110 |     auto *v_xc = new mrcpp::FunctionTree<3>(df_dr.getMRA());
   111 |     mrcpp::build_grid(*v_xc, df_dr);
   112 |     mrcpp::build_grid(*v_xc, *tmp);
   113 |     mrcpp::add(-1.0, *v_xc, 1.0, df_dr, -1.0, *tmp);
   114 |     delete tmp;
   115 | 
   116 |     // Collect output
   117 |     mrcpp::FunctionTreeVector<3> out_vec;
   118 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
   119 |     out_vec.push_back(std::make_tuple(1.0, v_xc));
   120 |     v_xc = nullptr;
   121 | 
   122 |     return out_vec;
   123 | }
   124 | 
   125 | } // namespace mrdft

=== FILE: src/mrdft/GGA.h | 868.0 B ===
     1 | #pragma once
     2 | 
     3 | #include <XCFun/xcfun.h>
     4 | #include "Functional.h"
     5 | 
     6 | namespace mrdft {
     7 | 
     8 | class GGA : public Functional {
     9 | public:
    10 |     GGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d);
    11 |     ~GGA() override = default;
    12 | 
    13 |     bool isSpin() const override { return false; }
    14 | 
    15 | private:
    16 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> derivative{nullptr};
    17 |     mrcpp::FunctionTreeVector<3> rho;
    18 |     mrcpp::FunctionTreeVector<3> grad;
    19 | 
    20 |     int getCtrInputLength() const override;
    21 |     int getCtrOutputLength() const override { return 5; }
    22 | 
    23 |     void clear() override;
    24 |     mrcpp::FunctionTreeVector<3> setupXCInput() override;
    25 |     mrcpp::FunctionTreeVector<3> setupCtrInput() override;
    26 | 
    27 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
    28 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
    29 | };
    30 | 
    31 | } // namespace mrdft

=== FILE: src/mrdft/LDA.cpp | 2.8 KB ===
     1 | /*
     2 |  * (banner unchanged)
     3 |  */
     4 | 
     5 | #include "MRCPP/MWFunctions"
     6 | #include "MRCPP/Printer"
     7 | 
     8 | #include "LDA.h"
     9 | #include "xc_utils.h"
    10 | 
    11 | namespace mrdft {
    12 | 
    13 | LDA::LDA(int k, XC_p &f)
    14 |         : Functional(k, f) {
    15 |     xc_mask = xc_utils::build_output_mask(true, false, this->order);
    16 |     d_mask = xc_utils::build_density_mask(true, false, this->order);
    17 | }
    18 | 
    19 | /** @brief Clear internal functions
    20 |  *
    21 |  * Ownership of densities is outside MRDFT -> clear
    22 |  * Ownership of gradients is inside MRDFT -> free
    23 |  */
    24 | void LDA::clear() {
    25 |     mrcpp::clear(this->rho, false);
    26 | }
    27 | 
    28 | /** @brief Number of function involved in contraction step */
    29 | int LDA::getCtrInputLength() const {
    30 |     int length = -1;
    31 |     if (this->order < 2) length = 0;
    32 |     if (this->order == 2) length = 1;
    33 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
    34 |     return length;
    35 | }
    36 | 
    37 | /** @brief Collect input functions to xcfun evaluation step
    38 |  *
    39 |  * For LDA : [rho_0]
    40 |  */
    41 | mrcpp::FunctionTreeVector<3> LDA::setupXCInput() {
    42 |     if (this->rho.size() < 1) MSG_ERROR("Density not initialized");
    43 |     mrcpp::FunctionTreeVector<3> out_vec;
    44 |     out_vec.push_back(this->rho[0]);
    45 |     return out_vec;
    46 | }
    47 | 
    48 | /** @brief Collect input functions to contraction step
    49 |  *
    50 |  * For LDA:
    51 |  * Ground State: No contraction, empty vector
    52 |  * Linear Response: [rho_1]
    53 |  * Higher Response: NOT_IMPLEMENTED
    54 |  */
    55 | mrcpp::FunctionTreeVector<3> LDA::setupCtrInput() {
    56 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
    57 |     mrcpp::FunctionTreeVector<3> out_vec;
    58 |     if (order == 2) out_vec.push_back(this->rho[1]);
    59 |     return out_vec;
    60 | }
    61 | 
    62 | /** @brief Prepare input functions to xcfun
    63 |  *
    64 |  * Collects input densities and computes necessary gradients.
    65 |  *
    66 |  * Ordering of input:
    67 |  * inp_vec[0] = alpha_0
    68 |  * inp_vec[1] = beta_0
    69 |  * inp_vec[2] = alpha_1
    70 |  * inp_vec[3] = beta_1
    71 |  * ...
    72 |  */
    73 | void LDA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
    74 |     if (inp_vec.size() != this->order) MSG_ERROR("Invalid input length");
    75 |     if (this->rho.size() > 0) MSG_ERROR("Density not empty");
    76 | 
    77 |     for (auto i = 0; i < this->order; i++) this->rho.push_back(inp_vec[i]);
    78 | }
    79 | 
    80 | /** @brief Compute final output functions
    81 |  *
    82 |  * Combine the raw partial derivatives from xcfun into functional derivatives.
    83 |  *
    84 |  * For LDA:
    85 |  * f_xc       : out[0] = inp[0]
    86 |  * df_xc/drho : out[1] = inp[1]
    87 |  */
    88 | mrcpp::FunctionTreeVector<3> LDA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
    89 |     // Energy density
    90 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
    91 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
    92 | 
    93 |     // XC potential
    94 |     mrcpp::FunctionTree<3> &v_xc = mrcpp::get_func(inp_vec, 1);
    95 |     inp_vec[1] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
    96 | 
    97 |     mrcpp::FunctionTreeVector<3> out_vec;
    98 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
    99 |     out_vec.push_back(std::make_tuple(1.0, &v_xc));
   100 |     return out_vec;
   101 | }
   102 | 
   103 | } // namespace mrdft

=== FILE: src/mrdft/LDA.h | 708.0 B ===
     1 | #pragma once
     2 | 
     3 | #include <XCFun/xcfun.h>
     4 | #include "Functional.h"
     5 | 
     6 | namespace mrdft {
     7 | 
     8 | class LDA : public Functional {
     9 | public:
    10 |     LDA(int k, XC_p &f);
    11 |     ~LDA() override = default;
    12 | 
    13 |     bool isSpin() const override { return false; }
    14 | 
    15 | private:
    16 |     mrcpp::FunctionTreeVector<3> rho;
    17 | 
    18 |     int getCtrInputLength() const override;
    19 |     int getCtrOutputLength() const override { return 2; }
    20 | 
    21 |     void clear() override;
    22 |     mrcpp::FunctionTreeVector<3> setupXCInput() override;
    23 |     mrcpp::FunctionTreeVector<3> setupCtrInput() override;
    24 | 
    25 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
    26 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
    27 | };
    28 | 
    29 | } // namespace mrdft

=== FILE: src/mrdft/LibXCBackend.cpp | 13.4 KB ===
     1 | // src/mrdft/LibXCBackend.cpp
     2 | #include "LibXCBackend.h"
     3 | 
     4 | #include <vector>
     5 | #include <stdexcept>
     6 | #include <cmath>
     7 | #include <algorithm>   // std::max
     8 | 
     9 | // If xc.h isn't included by the header, uncomment the next line:
    10 | // #include <xc.h>
    11 | 
    12 | namespace mrdft {
    13 | 
    14 | // ======================= helpers (unpolarized) =======================
    15 | 
    16 | static void split_gga_inputs_unpolarized(const Eigen::MatrixXd &inp,
    17 |                                          Eigen::VectorXd &rho,
    18 |                                          Eigen::VectorXd &sigma)
    19 | {
    20 |     const int n = static_cast<int>(inp.rows());
    21 |     const int m = static_cast<int>(inp.cols());
    22 | 
    23 |     if (n == 0) { rho.resize(0); sigma.resize(0); return; }
    24 | 
    25 |     if (m == 2) {
    26 |         // layout: [rho, sigma] where sigma = |∇rho|^2 (or gamma)
    27 |         rho   = inp.col(0);
    28 |         sigma = inp.col(1);
    29 |         return;
    30 |     }
    31 | 
    32 |     if (m == 4) {
    33 |         // layout: [rho, gradx, grady, gradz]  -> sigma = |∇rho|^2
    34 |         rho   = inp.col(0);
    35 |         sigma.resize(n);
    36 |         for (int i = 0; i < n; ++i) {
    37 |             const double gx = inp(i, 1);
    38 |             const double gy = inp(i, 2);
    39 |             const double gz = inp(i, 3);
    40 |             sigma(i) = gx*gx + gy*gy + gz*gz;
    41 |         }
    42 |         return;
    43 |     }
    44 | 
    45 |     throw std::runtime_error(
    46 |         "LibXCGGA: unsupported input layout. "
    47 |         "Expected (rho,sigma) or (rho,gradx,grady,gradz). "
    48 |         "Got " + std::to_string(m) + " columns.");
    49 | }
    50 | 
    51 | // Accumulate one LibXC GGA functional into (exc, vrho, vsigma)
    52 | // note: LibXC API takes a non-const xc_func_type*; we const_cast safely.
    53 | static void add_gga_unpolarized(const xc_func_type &f,
    54 |                                 int n,
    55 |                                 const double *rho,   // len n
    56 |                                 const double *sigma, // len n
    57 |                                 double *exc,         // len n (accum)
    58 |                                 double *vrho,        // len n (accum)
    59 |                                 double *vsigma)      // len n (accum)
    60 | {
    61 |     std::vector<double> exc_i(n, 0.0), vrho_i(n, 0.0), vsigma_i(n, 0.0);
    62 |     xc_func_type *fp = const_cast<xc_func_type*>(&f);
    63 |     xc_gga_exc_vxc(fp, n, rho, sigma, exc_i.data(), vrho_i.data(), vsigma_i.data());
    64 |     for (int i = 0; i < n; ++i) {
    65 |         exc[i]    += exc_i[i];
    66 |         vrho[i]   += vrho_i[i];
    67 |         vsigma[i] += vsigma_i[i];
    68 |     }
    69 | }
    70 | 
    71 | // ======================= helpers (polarized) =======================
    72 | 
    73 | static void split_lda_inputs_polarized(const Eigen::MatrixXd &inp,
    74 |                                        Eigen::VectorXd &rho_up,
    75 |                                        Eigen::VectorXd &rho_dn)
    76 | {
    77 |     const int n = static_cast<int>(inp.rows());
    78 |     const int m = static_cast<int>(inp.cols());
    79 |     if (n == 0) { rho_up.resize(0); rho_dn.resize(0); return; }
    80 | 
    81 |     if (m == 2) {           // [rho_up, rho_dn]
    82 |         rho_up = inp.col(0);
    83 |         rho_dn = inp.col(1);
    84 |         return;
    85 |     }
    86 | 
    87 |     throw std::runtime_error(
    88 |         "LibXCSpinLDA: unsupported input layout. "
    89 |         "Expected 2 columns (rho_up, rho_dn). Got " + std::to_string(m));
    90 | }
    91 | 
    92 | static void split_gga_inputs_polarized(const Eigen::MatrixXd &inp,
    93 |                                        Eigen::VectorXd &rho_up,
    94 |                                        Eigen::VectorXd &rho_dn,
    95 |                                        Eigen::VectorXd &sigma_uu,
    96 |                                        Eigen::VectorXd &sigma_ud,
    97 |                                        Eigen::VectorXd &sigma_dd)
    98 | {
    99 |     const int n = static_cast<int>(inp.rows());
   100 |     const int m = static_cast<int>(inp.cols());
   101 |     if (n == 0) {
   102 |         rho_up.resize(0); rho_dn.resize(0);
   103 |         sigma_uu.resize(0); sigma_ud.resize(0); sigma_dd.resize(0);
   104 |         return;
   105 |     }
   106 | 
   107 |     if (m == 5) {
   108 |         // [rho_up, rho_dn, sigma_uu, sigma_ud, sigma_dd]
   109 |         rho_up   = inp.col(0);
   110 |         rho_dn   = inp.col(1);
   111 |         sigma_uu = inp.col(2);
   112 |         sigma_ud = inp.col(3);
   113 |         sigma_dd = inp.col(4);
   114 |         return;
   115 |     }
   116 | 
   117 |     if (m == 8) {
   118 |         // [rho_up, rho_dn, gx_u, gy_u, gz_u, gx_d, gy_d, gz_d]
   119 |         rho_up = inp.col(0);
   120 |         rho_dn = inp.col(1);
   121 |         const Eigen::VectorXd gx_u = inp.col(2), gy_u = inp.col(3), gz_u = inp.col(4);
   122 |         const Eigen::VectorXd gx_d = inp.col(5), gy_d = inp.col(6), gz_d = inp.col(7);
   123 | 
   124 |         sigma_uu.resize(n);
   125 |         sigma_ud.resize(n);
   126 |         sigma_dd.resize(n);
   127 |         for (int i = 0; i < n; ++i) {
   128 |             const double gux = gx_u(i), guy = gy_u(i), guz = gz_u(i);
   129 |             const double gdx = gx_d(i), gdy = gy_d(i), gdz = gz_d(i);
   130 |             sigma_uu(i) = gux*gux + guy*guy + guz*guz;
   131 |             sigma_dd(i) = gdx*gdx + gdy*gdy + gdz*gdz;
   132 |             sigma_ud(i) = gux*gdx + guy*gdy + guz*gdz; // can be negative
   133 |         }
   134 |         return;
   135 |     }
   136 | 
   137 |     throw std::runtime_error(
   138 |         "LibXCSpinGGA: unsupported input layout. "
   139 |         "Expected 5 columns (rho_up,rho_dn,sigma_uu,sigma_ud,sigma_dd) "
   140 |         "or 8 columns (rho_up,rho_dn,gx_u,gy_u,gz_u,gx_d,gy_d,gz_d). "
   141 |         "Got " + std::to_string(m));
   142 | }
   143 | 
   144 | // ======================= LDA (unpolarized) =======================
   145 | 
   146 | Eigen::MatrixXd LibXCLDA::evaluate_transposed(Eigen::MatrixXd &inp) const {
   147 |     // Expect a single column: rho
   148 |     const int n = static_cast<int>(inp.rows());
   149 |     const int m = static_cast<int>(inp.cols());
   150 |     if (m != 1) {
   151 |         throw std::runtime_error(
   152 |             "LibXCLDA: unsupported input layout. Expected 1 column (rho), got " +
   153 |             std::to_string(m));
   154 |     }
   155 | 
   156 |     std::vector<double> rho(n), exc(n, 0.0), vrho(n, 0.0);
   157 |     for (int i = 0; i < n; ++i) rho[i] = inp(i, 0);
   158 | 
   159 |     for (auto &func : handle.funcs) {
   160 |         std::vector<double> exc_i(n, 0.0), vrho_i(n, 0.0);
   161 |         xc_lda_exc_vxc(&func, n, rho.data(), exc_i.data(), vrho_i.data());
   162 |         for (int i = 0; i < n; ++i) {
   163 |             exc[i]  += exc_i[i];
   164 |             vrho[i] += vrho_i[i];
   165 |         }
   166 |     }
   167 | 
   168 |     // MRChem expects energy density per volume: F = n * exc
   169 |     Eigen::MatrixXd out(n, 2);
   170 |     for (int i = 0; i < n; ++i) {
   171 |         out(i, 0) = rho[i] * exc[i];  // F
   172 |         out(i, 1) = vrho[i];          // dF/dn
   173 |     }
   174 |     return out;
   175 | }
   176 | 
   177 | // ======================= GGA (unpolarized) =======================
   178 | 
   179 | Eigen::MatrixXd LibXCGGA::evaluate_transposed(Eigen::MatrixXd &inp) const {
   180 |     const int n = static_cast<int>(inp.rows());
   181 |     const int m = static_cast<int>(inp.cols());
   182 | 
   183 |     Eigen::VectorXd rho_v, sigma_v;
   184 |     Eigen::VectorXd gx_v, gy_v, gz_v;
   185 | 
   186 |     if (m == 2) {
   187 |         rho_v   = inp.col(0);
   188 |         sigma_v = inp.col(1);                 // σ = |∇ρ|² (or gamma)
   189 |     } else if (m == 4) {
   190 |         rho_v = inp.col(0);
   191 |         gx_v  = inp.col(1);
   192 |         gy_v  = inp.col(2);
   193 |         gz_v  = inp.col(3);
   194 |         sigma_v.resize(n);
   195 |         for (int i = 0; i < n; ++i) {
   196 |             const double gx = gx_v(i), gy = gy_v(i), gz = gz_v(i);
   197 |             sigma_v(i) = gx*gx + gy*gy + gz*gz;
   198 |         }
   199 |     } else {
   200 |         throw std::runtime_error(
   201 |             "LibXCGGA: unsupported input layout. "
   202 |             "Expected (rho,sigma) or (rho,gradx,grady,gradz). "
   203 |             "Got " + std::to_string(m) + " columns.");
   204 |     }
   205 | 
   206 |     std::vector<double> rho(n), sigma(n), exc(n, 0.0), vrho(n, 0.0), vsigma(n, 0.0);
   207 |     for (int i = 0; i < n; ++i) { rho[i] = rho_v(i); sigma[i] = sigma_v(i); }
   208 | 
   209 |     for (auto &func : handle.funcs) {
   210 |         std::vector<double> exc_i(n, 0.0), vrho_i(n, 0.0), vsigma_i(n, 0.0);
   211 |         xc_gga_exc_vxc(&func, n, rho.data(), sigma.data(),
   212 |                        exc_i.data(), vrho_i.data(), vsigma_i.data());
   213 |         for (int i = 0; i < n; ++i) {
   214 |             exc[i]    += exc_i[i];
   215 |             vrho[i]   += vrho_i[i];
   216 |             vsigma[i] += vsigma_i[i];
   217 |         }
   218 |     }
   219 | 
   220 |     if (m == 2) {
   221 |         // sigma layout: [F, dF/dn, dF/dsigma]
   222 |         Eigen::MatrixXd out(n, 3);
   223 |         for (int i = 0; i < n; ++i) {
   224 |             out(i, 0) = rho[i] * exc[i];  // F = n * exc
   225 |             out(i, 1) = vrho[i];          // dF/dn
   226 |             out(i, 2) = vsigma[i];        // dF/dsigma
   227 |         }
   228 |         return out;
   229 |     } else {
   230 |         // gradient layout: [F, dF/dn, dF/dgx, dF/dgy, dF/dgz]
   231 |         Eigen::MatrixXd out(n, 5);
   232 |         for (int i = 0; i < n; ++i) {
   233 |             const double gx = gx_v(i), gy = gy_v(i), gz = gz_v(i);
   234 |             out(i, 0) = rho[i] * exc[i];       // F
   235 |             out(i, 1) = vrho[i];               // dF/dn
   236 |             // chain rule: sigma = gx^2 + gy^2 + gz^2  => dF/dgk = 2*vsigma*gk
   237 |             out(i, 2) = 2.0 * vsigma[i] * gx;  // dF/dgx
   238 |             out(i, 3) = 2.0 * vsigma[i] * gy;  // dF/dgy
   239 |             out(i, 4) = 2.0 * vsigma[i] * gz;  // dF/dgz
   240 |         }
   241 |         return out;
   242 |     }
   243 | }
   244 | 
   245 | // ======================= Spin LDA (polarized) =======================
   246 | 
   247 | Eigen::MatrixXd LibXCSpinLDA::evaluate_transposed(Eigen::MatrixXd &inp) const {
   248 |     const int n = static_cast<int>(inp.rows());
   249 | 
   250 |     Eigen::VectorXd rho_up_v, rho_dn_v;
   251 |     split_lda_inputs_polarized(inp, rho_up_v, rho_dn_v);
   252 | 
   253 |     std::vector<double> rho(2*n);
   254 |     for (int i = 0; i < n; ++i) {
   255 |         rho[2*i + 0] = std::max(0.0, rho_up_v(i));
   256 |         rho[2*i + 1] = std::max(0.0, rho_dn_v(i));
   257 |     }
   258 | 
   259 |     std::vector<double> exc(n, 0.0);
   260 |     std::vector<double> vrho(2*n, 0.0);
   261 | 
   262 |     for (auto &func : handle.funcs) {
   263 |         std::vector<double> exc_i(n, 0.0), vrho_i(2*n, 0.0);
   264 |         xc_lda_exc_vxc(&func, n, rho.data(), exc_i.data(), vrho_i.data());
   265 |         for (int i = 0; i < n; ++i) {
   266 |             exc[i]      += exc_i[i];
   267 |             vrho[2*i+0] += vrho_i[2*i+0];
   268 |             vrho[2*i+1] += vrho_i[2*i+1];
   269 |         }
   270 |     }
   271 | 
   272 |     // Output: [F, dF/d(rho_up), dF/d(rho_dn)] with F = (rho_up+rho_dn)*exc
   273 |     Eigen::MatrixXd out(n, 3);
   274 |     for (int i = 0; i < n; ++i) {
   275 |         const double n_tot = rho[2*i+0] + rho[2*i+1];
   276 |         out(i, 0) = n_tot * exc[i];
   277 |         out(i, 1) = vrho[2*i + 0];
   278 |         out(i, 2) = vrho[2*i + 1];
   279 |     }
   280 |     return out;
   281 | }
   282 | 
   283 | // ======================= Spin GGA (polarized) =======================
   284 | 
   285 | Eigen::MatrixXd LibXCSpinGGA::evaluate_transposed(Eigen::MatrixXd &inp) const {
   286 |     const int n = static_cast<int>(inp.rows());
   287 |     const int m = static_cast<int>(inp.cols());
   288 | 
   289 |     Eigen::VectorXd rho_up_v, rho_dn_v, sigma_uu_v, sigma_ud_v, sigma_dd_v;
   290 |     split_gga_inputs_polarized(inp, rho_up_v, rho_dn_v, sigma_uu_v, sigma_ud_v, sigma_dd_v);
   291 | 
   292 |     // Flattened LibXC layout:
   293 |     //   rho[2*i+0]=rho_up, rho[2*i+1]=rho_dn
   294 |     //   sigma[3*i+0]=sigma_uu, [3*i+1]=sigma_ud, [3*i+2]=sigma_dd
   295 |     std::vector<double> rho(2*n);
   296 |     std::vector<double> sigma(3*n);
   297 |     for (int i = 0; i < n; ++i) {
   298 |         rho[2*i + 0] = std::max(0.0, rho_up_v(i));
   299 |         rho[2*i + 1] = std::max(0.0, rho_dn_v(i));
   300 |         sigma[3*i + 0] = std::max(0.0, sigma_uu_v(i));
   301 |         sigma[3*i + 1] =           sigma_ud_v(i);  // can be negative
   302 |         sigma[3*i + 2] = std::max(0.0, sigma_dd_v(i));
   303 |     }
   304 | 
   305 |     std::vector<double> exc(n, 0.0);
   306 |     std::vector<double> vrho(2*n, 0.0);
   307 |     std::vector<double> vsigma(3*n, 0.0);
   308 | 
   309 |     for (auto &func : handle.funcs) {
   310 |         std::vector<double> exc_i(n, 0.0), vrho_i(2*n, 0.0), vsigma_i(3*n, 0.0);
   311 |         xc_gga_exc_vxc(&func, n, rho.data(), sigma.data(),
   312 |                        exc_i.data(), vrho_i.data(), vsigma_i.data());
   313 |         for (int i = 0; i < n; ++i) {
   314 |             exc[i]        += exc_i[i];
   315 |             vrho[2*i+0]   += vrho_i[2*i+0];
   316 |             vrho[2*i+1]   += vrho_i[2*i+1];
   317 |             vsigma[3*i+0] += vsigma_i[3*i+0];
   318 |             vsigma[3*i+1] += vsigma_i[3*i+1];
   319 |             vsigma[3*i+2] += vsigma_i[3*i+2];
   320 |         }
   321 |     }
   322 | 
   323 |     // If caller provided gradients (8-col input), expose gradient derivatives via chain rule:
   324 |     //   dF/d(∇ρ↑) = 2*vsigma_uu*∇ρ↑ + vsigma_ud*∇ρ↓
   325 |     //   dF/d(∇ρ↓) = 2*vsigma_dd*∇ρ↓ + vsigma_ud*∇ρ↑
   326 |     if (m == 8) {
   327 |         const Eigen::VectorXd gx_u = inp.col(2), gy_u = inp.col(3), gz_u = inp.col(4);
   328 |         const Eigen::VectorXd gx_d = inp.col(5), gy_d = inp.col(6), gz_d = inp.col(7);
   329 | 
   330 |         Eigen::MatrixXd out(n, 9);
   331 |         for (int i = 0; i < n; ++i) {
   332 |             const double n_tot = rho[2*i+0] + rho[2*i+1];
   333 |             const double vuu = vsigma[3*i+0];
   334 |             const double vud = vsigma[3*i+1];
   335 |             const double vdd = vsigma[3*i+2];
   336 | 
   337 |             // dF/d(grad up)
   338 |             const double dFx_u = 2.0*vuu*gx_u(i) + vud*gx_d(i);
   339 |             const double dFy_u = 2.0*vuu*gy_u(i) + vud*gy_d(i);
   340 |             const double dFz_u = 2.0*vuu*gz_u(i) + vud*gz_d(i);
   341 |             // dF/d(grad down)
   342 |             const double dFx_d = 2.0*vdd*gx_d(i) + vud*gx_u(i);
   343 |             const double dFy_d = 2.0*vdd*gy_d(i) + vud*gy_u(i);
   344 |             const double dFz_d = 2.0*vdd*gz_d(i) + vud*gz_u(i);
   345 | 
   346 |             out(i, 0) = n_tot * exc[i];     // F
   347 |             out(i, 1) = vrho[2*i + 0];      // dF/d rho_up
   348 |             out(i, 2) = vrho[2*i + 1];      // dF/d rho_dn
   349 |             out(i, 3) = dFx_u;              // dF/d gx_up
   350 |             out(i, 4) = dFy_u;              // dF/d gy_up
   351 |             out(i, 5) = dFz_u;              // dF/d gz_up
   352 |             out(i, 6) = dFx_d;              // dF/d gx_dn
   353 |             out(i, 7) = dFy_d;              // dF/d gy_dn
   354 |             out(i, 8) = dFz_d;              // dF/d gz_dn
   355 |         }
   356 |         return out;
   357 |     }
   358 | 
   359 |     // Otherwise (5-col sigma layout): [F, dF/drho_up, dF/drho_dn, dF/dsigma_uu, dF/dsigma_ud, dF/dsigma_dd]
   360 |     Eigen::MatrixXd out(n, 6);
   361 |     for (int i = 0; i < n; ++i) {
   362 |         const double n_tot = rho[2*i+0] + rho[2*i+1];
   363 |         out(i, 0) = n_tot * exc[i];
   364 |         out(i, 1) = vrho[2*i + 0];
   365 |         out(i, 2) = vrho[2*i + 1];
   366 |         out(i, 3) = vsigma[3*i + 0];
   367 |         out(i, 4) = vsigma[3*i + 1];
   368 |         out(i, 5) = vsigma[3*i + 2];
   369 |     }
   370 |     return out;
   371 | }
   372 | 
   373 | } // namespace mrdft

=== FILE: src/mrdft/LibXCBackend.h | 2.1 KB ===
     1 | #pragma once
     2 | 
     3 | #include <vector>
     4 | #include <memory>
     5 | #include <stdexcept>
     6 | #include <Eigen/Core>
     7 | 
     8 | #include <xc.h>  // LibXC C header
     9 | 
    10 | #include "LDA.h"
    11 | #include "GGA.h"
    12 | #include "SpinLDA.h"
    13 | #include "SpinGGA.h"
    14 | 
    15 | namespace mrdft {
    16 | 
    17 | /* Minimal RAII wrapper for LibXC function handles */
    18 | class LibXCHandle {
    19 | public:
    20 |     LibXCHandle(const std::vector<int>& ids, int nspin)
    21 |         : funcs(ids.size()), nspin(nspin) {
    22 |         for (size_t k = 0; k < ids.size(); ++k) {
    23 |             if (xc_func_init(&funcs[k], ids[k], nspin) != 0) {
    24 |                 throw std::runtime_error("LibXC: could not initialize functional id=" + std::to_string(ids[k]));
    25 |             }
    26 |         }
    27 |     }
    28 |     ~LibXCHandle() {
    29 |         for (auto &f : funcs) xc_func_end(&f);
    30 |     }
    31 |     std::vector<xc_func_type> funcs;
    32 |     int nspin{XC_UNPOLARIZED};
    33 | };
    34 | 
    35 | /* -------- Unpolarized LDA -------- */
    36 | class LibXCLDA : public LDA {
    37 | public:
    38 |     LibXCLDA(int k, XC_p &f, const std::vector<int>& ids)
    39 |         : LDA(k, f), handle(ids, XC_UNPOLARIZED) {}
    40 | 
    41 |     Eigen::MatrixXd evaluate_transposed(Eigen::MatrixXd &inp) const override;
    42 | 
    43 | private:
    44 |     LibXCHandle handle;
    45 | };
    46 | 
    47 | /* -------- Unpolarized GGA -------- */
    48 | class LibXCGGA : public GGA {
    49 | public:
    50 |     LibXCGGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d, const std::vector<int>& ids)
    51 |         : GGA(k, f, d), handle(ids, XC_UNPOLARIZED) {}
    52 | 
    53 |     Eigen::MatrixXd evaluate_transposed(Eigen::MatrixXd &inp) const override;
    54 | 
    55 | private:
    56 |     LibXCHandle handle;
    57 | };
    58 | 
    59 | /* -------- Spin LDA -------- */
    60 | class LibXCSpinLDA : public SpinLDA {
    61 | public:
    62 |     LibXCSpinLDA(int k, XC_p &f, const std::vector<int>& ids)
    63 |         : SpinLDA(k, f), handle(ids, XC_POLARIZED) {}
    64 | 
    65 |     Eigen::MatrixXd evaluate_transposed(Eigen::MatrixXd &inp) const override;
    66 | 
    67 | private:
    68 |     LibXCHandle handle;
    69 | };
    70 | 
    71 | /* -------- Spin GGA -------- */
    72 | class LibXCSpinGGA : public SpinGGA {
    73 | public:
    74 |     LibXCSpinGGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d, const std::vector<int>& ids)
    75 |         : SpinGGA(k, f, d), handle(ids, XC_POLARIZED) {}
    76 | 
    77 |     Eigen::MatrixXd evaluate_transposed(Eigen::MatrixXd &inp) const override;
    78 | 
    79 | private:
    80 |     LibXCHandle handle;
    81 | };
    82 | 
    83 | } // namespace mrdft

=== FILE: src/mrdft/SpinGGA.cpp | 5.5 KB ===
     1 | /*
     2 |  * (banner unchanged)
     3 |  */
     4 | 
     5 | #include "MRCPP/MWOperators"
     6 | #include "MRCPP/Printer"
     7 | 
     8 | #include "SpinGGA.h"
     9 | #include "xc_utils.h"
    10 | 
    11 | namespace mrdft {
    12 | 
    13 | SpinGGA::SpinGGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d)
    14 |         : Functional(k, f)
    15 |         , derivative(std::move(d)) {
    16 |     xc_mask = xc_utils::build_output_mask(false, true, this->order);
    17 |     d_mask = xc_utils::build_density_mask(false, true, this->order);
    18 | }
    19 | 
    20 | /** @brief Clear internal functions
    21 |  *
    22 |  * Ownership of densities is outside MRDFT -> clear
    23 |  * Ownership of gradients is inside MRDFT -> free
    24 |  */
    25 | void SpinGGA::clear() {
    26 |     mrcpp::clear(this->rho_a, false);
    27 |     mrcpp::clear(this->rho_b, false);
    28 |     mrcpp::clear(this->grad_a, true);
    29 |     mrcpp::clear(this->grad_b, true);
    30 | }
    31 | 
    32 | /** @brief Number of function involved in contraction step */
    33 | int SpinGGA::getCtrInputLength() const {
    34 |     int length = -1;
    35 |     if (this->order < 2) length = 0;
    36 |     if (this->order == 2) length = 8;
    37 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
    38 |     return length;
    39 | }
    40 | 
    41 | /** @brief Collect input functions to xcfun evaluation step
    42 |  *
    43 |  * For SpinGGA : [alpha_0, beta_0, grad(alpha_0), grad(beta_0)]
    44 |  */
    45 | mrcpp::FunctionTreeVector<3> SpinGGA::setupXCInput() {
    46 |     if (this->rho_a.size() < 1) MSG_ERROR("Alpha density not initialized");
    47 |     if (this->rho_b.size() < 1) MSG_ERROR("Beta density not initialized");
    48 |     if (this->grad_a.size() < 3) MSG_ERROR("Alpha gradient not initialized");
    49 |     if (this->grad_b.size() < 3) MSG_ERROR("Beta gradient not initialized");
    50 | 
    51 |     mrcpp::FunctionTreeVector<3> out_vec;
    52 |     out_vec.push_back(this->rho_a[0]);
    53 |     out_vec.push_back(this->rho_b[0]);
    54 |     out_vec.insert(out_vec.end(), this->grad_a.begin(), this->grad_a.begin() + 3);
    55 |     out_vec.insert(out_vec.end(), this->grad_b.begin(), this->grad_b.begin() + 3);
    56 |     return out_vec;
    57 | }
    58 | 
    59 | /** @brief Collect input functions to contraction step
    60 |  *
    61 |  * For SpinGGA:
    62 |  * Ground State: No contraction, empty vector
    63 |  * Linear Response: [alpha_1, beta_1, grad(alpha_1), grad(beta_1)]
    64 |  * Higher Response: NOT_IMPLEMENTED
    65 |  */
    66 | mrcpp::FunctionTreeVector<3> SpinGGA::setupCtrInput() {
    67 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
    68 |     mrcpp::FunctionTreeVector<3> out_vec;
    69 |     if (this->order == 2) {
    70 |         out_vec.push_back(this->rho_a[1]);
    71 |         out_vec.push_back(this->rho_b[1]);
    72 |         out_vec.insert(out_vec.end(), this->grad_a.begin() + 3, this->grad_a.begin() + 6);
    73 |         out_vec.insert(out_vec.end(), this->grad_b.begin() + 3, this->grad_b.begin() + 6);
    74 |     }
    75 |     return out_vec;
    76 | }
    77 | 
    78 | /** @brief Prepare input functions to xcfun
    79 |  *
    80 |  * Collects input densities and computes necessary gradients.
    81 |  */
    82 | void SpinGGA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
    83 |     if (inp_vec.size() != 2 * this->order) MSG_ERROR("Invalid input length");
    84 |     if (this->rho_a.size() > 0) MSG_ERROR("Alpha density not empty");
    85 |     if (this->rho_b.size() > 0) MSG_ERROR("Beta density not empty");
    86 |     if (this->grad_a.size() > 0) MSG_ERROR("Alpha gradient not empty");
    87 |     if (this->grad_b.size() > 0) MSG_ERROR("Beta gradient not empty");
    88 | 
    89 |     int n = 0;
    90 |     for (int i = 0; i < this->order; i++) {
    91 |         this->rho_a.push_back(inp_vec[n++]);
    92 |         this->rho_b.push_back(inp_vec[n++]);
    93 |     }
    94 | 
    95 |     for (int i = 0; i < this->order; i++) {
    96 |         mrcpp::FunctionTreeVector<3> tmp_a, tmp_b;
    97 |         if (this->log_grad and i == 0) {
    98 |             tmp_a = xc_utils::log_gradient(*this->derivative, mrcpp::get_func(this->rho_a, i));
    99 |             tmp_b = xc_utils::log_gradient(*this->derivative, mrcpp::get_func(this->rho_b, i));
   100 |         } else {
   101 |             tmp_a = mrcpp::gradient(*this->derivative, mrcpp::get_func(this->rho_a, i));
   102 |             tmp_b = mrcpp::gradient(*this->derivative, mrcpp::get_func(this->rho_b, i));
   103 |         }
   104 |         this->grad_a.insert(this->grad_a.end(), tmp_a.begin(), tmp_a.end());
   105 |         this->grad_b.insert(this->grad_b.end(), tmp_b.begin(), tmp_b.end());
   106 |     }
   107 | }
   108 | 
   109 | /** @brief Compute final output functions
   110 |  *
   111 |  * For SpinGGA:
   112 |  * f_xc         : out[0] = inp[0]
   113 |  * df_xc/drho_a : out[1] = inp[1] - div(inp[3,4,5])
   114 |  * df_xc/drho_b : out[2] = inp[2] - div(inp[6,7,8])
   115 |  */
   116 | mrcpp::FunctionTreeVector<3> SpinGGA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
   117 |     // Energy density
   118 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
   119 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
   120 | 
   121 |     // Alpha part
   122 |     mrcpp::FunctionTree<3> &df_da = mrcpp::get_func(inp_vec, 1);
   123 |     mrcpp::FunctionTreeVector<3> df_dga(inp_vec.begin() + 3, inp_vec.begin() + 6);
   124 | 
   125 |     auto *tmp_a = new mrcpp::FunctionTree<3>(df_da.getMRA());
   126 |     mrcpp::divergence(*tmp_a, *this->derivative, df_dga);
   127 | 
   128 |     auto *v_a = new mrcpp::FunctionTree<3>(df_da.getMRA());
   129 |     mrcpp::build_grid(*v_a, df_da);
   130 |     mrcpp::build_grid(*v_a, *tmp_a);
   131 |     mrcpp::add(-1.0, *v_a, 1.0, df_da, -1.0, *tmp_a);
   132 |     delete tmp_a;
   133 | 
   134 |     // Beta part
   135 |     mrcpp::FunctionTree<3> &df_db = mrcpp::get_func(inp_vec, 2);
   136 |     mrcpp::FunctionTreeVector<3> df_dgb(inp_vec.begin() + 6, inp_vec.begin() + 9);
   137 | 
   138 |     auto *tmp_b = new mrcpp::FunctionTree<3>(df_db.getMRA());
   139 |     mrcpp::divergence(*tmp_b, *this->derivative, df_dgb);
   140 | 
   141 |     auto *v_b = new mrcpp::FunctionTree<3>(df_db.getMRA());
   142 |     mrcpp::build_grid(*v_b, df_db);
   143 |     mrcpp::build_grid(*v_b, *tmp_b);
   144 |     mrcpp::add(-1.0, *v_b, 1.0, df_db, -1.0, *tmp_b);
   145 |     delete tmp_b;
   146 | 
   147 |     // Collect output
   148 |     mrcpp::FunctionTreeVector<3> out_vec;
   149 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
   150 |     out_vec.push_back(std::make_tuple(1.0, v_a));
   151 |     out_vec.push_back(std::make_tuple(1.0, v_b));
   152 |     v_a = nullptr;
   153 |     v_b = nullptr;
   154 | 
   155 |     return out_vec;
   156 | }
   157 | 
   158 | } // namespace mrdft

=== FILE: src/mrdft/SpinGGA.h | 964.0 B ===
     1 | #pragma once
     2 | 
     3 | #include <XCFun/xcfun.h>
     4 | #include "Functional.h"
     5 | 
     6 | namespace mrdft {
     7 | 
     8 | class SpinGGA : public Functional {
     9 | public:
    10 |     SpinGGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d);
    11 |     ~SpinGGA() override = default;
    12 | 
    13 |     bool isSpin() const override { return true; }
    14 | 
    15 | private:
    16 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> derivative{nullptr};
    17 |     mrcpp::FunctionTreeVector<3> rho_a;
    18 |     mrcpp::FunctionTreeVector<3> rho_b;
    19 |     mrcpp::FunctionTreeVector<3> grad_a;
    20 |     mrcpp::FunctionTreeVector<3> grad_b;
    21 | 
    22 |     int getCtrInputLength() const override;
    23 |     int getCtrOutputLength() const override { return 9; }
    24 | 
    25 |     void clear() override;
    26 |     mrcpp::FunctionTreeVector<3> setupXCInput() override;
    27 |     mrcpp::FunctionTreeVector<3> setupCtrInput() override;
    28 | 
    29 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
    30 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
    31 | };
    32 | 
    33 | } // namespace mrdft

=== FILE: src/mrdft/SpinLDA.cpp | 3.3 KB ===
     1 | /*
     2 |  * (banner unchanged)
     3 |  */
     4 | 
     5 | #include "MRCPP/MWFunctions"
     6 | #include "MRCPP/Printer"
     7 | 
     8 | #include "SpinLDA.h"
     9 | #include "xc_utils.h"
    10 | 
    11 | namespace mrdft {
    12 | 
    13 | SpinLDA::SpinLDA(int k, XC_p &f)
    14 |         : Functional(k, f) {
    15 |     xc_mask = xc_utils::build_output_mask(true, true, this->order);
    16 |     d_mask = xc_utils::build_density_mask(true, true, this->order);
    17 | }
    18 | 
    19 | /** @brief Clear internal functions
    20 |  *
    21 |  * Ownership of densities is outside MRDFT -> clear
    22 |  * Ownership of gradients is inside MRDFT -> free
    23 |  */
    24 | void SpinLDA::clear() {
    25 |     mrcpp::clear(this->rho_a, false);
    26 |     mrcpp::clear(this->rho_b, false);
    27 | }
    28 | 
    29 | /** @brief Number of function involved in contraction step */
    30 | int SpinLDA::getCtrInputLength() const {
    31 |     int length = -1;
    32 |     if (this->order < 2) length = 0;
    33 |     if (this->order == 2) length = 2;
    34 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
    35 |     return length;
    36 | }
    37 | 
    38 | /** @brief Collect input functions to xcfun evaluation step
    39 |  *
    40 |  * For SpinLDA : [alpha_0, beta_0]
    41 |  */
    42 | mrcpp::FunctionTreeVector<3> SpinLDA::setupXCInput() {
    43 |     if (this->rho_a.size() < 1) MSG_ERROR("Alpha density not initialized");
    44 |     if (this->rho_b.size() < 1) MSG_ERROR("Beta density not initialized");
    45 | 
    46 |     mrcpp::FunctionTreeVector<3> out_vec;
    47 |     out_vec.push_back(this->rho_a[0]);
    48 |     out_vec.push_back(this->rho_b[0]);
    49 |     return out_vec;
    50 | }
    51 | 
    52 | /** @brief Collect input functions to contraction step
    53 |  *
    54 |  * For SpinLDA:
    55 |  * Ground State: No contraction, empty vector
    56 |  * Linear Response: [alpha_1, beta_1]
    57 |  * Higher Response: NOT_IMPLEMENTED
    58 |  */
    59 | mrcpp::FunctionTreeVector<3> SpinLDA::setupCtrInput() {
    60 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
    61 |     mrcpp::FunctionTreeVector<3> out_vec;
    62 |     if (order == 2) {
    63 |         out_vec.push_back(this->rho_a[1]);
    64 |         out_vec.push_back(this->rho_b[1]);
    65 |     }
    66 |     return out_vec;
    67 | }
    68 | 
    69 | /** @brief Prepare input functions to xcfun
    70 |  *
    71 |  * Collects input densities and computes necessary gradients.
    72 |  */
    73 | void SpinLDA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
    74 |     if (inp_vec.size() != 2 * this->order) MSG_ERROR("Invalid input length");
    75 |     if (this->rho_a.size() > 0) MSG_ERROR("Alpha density not empty");
    76 |     if (this->rho_b.size() > 0) MSG_ERROR("Beta density not empty");
    77 | 
    78 |     int n = 0;
    79 |     for (int i = 0; i < this->order; i++) {
    80 |         this->rho_a.push_back(inp_vec[n++]);
    81 |         this->rho_b.push_back(inp_vec[n++]);
    82 |     }
    83 | }
    84 | 
    85 | /** @brief Compute final output functions
    86 |  *
    87 |  * For SpinLDA:
    88 |  * f_xc         : out[0] = inp[0]
    89 |  * df_xc/drho_a : out[1] = inp[1]
    90 |  * df_xc/drho_b : out[2] = inp[2]
    91 |  */
    92 | mrcpp::FunctionTreeVector<3> SpinLDA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
    93 |     // Energy density
    94 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
    95 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
    96 | 
    97 |     // Alpha potential
    98 |     mrcpp::FunctionTree<3> &v_a = mrcpp::get_func(inp_vec, 1);
    99 |     inp_vec[1] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
   100 | 
   101 |     // Beta potential
   102 |     mrcpp::FunctionTree<3> &v_b = mrcpp::get_func(inp_vec, 2);
   103 |     inp_vec[2] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
   104 | 
   105 |     // Collect output
   106 |     mrcpp::FunctionTreeVector<3> out_vec;
   107 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
   108 |     out_vec.push_back(std::make_tuple(1.0, &v_a));
   109 |     out_vec.push_back(std::make_tuple(1.0, &v_b));
   110 |     return out_vec;
   111 | }
   112 | } // namespace mrdft

=== FILE: src/mrdft/SpinLDA.h | 761.0 B ===
     1 | #pragma once
     2 | 
     3 | #include <XCFun/xcfun.h>
     4 | #include "Functional.h"
     5 | 
     6 | namespace mrdft {
     7 | 
     8 | class SpinLDA : public Functional {
     9 | public:
    10 |     SpinLDA(int k, XC_p &f);
    11 |     ~SpinLDA() override = default;
    12 | 
    13 |     bool isSpin() const override { return true; }
    14 | 
    15 | private:
    16 |     mrcpp::FunctionTreeVector<3> rho_a;
    17 |     mrcpp::FunctionTreeVector<3> rho_b;
    18 | 
    19 |     int getCtrInputLength() const override;
    20 |     int getCtrOutputLength() const override { return 3; }
    21 | 
    22 |     void clear() override;
    23 |     mrcpp::FunctionTreeVector<3> setupXCInput() override;
    24 |     mrcpp::FunctionTreeVector<3> setupCtrInput() override;
    25 | 
    26 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
    27 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
    28 | };
    29 | 
    30 | } // namespace mrdft

=== FILE: src/mrdft/xc_backend.h | 1.1 KB ===
     1 | #pragma once
     2 | 
     3 | #include <Eigen/Core>
     4 | #include <memory>
     5 | #include <string>
     6 | 
     7 | namespace mrdft {
     8 | 
     9 | class XCBackend {
    10 | public:
    11 |     virtual ~XCBackend() = default;
    12 | 
    13 |     // Configure functional & coefficient (same semantics as xcfun_set)
    14 |     virtual void set_functional(const std::string &name, double coeff) = 0;
    15 | 
    16 |     // Configure evaluation layout (order, spin, gamma vs explicit)
    17 |     virtual void configure(int order, bool spin, bool use_gamma) = 0;
    18 | 
    19 |     // Introspection
    20 |     virtual bool  is_gga() const = 0;
    21 |     virtual bool  is_metagga() const = 0;
    22 |     virtual double amount_exx() const = 0;
    23 |     virtual int   input_length() const = 0;
    24 |     virtual int   output_length() const = 0;
    25 | 
    26 |     // Evaluate at many grid points. Each ROW is one grid point.
    27 |     // Returns (nPts x nOut). Applies cutoff identical to old code.
    28 |     virtual Eigen::MatrixXd eval_transposed(const Eigen::MatrixXd &inp,
    29 |                                             double cutoff,
    30 |                                             bool is_spin_sep) const = 0;
    31 | };
    32 | 
    33 | using XCBackend_p = std::shared_ptr<XCBackend>;
    34 | 
    35 | // Stage 1 backend: wraps XCFun
    36 | XCBackend_p make_xcfun_backend();
    37 | 
    38 | } // namespace mrdft

=== FILE: src/mrdft/xc_backend_xcfun.cpp | 3.0 KB ===
     1 | #include "xc_backend.h"
     2 | 
     3 | #include <XCFun/xcfun.h>
     4 | #include <memory>
     5 | #include <stdexcept>
     6 | #include <utility>
     7 | 
     8 | namespace mrdft {
     9 | 
    10 | namespace {
    11 | struct XCFunDeleter {
    12 |     void operator()(xcfun_t *p) const { if (p) xcfun_delete(p); }
    13 | };
    14 | } // namespace
    15 | 
    16 | class XCFunBackend final : public XCBackend {
    17 | public:
    18 |     XCFunBackend()
    19 |         : xcfun_(xcfun_new(), XCFunDeleter{}) {}
    20 | 
    21 |     void set_functional(const std::string &name, double coeff) override {
    22 |         xcfun_set(xcfun_.get(), name.c_str(), coeff);
    23 |     }
    24 | 
    25 |     void configure(int order, bool spin, bool use_gamma) override {
    26 |         order_ = order;
    27 |         spin_  = spin;
    28 | 
    29 |         const bool gga = xcfun_is_gga(xcfun_.get());
    30 |         unsigned int mode         = 1;                 // partial derivatives
    31 |         unsigned int func_type    = gga ? 1u : 0u;     // 0=LDA, 1=GGA
    32 |         unsigned int dens_type    = static_cast<unsigned>(1 + (spin ? 1 : 0)); // 1 or 2
    33 |         unsigned int laplacian    = 0;
    34 |         unsigned int kinetic      = 0;
    35 |         unsigned int current      = 0;
    36 |         unsigned int exp_deriv    = static_cast<unsigned>(!use_gamma);
    37 |         if (!gga) exp_deriv = 0; // fall back to gamma-type for LDA
    38 | 
    39 |         xcfun_user_eval_setup(xcfun_.get(), order_, func_type, dens_type,
    40 |                               mode, laplacian, kinetic, current, exp_deriv);
    41 |     }
    42 | 
    43 |     bool is_gga() const override     { return xcfun_is_gga(xcfun_.get()); }
    44 |     bool is_metagga() const override { return xcfun_is_metagga(xcfun_.get()); }
    45 | 
    46 |     double amount_exx() const override {
    47 |         double exx = 0.0;
    48 |         xcfun_get(xcfun_.get(), "exx", &exx);
    49 |         return exx;
    50 |     }
    51 | 
    52 |     int input_length()  const override { return xcfun_input_length(xcfun_.get()); }
    53 |     int output_length() const override { return xcfun_output_length(xcfun_.get()); }
    54 | 
    55 |     Eigen::MatrixXd eval_transposed(const Eigen::MatrixXd &inp,
    56 |                                     double cutoff,
    57 |                                     bool is_spin_sep) const override {
    58 |         const int nInp = input_length();
    59 |         const int nOut = output_length();
    60 |         const int nPts = static_cast<int>(inp.rows());
    61 |         if (inp.cols() != nInp) throw std::runtime_error("XCFunBackend: invalid input shape");
    62 | 
    63 |         Eigen::MatrixXd out(nPts, nOut);
    64 |         out.setZero();
    65 | 
    66 |         Eigen::VectorXd in_row(nInp);
    67 |         Eigen::VectorXd out_row(nOut);
    68 |         for (int i = 0; i < nPts; ++i) {
    69 |             bool calc = true;
    70 |             if (is_spin_sep) {
    71 |                 if (inp(i, 0) < cutoff && inp(i, 1) < cutoff) calc = false;
    72 |             } else {
    73 |                 if (inp(i, 0) < cutoff) calc = false;
    74 |             }
    75 |             for (int j = 0; j < nInp; ++j) in_row(j) = inp(i, j);
    76 |             if (calc) xcfun_eval(xcfun_.get(), in_row.data(), out_row.data());
    77 |             for (int j = 0; j < nOut; ++j) out(i, j) = out_row(j);
    78 |         }
    79 |         return out;
    80 |     }
    81 | 
    82 | private:
    83 |     std::unique_ptr<xcfun_t, XCFunDeleter> xcfun_;
    84 |     int  order_ = 1;
    85 |     bool spin_  = false;
    86 | };
    87 | 
    88 | XCBackend_p make_xcfun_backend() {
    89 |     return std::make_shared<XCFunBackend>();
    90 | }
    91 | 
    92 | } // namespace mrdft

=== FILE: src/mrdft/xc_utils.h | 1.7 KB ===
     1 | /*
     2 |  * MRChem, a numerical real-space code for molecular electronic structure
     3 |  * calculations within the self-consistent field (SCF) approximations of quantum
     4 |  * chemistry (Hartree-Fock and Density Functional Theory).
     5 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
     6 |  *
     7 |  * This file is part of MRChem.
     8 |  *
     9 |  * MRChem is free software: you can redistribute it and/or modify
    10 |  * it under the terms of the GNU Lesser General Public License as published by
    11 |  * the Free Software Foundation, either version 3 of the License, or
    12 |  * (at your option) any later version.
    13 |  *
    14 |  * MRChem is distributed in the hope that it will be useful,
    15 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
    16 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17 |  * GNU Lesser General Public License for more details.
    18 |  *
    19 |  * You should have received a copy of the GNU Lesser General Public License
    20 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
    21 |  *
    22 |  * For information on the complete list of contributors to MRChem, see:
    23 |  * <https://mrchem.readthedocs.io/>
    24 |  */
    25 | 
    26 | #include <Eigen/Core>
    27 | #include <MRCPP/MWFunctions>
    28 | 
    29 | namespace mrdft {
    30 | namespace xc_utils {
    31 | 
    32 | Eigen::MatrixXi build_output_mask(bool is_lda, bool is_spin_sep, int order);
    33 | Eigen::VectorXi build_density_mask(bool is_lda, bool is_spin_sep, int order);
    34 | 
    35 | std::vector<mrcpp::FunctionNode<3> *> fetch_nodes(int n, mrcpp::FunctionTreeVector<3> &inp);
    36 | Eigen::MatrixXd compress_nodes(std::vector<mrcpp::FunctionNode<3> *> &inp_nodes);
    37 | void expand_nodes(std::vector<mrcpp::FunctionNode<3> *> &out_nodes, Eigen::MatrixXd &out_data);
    38 | 
    39 | mrcpp::FunctionTreeVector<3> log_gradient(mrcpp::DerivativeOperator<3> &diff_oper, mrcpp::FunctionTree<3> &rho);
    40 | 
    41 | } // namespace xc_utils
    42 | } // namespace mrdft

=== FILE: src/mrenv.cpp | 13.7 KB ===
     1 | /*
     2 |  * MRChem, a numerical real-space code for molecular electronic structure
     3 |  * calculations within the self-consistent field (SCF) approximations of quantum
     4 |  * chemistry (Hartree-Fock and Density Functional Theory).
     5 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
     6 |  *
     7 |  * This file is part of MRChem.
     8 |  *
     9 |  * MRChem is free software: you can redistribute it and/or modify
    10 |  * it under the terms of the GNU Lesser General Public License as published by
    11 |  * the Free Software Foundation, either version 3 of the License, or
    12 |  * (at your option) any later version.
    13 |  *
    14 |  * MRChem is distributed in the hope that it will be useful,
    15 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
    16 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    17 |  * GNU Lesser General Public License for more details.
    18 |  *
    19 |  * You should have received a copy of the GNU Lesser General Public License
    20 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
    21 |  *
    22 |  * For information on the complete list of contributors to MRChem, see:
    23 |  * <https://mrchem.readthedocs.io/>
    24 |  */
    25 | 
    26 | #include <MRCPP/Printer>
    27 | #include <XCFun/xcfun.h>
    28 | #include <fstream>
    29 | #include <iostream>
    30 | #include "MRCPP/utils/parallel.h"
    31 | 
    32 | #include "mrchem.h"
    33 | #include "mrenv.h"
    34 | #include "utils/print_utils.h"
    35 | #include "utils/json_utils.h"   // robust, tolerant JSON helpers
    36 | #include "version.h"
    37 | 
    38 | using json    = nlohmann::json;
    39 | using Printer = mrcpp::Printer;
    40 | 
    41 | namespace mrchem {
    42 | 
    43 | namespace mrenv {
    44 | void init_printer(const json &json_print);
    45 | void init_mra(const json &json_mra);
    46 | void init_mpi(const json &json_mpi);
    47 | void print_header();
    48 | } // namespace mrenv
    49 | 
    50 | // -----------------------------------------------------------------------------
    51 | // Read the program JSON and return the normalized "input" subtree
    52 | // -----------------------------------------------------------------------------
    53 | json mrenv::fetch_json(int argc, char **argv) {
    54 |     const char *infile = nullptr;
    55 |     if (argc == 1) {
    56 |         infile = "STDIN";
    57 |     } else if (argc == 2) {
    58 |         infile = argv[1];
    59 |     } else {
    60 |         MSG_ERROR("Invalid number of arguments! Pass either no argument (read from stdin) or a single JSON file.");
    61 |     }
    62 | 
    63 |     json root;
    64 |     if (std::string(infile) == "STDIN") {
    65 |         std::cin >> root;
    66 |     } else {
    67 |         std::ifstream ifs(infile, std::ios_base::in);
    68 |         if (!ifs) MSG_ABORT("Could not open input file: " << infile);
    69 |         ifs >> root;
    70 |         ifs.close();
    71 |     }
    72 | 
    73 |     if (!root.contains("input") || !root["input"].is_object()) {
    74 |         MSG_ABORT(
    75 |             "Malformed program JSON: missing object \"input\".\n"
    76 |             "Note: mrchem.x expects the generated program JSON (with \"input\" and \"output\" sections),\n"
    77 |             "not the user .inp/.json you write by hand. Use `mrchem --dryrun <name>` or\n"
    78 |             "`mrchem --json --stdout <name> > <name>.json` to generate the program JSON."
    79 |         );
    80 |     }
    81 | 
    82 |     // Work on a copy of the "input" subtree and normalize boolean-ish fields (0/1, on/off, etc.)
    83 |     json j = root["input"];
    84 |     mrchem::json_utils::sanitize_booleans(j);
    85 |     return j;
    86 | }
    87 | 
    88 | // -----------------------------------------------------------------------------
    89 | // Initialization (printer, MRA, MPI) with tolerant JSON reads
    90 | // -----------------------------------------------------------------------------
    91 | void mrenv::initialize(const json &json_inp) {
    92 |     auto json_print = json_inp.find("printer");
    93 |     auto json_mra   = json_inp.find("mra");
    94 |     auto json_mpi   = json_inp.find("mpi");
    95 | 
    96 |     if (json_mra == json_inp.end() || !json_mra->is_object()) {
    97 |         MSG_ABORT("Missing MRA input! The \"input\" JSON must contain an \"mra\" object.");
    98 |     } else {
    99 |         mrenv::init_mra(*json_mra);
   100 |     }
   101 |     if (json_mpi   != json_inp.end() && json_mpi->is_object())   mrenv::init_mpi(*json_mpi);
   102 |     if (json_print != json_inp.end() && json_print->is_object()) mrenv::init_printer(*json_print);
   103 | 
   104 |     mrenv::print_header();
   105 | }
   106 | 
   107 | void mrenv::init_printer(const json &json_print) {
   108 |     // Safe, typed reads with defaults
   109 |     int  print_level = json_utils::value_loose<int>(json_print,  "print_level", 1);
   110 |     int  print_prec  = json_utils::value_loose<int>(json_print,  "print_prec",  10);
   111 |     int  print_width = json_utils::value_loose<int>(json_print,  "print_width", 120);
   112 |     bool print_mpi   = json_utils::value_loose<bool>(json_print, "print_mpi",   false);
   113 | 
   114 |     std::string fname = "mrchem.out";
   115 |     if (json_print.contains("file_name") && json_print["file_name"].is_string()) {
   116 |         fname = json_print["file_name"].get<std::string>();
   117 |     }
   118 | 
   119 |     if (print_mpi) {
   120 |         Printer::init(print_level, mrcpp::mpi::world_rank, mrcpp::mpi::world_size, fname.c_str());
   121 |     } else {
   122 |         Printer::init(print_level, mrcpp::mpi::world_rank, mrcpp::mpi::world_size);
   123 |     }
   124 |     Printer::setPrecision(print_prec);
   125 |     Printer::setWidth(print_width);
   126 | }
   127 | 
   128 | void mrenv::init_mra(const json &json_mra) {
   129 |     // Required fields: enforce exact types here (schema-generated JSON should be correct)
   130 |     int min_scale = json_mra.at("min_scale").get<int>();
   131 |     int max_scale = json_mra.at("max_scale").get<int>();
   132 |     auto corner   = json_mra.at("corner");
   133 |     auto boxes    = json_mra.at("boxes");
   134 |     mrcpp::BoundingBox<3> world(min_scale, corner, boxes);
   135 | 
   136 |     int         order = json_mra.at("basis_order").get<int>();
   137 |     std::string btype = json_mra.at("basis_type").get<std::string>();
   138 | 
   139 |     auto max_depth = max_scale - min_scale;
   140 |     if (min_scale < mrcpp::MinScale) MSG_ABORT("Root scale too large");
   141 |     if (max_scale > mrcpp::MaxScale) MSG_ABORT("Max scale too large");
   142 |     if (max_depth > mrcpp::MaxDepth) MSG_ABORT("Max depth too large");
   143 | 
   144 |     if (btype == "interpolating") {
   145 |         mrcpp::InterpolatingBasis basis(order);
   146 |         MRA = new mrcpp::MultiResolutionAnalysis<3>(world, basis, max_depth);
   147 |     } else if (btype == "legendre") {
   148 |         mrcpp::LegendreBasis basis(order);
   149 |         MRA = new mrcpp::MultiResolutionAnalysis<3>(world, basis, max_depth);
   150 |     } else {
   151 |         MSG_ABORT("Invalid basis type!");
   152 |     }
   153 |     mrcpp::cplxfunc::SetdefaultMRA(MRA);
   154 | }
   155 | 
   156 | void mrenv::init_mpi(const json &json_mpi) {
   157 |     // Tolerant reads to avoid type_error.302 for 0/1, "true"/"false", etc.
   158 |     mrcpp::mpi::numerically_exact = json_utils::value_loose<bool>(json_mpi, "numerically_exact", false);
   159 |     mrcpp::mpi::shared_memory_size = json_utils::value_loose<int>( json_mpi, "shared_memory_size", 0);
   160 |     mrcpp::mpi::bank_size          = json_utils::value_loose<int>( json_mpi, "bank_size",          0);
   161 |     mrcpp::mpi::omp_threads        = json_utils::value_loose<int>( json_mpi, "omp_threads",        1);
   162 | 
   163 |     // Must be after bank_size and before init_printer/print_header
   164 |     mrcpp::mpi::initialize();
   165 | }
   166 | 
   167 | // -----------------------------------------------------------------------------
   168 | // Pretty header
   169 | // -----------------------------------------------------------------------------
   170 | void mrenv::print_header() {
   171 |     auto pwidth      = Printer::getWidth();
   172 |     auto txt_width   = 50;
   173 |     auto pre_spaces  = (pwidth - 6 - txt_width) / 2;
   174 |     auto post_spaces = pwidth - 6 - txt_width - pre_spaces;
   175 |     std::string pre_str  = std::string(3, '*') + std::string(pre_spaces, ' ');
   176 |     std::string post_str = std::string(post_spaces, ' ') + std::string(3, '*');
   177 |     std::stringstream o_ver, o_branch, o_hash, o_author, o_date;
   178 |     o_ver    << "VERSION            " << program_version();
   179 |     o_branch << "Git branch         " << git_branch();
   180 |     o_hash   << "Git commit hash    " << git_commit_hash();
   181 |     o_author << "Git commit author  " << git_commit_author();
   182 |     o_date   << "Git commit date    " << git_commit_date();
   183 | 
   184 |     int ver_len    = static_cast<int>(o_ver.str().size());
   185 |     int branch_len = static_cast<int>(o_branch.str().size());
   186 |     int hash_len   = static_cast<int>(o_hash.str().size());
   187 |     int auth_len   = static_cast<int>(o_author.str().size());
   188 |     int date_len   = static_cast<int>(o_date.str().size());
   189 | 
   190 |     o_ver    << std::string(std::max(0, txt_width - ver_len),    ' ');
   191 |     o_branch << std::string(std::max(0, txt_width - branch_len), ' ');
   192 |     o_hash   << std::string(std::max(0, txt_width - hash_len),   ' ');
   193 |     o_author << std::string(std::max(0, txt_width - auth_len),   ' ');
   194 |     o_date   << std::string(std::max(0, txt_width - date_len),   ' ');
   195 | 
   196 |     std::stringstream o_bank;
   197 |     if (mrcpp::mpi::bank_size > 0) {
   198 |         o_bank << "(" << mrcpp::mpi::tot_bank_size << " bank)";
   199 |     } else {
   200 |         o_bank << "(no bank)";
   201 |     }
   202 | 
   203 |     mrcpp::print::separator(0, ' ');
   204 |     mrcpp::print::separator(0, ' ');
   205 |     mrcpp::print::separator(0, '*');
   206 |     println(0, pre_str << "                                                  " << post_str);
   207 |     println(0, pre_str << "                                                  " << post_str);
   208 |     println(0, pre_str << " __  __ ____   ____ _                             " << post_str);
   209 |     println(0, pre_str << "|  \\/  |  _ \\ / ___| |__   ___ _ __ ___           " << post_str);
   210 |     println(0, pre_str << "| |\\/| | |_) | |   | '_ \\ / _ \\ '_ ` _ \\          " << post_str);
   211 |     println(0, pre_str << "| |  | |  _ <| |___| | | |  __/ | | | | |         " << post_str);
   212 |     println(0, pre_str << "|_|  |_|_| \\_\\\\____|_| |_|\\___|_| |_| |_|         " << post_str);
   213 |     println(0, pre_str << "                                                  " << post_str);
   214 |     println(0, pre_str << o_ver.str() << post_str);
   215 |     println(0, pre_str << "                                                  " << post_str);
   216 |     println(0, pre_str << o_branch.str() << post_str);
   217 |     println(0, pre_str << o_hash.str() << post_str);
   218 |     println(0, pre_str << o_author.str() << post_str);
   219 |     println(0, pre_str << o_date.str() << post_str);
   220 |     println(0, pre_str << "                                                  " << post_str);
   221 |     println(0, pre_str << "Contact: luca.frediani@uit.no                     " << post_str);
   222 |     println(0, pre_str << "                                                  " << post_str);
   223 |     println(0, pre_str << "Radovan Bast            Magnar Bjorgve            " << post_str);
   224 |     println(0, pre_str << "Roberto Di Remigio      Antoine Durdek            " << post_str);
   225 |     println(0, pre_str << "Luca Frediani           Gabriel Gerez             " << post_str);
   226 |     println(0, pre_str << "Stig Rune Jensen        Jonas Juselius            " << post_str);
   227 |     println(0, pre_str << "Rune Monstad            Peter Wind                " << post_str);
   228 |     println(0, pre_str << "                                                  " << post_str);
   229 |     mrcpp::print::separator(0, '*', 1);
   230 |     mrcpp::print::separator(0, '-', 1);
   231 |     print_utils::scalar(0, "MPI processes  ", mrcpp::mpi::world_size, o_bank.str(), 0, false);
   232 |     print_utils::scalar(0, "OpenMP threads ", mrcpp::omp::n_threads, "", 0, false);
   233 |     print_utils::scalar(0, "Total cores    ",
   234 |                         (mrcpp::mpi::world_size - mrcpp::mpi::tot_bank_size) * mrcpp::omp::n_threads
   235 |                         + mrcpp::mpi::tot_bank_size, "", 0, false);
   236 |     mrcpp::print::separator(0, ' ');
   237 |     mrcpp::print::separator(0, '-', 1);
   238 |     printout(0, xcfun_splash());
   239 |     mrcpp::print::environment(0);
   240 |     MRA->print();
   241 | }
   242 | 
   243 | void mrenv::finalize(double wt) {
   244 |     if (MRA != nullptr) delete MRA;
   245 |     MRA = nullptr;
   246 | 
   247 |     auto pwidth      = Printer::getWidth();
   248 |     auto txt_width   = 45;
   249 |     auto pre_spaces  = (pwidth - 6 - txt_width) / 2;
   250 |     auto post_spaces = pwidth - 6 - txt_width - pre_spaces;
   251 |     std::string pre_str  = std::string(3, '*') + std::string(pre_spaces, ' ');
   252 |     std::string post_str = std::string(post_spaces, ' ') + std::string(3, '*');
   253 | 
   254 |     auto hr  = static_cast<int>(wt / 3600.0);
   255 |     auto min = static_cast<int>(std::fmod(wt, 3600.0) / 60.0);
   256 |     auto sec = static_cast<int>(std::fmod(wt, 60.0));
   257 | 
   258 |     std::stringstream o_time;
   259 |     o_time << "Wall time : " << std::setw(2) << hr << "h" << std::setw(3) << min << "m" << std::setw(3) << sec << "s";
   260 | 
   261 |     mrcpp::print::separator(0, ' ');
   262 |     mrcpp::print::separator(0, ' ');
   263 |     mrcpp::print::separator(0, '*');
   264 |     println(0, pre_str << "                                             " << post_str);
   265 |     println(0, pre_str << "                Exiting MRChem               " << post_str);
   266 |     println(0, pre_str << "                                             " << post_str);
   267 |     println(0, pre_str << "           " << o_time.str() << "           " << post_str);
   268 |     println(0, pre_str << "                                             " << post_str);
   269 |     mrcpp::print::separator(0, '*');
   270 |     mrcpp::print::separator(0, ' ');
   271 |     mrcpp::print::separator(0, ' ');
   272 | }
   273 | 
   274 | void mrenv::dump_json(const json &json_inp, const json &json_out) {
   275 |     json json_tot;
   276 |     json_tot["input"]  = json_inp;
   277 |     json_tot["output"] = json_out;
   278 | 
   279 |     // Try to derive a base name from printer.file_name; fallback to "mrchem"
   280 |     std::string base = "mrchem";
   281 |     try {
   282 |         if (json_inp.contains("printer") && json_inp["printer"].contains("file_name")) {
   283 |             base = detail::remove_extension(json_inp["printer"]["file_name"].get<std::string>());
   284 |         }
   285 |     } catch (...) {
   286 |         /* keep default */
   287 |     }
   288 | 
   289 |     if (mrcpp::mpi::grand_master()) {
   290 |         std::ofstream ofs(base + ".json", std::ios::out);
   291 |         ofs << json_tot.dump(2) << std::endl;
   292 |         ofs.close();
   293 |     }
   294 | }
   295 | 
   296 | // -----------------------------------------------------------------------------
   297 | // small helpers
   298 | // -----------------------------------------------------------------------------
   299 | std::string detail::remove_extension(const std::string &fname) {
   300 |     size_t lastdot = fname.find_last_of(".");
   301 |     if (lastdot == std::string::npos) return fname;
   302 |     return fname.substr(0, lastdot);
   303 | }
   304 | 
   305 | bool detail::all_success(const json &json_out) {
   306 |     auto scf_success = json_out["scf_calculation"]["success"].get<bool>();
   307 |     auto rsp_success = true;
   308 |     for (const auto &x : json_out["rsp_calculations"]) { rsp_success &= x["success"].get<bool>(); }
   309 |     return scf_success & rsp_success;
   310 | }
   311 | 
   312 | } // namespace mrchem

=== FILE: src/utils/json_utils.h | 5.1 KB ===
     1 | #pragma once
     2 | #include <nlohmann/json.hpp>
     3 | #include <string>
     4 | #include <algorithm>
     5 | #include <type_traits>
     6 | #include <cctype>
     7 | #include <unordered_set>
     8 | 
     9 | namespace mrchem::json_utils {
    10 | 
    11 | using json = nlohmann::json;
    12 | 
    13 | // Strict-but-tolerant conversion to bool.
    14 | // Accepts true/false, 0/1, and strings like "on/off", "yes/no".
    15 | inline bool to_bool(const nlohmann::json& j, bool def = false) {
    16 |     if (j.is_boolean()) return j.get<bool>();
    17 |     if (j.is_number_integer()) return j.get<int>() != 0;
    18 |     if (j.is_number_float())   return j.get<double>() != 0.0;
    19 |     if (j.is_string()) {
    20 |         std::string s = j.get<std::string>();
    21 |         std::transform(s.begin(), s.end(), s.begin(),
    22 |                        [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
    23 |         if (s == "true"  || s == "1" || s == "yes" || s == "on")  return true;
    24 |         if (s == "false" || s == "0" || s == "no"  || s == "off") return false;
    25 |         return def;
    26 |     }
    27 |     return def;
    28 | }
    29 | 
    30 | // Safely fetch a value of type T. For bool, uses to_bool.
    31 | // For numbers/strings, only returns if JSON type matches; else returns default.
    32 | template <class T>
    33 | inline T value_loose(const nlohmann::json& jparent, const char* key, const T& def) {
    34 |     if (!jparent.contains(key)) return def;
    35 |     const auto& j = jparent.at(key);
    36 |     if constexpr (std::is_same_v<T,bool>) {
    37 |         return to_bool(j, def);
    38 |     } else if constexpr (std::is_integral_v<T>) {
    39 |         if (j.is_number_integer()) return j.get<T>();
    40 |     } else if constexpr (std::is_floating_point_v<T>) {
    41 |         if (j.is_number()) return j.get<T>();
    42 |     } else if constexpr (std::is_same_v<T,std::string>) {
    43 |         if (j.is_string()) return j.get<std::string>();
    44 |     } else {
    45 |         try { return j.get<T>(); } catch (...) { /* fallthrough */ }
    46 |     }
    47 |     return def;
    48 | }
    49 | 
    50 | // ---------- New: input sanitizer to normalize booleans in the whole tree ----------
    51 | 
    52 | inline bool looks_like_bool_key(const std::string& k) {
    53 |     // common flags across the codebase
    54 |     static const std::unordered_set<std::string> whitelist = {
    55 |         "print_mpi","numerically_exact","restricted","localize","rotate","checkpoint",
    56 |         "dynamic","shared_memory","include_nuclear","include_coulomb","include_xc",
    57 |         "isAZORA","spin","nonequilibrium","density","unrestricted","debug","verbose",
    58 |         "timings","write_orbitals","plots","plot_density","plot_orbitals","enable",
    59 |         "disable","use_gpu","use_mpi","use_omp"
    60 |     };
    61 | 
    62 |     if (whitelist.count(k)) return true;
    63 |     // Heuristics by prefix/suffix
    64 |     auto starts_with = [&](const char* p){
    65 |         return k.rfind(p, 0) == 0;
    66 |     };
    67 |     auto ends_with = [&](const char* sfx){
    68 |         return k.size() >= std::char_traits<char>::length(sfx)
    69 |             && k.compare(k.size()-std::char_traits<char>::length(sfx),
    70 |                          std::char_traits<char>::length(sfx), sfx) == 0;
    71 |     };
    72 | 
    73 |     return starts_with("is_") || starts_with("has_") || starts_with("use_")
    74 |         || starts_with("enable_") || starts_with("disable_") || starts_with("do_")
    75 |         || starts_with("with_") || starts_with("print_") || starts_with("plot_")
    76 |         || ends_with("_enabled") || ends_with("_disabled");
    77 | }
    78 | 
    79 | // Recursively coerce 0/1 and on/off-like strings to booleans for "boolean-ish" keys.
    80 | inline void sanitize_booleans(nlohmann::json& j) {
    81 |     if (j.is_object()) {
    82 |         for (auto it = j.begin(); it != j.end(); ++it) {
    83 |             const std::string key = it.key();
    84 |             auto& val = it.value();
    85 |             // Recurse first
    86 |             if (val.is_object() || val.is_array()) sanitize_booleans(val);
    87 | 
    88 |             if (looks_like_bool_key(key)) {
    89 |                 if (!val.is_boolean()) {
    90 |                     // Only coerce if convertible; otherwise leave as-is
    91 |                     bool coerced = to_bool(val, /*def*/false);
    92 |                     // If val was non-convertible string (e.g., "maybe"), keep old value
    93 |                     if (val.is_boolean() || val.is_number() || val.is_string()) {
    94 |                         // Special case: avoid mis-coercing numbers not 0/1
    95 |                         if (val.is_number_integer()) {
    96 |                             int n = val.get<int>();
    97 |                             if (n == 0 || n == 1) { val = coerced; }
    98 |                         } else if (val.is_number_float()) {
    99 |                             double x = val.get<double>();
   100 |                             if (x == 0.0 || x == 1.0) { val = coerced; }
   101 |                         } else if (val.is_string()) {
   102 |                             // Strings like "on"/"off"/"yes"/"no"/"true"/"false"/"0"/"1"
   103 |                             std::string s = val.get<std::string>();
   104 |                             std::string sl = s;
   105 |                             std::transform(sl.begin(), sl.end(), sl.begin(),
   106 |                                            [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
   107 |                             if (sl=="true"||sl=="false"||sl=="on"||sl=="off"||sl=="yes"||sl=="no"||sl=="0"||sl=="1") {
   108 |                                 val = coerced;
   109 |                             }
   110 |                         }
   111 |                     }
   112 |                 }
   113 |             }
   114 |         }
   115 |     } else if (j.is_array()) {
   116 |         for (auto& x : j) sanitize_booleans(x);
   117 |     }
   118 | }
   119 | 
   120 | } // namespace mrchem::json_utils

=== FILE: tests/hf_grad_blyp_surface_force/reference/hf.json | 7.9 KB ===
     1 | {
     2 |   "input": {
     3 |     "constants": {
     4 |       "N_a": 6.02214076e+23,
     5 |       "angstrom2bohrs": 1.8897261246257702,
     6 |       "boltzmann_constant": 1.380649e-23,
     7 |       "dipmom_au2debye": 2.5417464739297717,
     8 |       "e0": 8.8541878128e-12,
     9 |       "electron_g_factor": -2.00231930436256,
    10 |       "elementary_charge": 1.602176634e-19,
    11 |       "fine_structure_constant": 0.0072973525693,
    12 |       "hartree2ev": 27.211386245988,
    13 |       "hartree2kcalmol": 627.5094740630558,
    14 |       "hartree2kjmol": 2625.4996394798254,
    15 |       "hartree2simagnetizability": 78.9451185,
    16 |       "hartree2wavenumbers": 219474.6313632,
    17 |       "light_speed": 137.035999084,
    18 |       "meter2bohr": 18897261246.2577
    19 |     },
    20 |     "geom_opt": {
    21 |       "init_step_size": -0.5,
    22 |       "max_force_component": 0.005,
    23 |       "max_history_length": 10,
    24 |       "max_iter": 100,
    25 |       "minimal_step_size": 0.01,
    26 |       "run": false,
    27 |       "subspace_tolerance": 0.001,
    28 |       "use_previous_guess": false
    29 |     },
    30 |     "molecule": {
    31 |       "charge": 0,
    32 |       "coords": [
    33 |         {
    34 |           "atom": "f",
    35 |           "r_rms": 5.2927138943e-05,
    36 |           "xyz": [
    37 |             -2.25797417086055,
    38 |             -0.462275046496363,
    39 |             0.6442768685488515
    40 |           ]
    41 |         },
    42 |         {
    43 |           "atom": "h",
    44 |           "r_rms": 2.6569547399e-05,
    45 |           "xyz": [
    46 |             -3.1605765564318227,
    47 |             -0.7465980517921813,
    48 |             2.0925066015625777
    49 |           ]
    50 |         }
    51 |       ],
    52 |       "multiplicity": 1
    53 |     },
    54 |     "mpi": {
    55 |       "bank_size": -1,
    56 |       "numerically_exact": true,
    57 |       "omp_threads": -1,
    58 |       "shared_memory_size": 10000
    59 |     },
    60 |     "mra": {
    61 |       "basis_order": 5,
    62 |       "basis_type": "interpolating",
    63 |       "boxes": [
    64 |         2,
    65 |         2,
    66 |         2
    67 |       ],
    68 |       "corner": [
    69 |         -1,
    70 |         -1,
    71 |         -1
    72 |       ],
    73 |       "max_scale": 20,
    74 |       "min_scale": -6
    75 |     },
    76 |     "printer": {
    77 |       "file_name": "hf",
    78 |       "print_constants": false,
    79 |       "print_level": 0,
    80 |       "print_mpi": false,
    81 |       "print_prec": 6,
    82 |       "print_width": 75
    83 |     },
    84 |     "rsp_calculations": {},
    85 |     "scf_calculation": {
    86 |       "fock_operator": {
    87 |         "coulomb_operator": {
    88 |           "poisson_prec": 0.001,
    89 |           "shared_memory": false
    90 |         },
    91 |         "exchange_operator": {
    92 |           "exchange_prec": -1.0,
    93 |           "poisson_prec": 0.001
    94 |         },
    95 |         "kinetic_operator": {
    96 |           "derivative": "abgv_55"
    97 |         },
    98 |         "nuclear_operator": {
    99 |           "nuclear_model": "point_like",
   100 |           "proj_prec": 0.001,
   101 |           "shared_memory": false,
   102 |           "smooth_prec": 0.001
   103 |         },
   104 |         "xc_operator": {
   105 |           "shared_memory": false,
   106 |           "xc_functional": {
   107 |             "cutoff": 0.0,
   108 |             "functionals": [
   109 |               {
   110 |                 "coef": 1.0,
   111 |                 "name": "blyp"
   112 |               }
   113 |             ],
   114 |             "spin": false
   115 |           }
   116 |         }
   117 |       },
   118 |       "initial_guess": {
   119 |         "environment": "None",
   120 |         "external_field": "None",
   121 |         "file_CUBE_a": "cube_vectors/CUBE_a_vector.json",
   122 |         "file_CUBE_b": "cube_vectors/CUBE_b_vector.json",
   123 |         "file_CUBE_p": "cube_vectors/CUBE_p_vector.json",
   124 |         "file_basis": "initial_guess/mrchem.bas",
   125 |         "file_chk": "checkpoint/phi_scf",
   126 |         "file_gto_a": "initial_guess/mrchem.moa",
   127 |         "file_gto_b": "initial_guess/mrchem.mob",
   128 |         "file_gto_p": "initial_guess/mrchem.mop",
   129 |         "file_phi_a": "initial_guess/phi_a_scf",
   130 |         "file_phi_b": "initial_guess/phi_b_scf",
   131 |         "file_phi_p": "initial_guess/phi_p_scf",
   132 |         "localize": false,
   133 |         "method": "DFT (BLYP)",
   134 |         "prec": 0.001,
   135 |         "relativity": "None",
   136 |         "restricted": true,
   137 |         "rotate": true,
   138 |         "screen": 12.0,
   139 |         "type": "core",
   140 |         "zeta": 2
   141 |       },
   142 |       "properties": {
   143 |         "dipole_moment": {
   144 |           "dip-1": {
   145 |             "operator": "h_e_dip",
   146 |             "precision": 0.001,
   147 |             "r_O": [
   148 |               0.0,
   149 |               0.0,
   150 |               0.0
   151 |             ]
   152 |           }
   153 |         },
   154 |         "geometric_derivative": {
   155 |           "geom-1": {
   156 |             "method": "surface_integrals",
   157 |             "operator": "h_nuc_grad",
   158 |             "precision": 0.001,
   159 |             "radius_factor": 0.6,
   160 |             "smoothing": 0.001,
   161 |             "surface_integral_precision": "medium"
   162 |           }
   163 |         }
   164 |       }
   165 |     },
   166 |     "schema_name": "mrchem_input",
   167 |     "schema_version": 1
   168 |   },
   169 |   "output": {
   170 |     "properties": {
   171 |       "center_of_mass": [
   172 |         -2.3034482007428676,
   173 |         -0.47659952984111875,
   174 |         0.7172401613655945
   175 |       ],
   176 |       "charge": 0,
   177 |       "dipole_moment": {
   178 |         "dip-1": {
   179 |           "magnitude": 1.7198919865413433,
   180 |           "r_O": [
   181 |             0.0,
   182 |             0.0,
   183 |             0.0
   184 |           ],
   185 |           "vector": [
   186 |             -0.8972071878281191,
   187 |             -0.2841157968815553,
   188 |             1.4395575436366013
   189 |           ],
   190 |           "vector_el": [
   191 |             22.58513690634613,
   192 |             4.622957673378089,
   193 |             -6.451440874865561
   194 |           ],
   195 |           "vector_nuc": [
   196 |             -23.48234409417425,
   197 |             -4.907073470259644,
   198 |             7.890998418502162
   199 |           ]
   200 |         }
   201 |       },
   202 |       "geometric_derivative": {
   203 |         "geom-1": {
   204 |           "electronic": [
   205 |             0.1260519015989603,
   206 |             0.06708480199000838,
   207 |             -0.24292966533479632,
   208 |             0.30253765872409094,
   209 |             0.1843025436999091,
   210 |             -0.6277289984934219
   211 |           ],
   212 |           "electronic_norm": 0.7739150037080911,
   213 |           "nuclear": [
   214 |             0.0,
   215 |             0.0,
   216 |             0.0,
   217 |             0.0,
   218 |             0.0,
   219 |             0.0
   220 |           ],
   221 |           "nuclear_norm": 0.0,
   222 |           "total": [
   223 |             0.1260519015989603,
   224 |             0.06708480199000838,
   225 |             -0.24292966533479632,
   226 |             0.30253765872409094,
   227 |             0.1843025436999091,
   228 |             -0.6277289984934219
   229 |           ],
   230 |           "total_norm": 0.7739150037080911
   231 |         }
   232 |       },
   233 |       "geometry": [
   234 |         {
   235 |           "symbol": "F",
   236 |           "xyz": [
   237 |             -2.25797417086055,
   238 |             -0.462275046496363,
   239 |             0.6442768685488515
   240 |           ]
   241 |         },
   242 |         {
   243 |           "symbol": "H",
   244 |           "xyz": [
   245 |             -3.1605765564318227,
   246 |             -0.7465980517921813,
   247 |             2.0925066015625777
   248 |           ]
   249 |         }
   250 |       ],
   251 |       "multiplicity": 1,
   252 |       "orbital_energies": {
   253 |         "energy": [
   254 |           -16.18899571748805,
   255 |           3.1970606960540455,
   256 |           4.744873499611058,
   257 |           4.767570443715087,
   258 |           4.768191193836112
   259 |         ],
   260 |         "occupation": [
   261 |           2.0,
   262 |           2.0,
   263 |           2.0,
   264 |           2.0,
   265 |           2.0
   266 |         ],
   267 |         "spin": [
   268 |           "p",
   269 |           "p",
   270 |           "p",
   271 |           "p",
   272 |           "p"
   273 |         ],
   274 |         "sum_occupied": 2.5774002314565028
   275 |       },
   276 |       "scf_energy": {
   277 |         "E_ee": 94.6510436080992,
   278 |         "E_eext": 0.0,
   279 |         "E_el": -87.33167063235598,
   280 |         "E_en": -329.7709134337061,
   281 |         "E_kin": 163.8699575241591,
   282 |         "E_next": 0.0,
   283 |         "E_nn": 5.2023121410189415,
   284 |         "E_nuc": 5.2023121410189415,
   285 |         "E_tot": -82.12935849133704,
   286 |         "E_x": 0.0,
   287 |         "E_xc": -16.08180932,
   288 |         "Er_el": 0.0,
   289 |         "Er_nuc": 0.0,
   290 |         "Er_tot": 0.0
   291 |       }
   292 |     },
   293 |     "provenance": {
   294 |       "creator": "MRChem",
   295 |       "mpi_processes": 1,
   296 |       "nthreads": 8,
   297 |       "routine": "mrchem.x",
   298 |       "total_cores": 8,
   299 |       "version": "1.2.0-alpha"
   300 |     },
   301 |     "rsp_calculations": null,
   302 |     "scf_calculation": {
   303 |       "initial_energy": {
   304 |         "E_ee": 94.6510436080992,
   305 |         "E_eext": 0.0,
   306 |         "E_el": -87.33167063235598,
   307 |         "E_en": -329.7709134337061,
   308 |         "E_kin": 163.8699575241591,
   309 |         "E_next": 0.0,
   310 |         "E_nn": 5.2023121410189415,
   311 |         "E_nuc": 5.2023121410189415,
   312 |         "E_tot": -82.12935849133704,
   313 |         "E_x": 0.0,
   314 |         "E_xc": -16.081758330908208,
   315 |         "Er_el": 0.0,
   316 |         "Er_nuc": 0.0,
   317 |         "Er_tot": 0.0
   318 |       },
   319 |       "success": true
   320 |     },
   321 |     "schema_name": "mrchem_output",
   322 |     "schema_version": 1,
   323 |     "success": true
   324 |   }
   325 | }

=== FILE: tests/hf_grad_lda/reference/hf.json | 6.9 KB ===
     1 | {
     2 |   "input": {
     3 |     "molecule": {
     4 |       "cavity_coords": [
     5 |         {
     6 |           "center": [
     7 |             -4.266952779405394,
     8 |             -0.8735732321267697,
     9 |             1.2175068299888478
    10 |           ],
    11 |           "radius": 1.0771438910366888
    12 |         },
    13 |         {
    14 |           "center": [
    15 |             -5.9726240875689705,
    16 |             -1.4108658430663887,
    17 |             3.9542643909246906
    18 |           ],
    19 |           "radius": 1.4928836384543585
    20 |         }
    21 |       ],
    22 |       "cavity_width": 0.37794522492515403,
    23 |       "charge": 0,
    24 |       "coords": [
    25 |         {
    26 |           "atom": "f",
    27 |           "xyz": [
    28 |             -2.25797417086055,
    29 |             -0.462275046496363,
    30 |             0.6442768685488515
    31 |           ]
    32 |         },
    33 |         {
    34 |           "atom": "h",
    35 |           "xyz": [
    36 |             -3.1605765564318227,
    37 |             -0.7465980517921813,
    38 |             2.0925066015625777
    39 |           ]
    40 |         }
    41 |       ],
    42 |       "multiplicity": 1
    43 |     },
    44 |     "mpi": {
    45 |       "bank_size": -1,
    46 |       "numerically_exact": true,
    47 |       "shared_memory_size": 10000
    48 |     },
    49 |     "mra": {
    50 |       "basis_order": 5,
    51 |       "basis_type": "interpolating",
    52 |       "boxes": [
    53 |         2,
    54 |         2,
    55 |         2
    56 |       ],
    57 |       "corner": [
    58 |         -1,
    59 |         -1,
    60 |         -1
    61 |       ],
    62 |       "max_scale": 20,
    63 |       "min_scale": -6
    64 |     },
    65 |     "printer": {
    66 |       "file_name": "hf.inp",
    67 |       "print_level": 0,
    68 |       "print_mpi": false,
    69 |       "print_prec": 6,
    70 |       "print_width": 75
    71 |     },
    72 |     "rsp_calculations": {},
    73 |     "scf_calculation": {
    74 |       "fock_operator": {
    75 |         "coulomb_operator": {
    76 |           "poisson_prec": 0.001,
    77 |           "shared_memory": false
    78 |         },
    79 |         "exchange_operator": {
    80 |           "exchange_prec": -1.0,
    81 |           "poisson_prec": 0.001
    82 |         },
    83 |         "kinetic_operator": {
    84 |           "derivative": "abgv_55"
    85 |         },
    86 |         "nuclear_operator": {
    87 |           "proj_prec": 0.001,
    88 |           "shared_memory": false,
    89 |           "smooth_prec": 0.001
    90 |         },
    91 |         "xc_operator": {
    92 |           "shared_memory": false,
    93 |           "xc_functional": {
    94 |             "cutoff": 0.0,
    95 |             "functionals": [
    96 |               {
    97 |                 "coef": 1.0,
    98 |                 "name": "svwn5"
    99 |               }
   100 |             ],
   101 |             "spin": false
   102 |           }
   103 |         }
   104 |       },
   105 |       "initial_guess": {
   106 |         "file_basis": "initial_guess/mrchem.bas",
   107 |         "file_chk": "checkpoint/phi_scf",
   108 |         "file_gto_a": "initial_guess/mrchem.moa",
   109 |         "file_gto_b": "initial_guess/mrchem.mob",
   110 |         "file_gto_p": "initial_guess/mrchem.mop",
   111 |         "file_phi_a": "initial_guess/phi_a_scf",
   112 |         "file_phi_b": "initial_guess/phi_b_scf",
   113 |         "file_phi_p": "initial_guess/phi_p_scf",
   114 |         "localize": false,
   115 |         "method": "DFT (SVWN5)",
   116 |         "prec": 0.001,
   117 |         "restricted": true,
   118 |         "type": "core",
   119 |         "zeta": 2
   120 |       },
   121 |       "properties": {
   122 |         "dipole_moment": {
   123 |           "dip-1": {
   124 |             "operator": "h_e_dip",
   125 |             "precision": 0.001,
   126 |             "r_O": [
   127 |               0.0,
   128 |               0.0,
   129 |               0.0
   130 |             ]
   131 |           }
   132 |         },
   133 |         "geometric_derivative": {
   134 |           "geom-1": {
   135 |             "operator": "h_nuc_grad",
   136 |             "precision": 0.001,
   137 |             "smooth_prec": 0.001
   138 |           }
   139 |         }
   140 |       }
   141 |     },
   142 |     "schema_name": "mrchem_input",
   143 |     "schema_version": 1
   144 |   },
   145 |   "output": {
   146 |     "properties": {
   147 |       "center_of_mass": [
   148 |         -2.3034482007428676,
   149 |         -0.47659952984111875,
   150 |         0.7172401613655945
   151 |       ],
   152 |       "charge": 0,
   153 |       "dipole_moment": {
   154 |         "dip-1": {
   155 |           "magnitude": 1.719904025547463,
   156 |           "r_O": [
   157 |             0.0,
   158 |             0.0,
   159 |             0.0
   160 |           ],
   161 |           "vector": [
   162 |             -0.8972280913620452,
   163 |             -0.28411660698606145,
   164 |             1.4395587389196445
   165 |           ],
   166 |           "vector_el": [
   167 |             22.585116002812203,
   168 |             4.622956863273583,
   169 |             -6.451439679582518
   170 |           ],
   171 |           "vector_nuc": [
   172 |             -23.48234409417425,
   173 |             -4.907073470259644,
   174 |             7.890998418502162
   175 |           ]
   176 |         }
   177 |       },
   178 |       "geometric_derivative": {
   179 |         "geom-1": {
   180 |           "electronic": [
   181 |             0.18841208365699463,
   182 |             -2.0754989710159437,
   183 |             -0.30224686528652456,
   184 |             -1.7451139820795545,
   185 |             -0.550106829049456,
   186 |             2.8002194690324362
   187 |           ],
   188 |           "electronic_norm": 3.9526975179105786,
   189 |           "nuclear": [
   190 |             -1.5689195606619417,
   191 |             -0.49421531749272585,
   192 |             2.5173387449218514,
   193 |             1.5689195606619417,
   194 |             0.49421531749272585,
   195 |             -2.5173387449218514
   196 |           ],
   197 |           "nuclear_norm": 4.252705427032731,
   198 |           "total": [
   199 |             -1.380507477004947,
   200 |             -2.5697142885086697,
   201 |             2.215091879635327,
   202 |             -0.17619442141761277,
   203 |             -0.05589151155673011,
   204 |             0.28288072411058485
   205 |           ],
   206 |           "total_norm": 3.678322211706672
   207 |         }
   208 |       },
   209 |       "geometry": [
   210 |         {
   211 |           "symbol": "F",
   212 |           "xyz": [
   213 |             -2.25797417086055,
   214 |             -0.462275046496363,
   215 |             0.6442768685488515
   216 |           ]
   217 |         },
   218 |         {
   219 |           "symbol": "H",
   220 |           "xyz": [
   221 |             -3.1605765564318227,
   222 |             -0.7465980517921813,
   223 |             2.0925066015625777
   224 |           ]
   225 |         }
   226 |       ],
   227 |       "multiplicity": 1,
   228 |       "orbital_energies": {
   229 |         "energy": [
   230 |           -15.989315407026629,
   231 |           3.235637551573358,
   232 |           4.7527923878469505,
   233 |           4.77560198567038,
   234 |           4.776109835111442
   235 |         ],
   236 |         "occupation": [
   237 |           2.0,
   238 |           2.0,
   239 |           2.0,
   240 |           2.0,
   241 |           2.0
   242 |         ],
   243 |         "spin": [
   244 |           "p",
   245 |           "p",
   246 |           "p",
   247 |           "p",
   248 |           "p"
   249 |         ],
   250 |         "sum_occupied": 3.1016527063510058
   251 |       },
   252 |       "scf_energy": {
   253 |         "E_ee": 94.65104330071759,
   254 |         "E_eext": 0.0,
   255 |         "E_el": -86.5736125221208,
   256 |         "E_en": -329.77091312936926,
   257 |         "E_kin": 163.86995613659036,
   258 |         "E_next": 0.0,
   259 |         "E_nn": 5.2023121410189415,
   260 |         "E_nuc": 5.2023121410189415,
   261 |         "E_tot": -81.37130038110186,
   262 |         "E_x": 0.0,
   263 |         "E_xc": -15.32371613,
   264 |         "Er_el": 0.0,
   265 |         "Er_nuc": 0.0,
   266 |         "Er_tot": 0.0
   267 |       }
   268 |     },
   269 |     "provenance": {
   270 |       "creator": "MRChem",
   271 |       "mpi_processes": 1,
   272 |       "nthreads": 1,
   273 |       "routine": "mrchem.x",
   274 |       "total_cores": 1,
   275 |       "version": "1.1.0-alpha"
   276 |     },
   277 |     "rsp_calculations": null,
   278 |     "scf_calculation": {
   279 |       "initial_energy": {
   280 |         "E_ee": 94.65104330071759,
   281 |         "E_eext": 0.0,
   282 |         "E_el": -86.5736125221208,
   283 |         "E_en": -329.77091312936926,
   284 |         "E_kin": 163.86995613659036,
   285 |         "E_next": 0.0,
   286 |         "E_nn": 5.2023121410189415,
   287 |         "E_nuc": 5.2023121410189415,
   288 |         "E_tot": -81.37130038110186,
   289 |         "E_x": 0.0,
   290 |         "E_xc": -15.323698830059485,
   291 |         "Er_el": 0.0,
   292 |         "Er_nuc": 0.0,
   293 |         "Er_tot": 0.0
   294 |       },
   295 |       "success": true
   296 |     },
   297 |     "schema_name": "mrchem_output",
   298 |     "schema_version": 1,
   299 |     "success": true
   300 |   }
   301 | }

=== FILE: xc_bundle_20250825_012432.txt | 103.0 KB ===
     1 | ===== BEGIN src/mrdft/xc_utils.h =====
     2 | /*
     3 |  * MRChem, a numerical real-space code for molecular electronic structure
     4 |  * calculations within the self-consistent field (SCF) approximations of quantum
     5 |  * chemistry (Hartree-Fock and Density Functional Theory).
     6 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
     7 |  *
     8 |  * This file is part of MRChem.
     9 |  *
    10 |  * MRChem is free software: you can redistribute it and/or modify
    11 |  * it under the terms of the GNU Lesser General Public License as published by
    12 |  * the Free Software Foundation, either version 3 of the License, or
    13 |  * (at your option) any later version.
    14 |  *
    15 |  * MRChem is distributed in the hope that it will be useful,
    16 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
    17 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18 |  * GNU Lesser General Public License for more details.
    19 |  *
    20 |  * You should have received a copy of the GNU Lesser General Public License
    21 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
    22 |  *
    23 |  * For information on the complete list of contributors to MRChem, see:
    24 |  * <https://mrchem.readthedocs.io/>
    25 |  */
    26 | 
    27 | #include <Eigen/Core>
    28 | #include <MRCPP/MWFunctions>
    29 | #include <XCFun/xcfun.h>
    30 | 
    31 | namespace mrdft {
    32 | namespace xc_utils {
    33 | 
    34 | Eigen::MatrixXi build_output_mask(bool is_lda, bool is_spin_sep, int order);
    35 | Eigen::VectorXi build_density_mask(bool is_lda, bool is_spin_sep, int order);
    36 | 
    37 | std::vector<mrcpp::FunctionNode<3> *> fetch_nodes(int n, mrcpp::FunctionTreeVector<3> &inp);
    38 | Eigen::MatrixXd compress_nodes(std::vector<mrcpp::FunctionNode<3> *> &inp_nodes);
    39 | void expand_nodes(std::vector<mrcpp::FunctionNode<3> *> &out_nodes, Eigen::MatrixXd &out_data);
    40 | 
    41 | mrcpp::FunctionTreeVector<3> log_gradient(mrcpp::DerivativeOperator<3> &diff_oper, mrcpp::FunctionTree<3> &rho);
    42 | 
    43 | } // namespace xc_utils
    44 | } // namespace mrdft
    45 | 
    46 | ===== END src/mrdft/xc_utils.h =====
    47 | 
    48 | ===== BEGIN src/mrdft/xc_utils.cpp =====
    49 | /*
    50 |  * MRChem, a numerical real-space code for molecular electronic structure
    51 |  * calculations within the self-consistent field (SCF) approximations of quantum
    52 |  * chemistry (Hartree-Fock and Density Functional Theory).
    53 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
    54 |  *
    55 |  * This file is part of MRChem.
    56 |  *
    57 |  * MRChem is free software: you can redistribute it and/or modify
    58 |  * it under the terms of the GNU Lesser General Public License as published by
    59 |  * the Free Software Foundation, either version 3 of the License, or
    60 |  * (at your option) any later version.
    61 |  *
    62 |  * MRChem is distributed in the hope that it will be useful,
    63 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
    64 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    65 |  * GNU Lesser General Public License for more details.
    66 |  *
    67 |  * You should have received a copy of the GNU Lesser General Public License
    68 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
    69 |  *
    70 |  * For information on the complete list of contributors to MRChem, see:
    71 |  * <https://mrchem.readthedocs.io/>
    72 |  */
    73 | 
    74 | #include <MRCPP/MWOperators>
    75 | #include <MRCPP/Printer>
    76 | #include <MRCPP/trees/FunctionNode.h>
    77 | 
    78 | #include "xc_utils.h"
    79 | 
    80 | namespace mrdft {
    81 | 
    82 | namespace xc_utils {
    83 | void fill_output_mask(Eigen::MatrixXi &mask, int start);
    84 | } // namespace xc_utils
    85 | 
    86 | Eigen::MatrixXi xc_utils::build_output_mask(bool is_lda, bool is_spin_sep, int order) {
    87 |     int start = 2;
    88 |     bool is_gga = not is_lda;
    89 |     Eigen::MatrixXi mask(1, 1);
    90 |     mask << 1;
    91 |     switch (order) {
    92 |         case 0:
    93 |             break;
    94 |         case 1:
    95 |             if (is_lda and is_spin_sep) {
    96 |                 mask.resize(2, 1);
    97 |                 mask << 1, 2;
    98 |             } else if (is_gga and not is_spin_sep) {
    99 |                 mask.resize(4, 1);
   100 |                 mask << 1, 2, 3, 4;
   101 |             } else if (is_gga and is_spin_sep) {
   102 |                 mask.resize(8, 1);
   103 |                 mask << 1, 2, 3, 4, 5, 6, 7, 8;
   104 |             }
   105 |             break;
   106 |         case 2:
   107 |             if (is_lda and is_spin_sep) {
   108 |                 start = 3;
   109 |                 mask.resize(2, 2);
   110 |             } else if (is_gga and not is_spin_sep) {
   111 |                 start = 5;
   112 |                 mask.resize(4, 4);
   113 |             } else if (is_gga and is_spin_sep) {
   114 |                 start = 9;
   115 |                 mask.resize(8, 8);
   116 |             }
   117 |             fill_output_mask(mask, start);
   118 |             break;
   119 |         default:
   120 |             MSG_ABORT("Not implemented");
   121 |     }
   122 |     return mask;
   123 | }
   124 | 
   125 | Eigen::VectorXi xc_utils::build_density_mask(bool is_lda, bool is_spin_sep, int order) {
   126 |     bool is_gga = not is_lda;
   127 |     Eigen::VectorXi mask(1);
   128 |     switch (order) {
   129 |         case 0:
   130 |         case 1:
   131 |             mask(0) = -1;
   132 |             break;
   133 |         case 2:
   134 |             mask(0) = 0;
   135 |             if (is_lda and is_spin_sep) {
   136 |                 mask.resize(2);
   137 |                 mask << 0, 1;
   138 |             } else if (is_gga and not is_spin_sep) {
   139 |                 mask.resize(4);
   140 |                 mask << 0, 1, 2, 3;
   141 |             } else if (is_gga and is_spin_sep) {
   142 |                 mask.resize(8);
   143 |                 mask << 0, 1, 2, 3, 4, 5, 6, 7;
   144 |             }
   145 |             break;
   146 |         default:
   147 |             MSG_ABORT("Not implemented");
   148 |     }
   149 |     return mask;
   150 | }
   151 | 
   152 | void xc_utils::fill_output_mask(Eigen::MatrixXi &mask, int value) {
   153 |     for (int i = 0; i < mask.rows(); i++) {
   154 |         mask(i, i) = value;
   155 |         value++;
   156 |         for (int j = i + 1; j < mask.cols(); j++) {
   157 |             mask(i, j) = value;
   158 |             mask(j, i) = value;
   159 |             value++;
   160 |         }
   161 |     }
   162 | }
   163 | 
   164 | /** @brief Fetch specific node from several FunctionTrees
   165 |  *
   166 |  * This will retrieve one node from each of the input trees and put them
   167 |  * into a vector of FunctionNodes. The node is fetched from position n
   168 |  * in the respective endNodeTables, which means that the tree structures
   169 |  * must be identical for this routine to work as intended.
   170 |  *
   171 |  * param[in] n Node position in EndNodeTable
   172 |  * param[in] inp_trees Array of FunctionTrees
   173 |  * param[out] out_nodes Array of FunctionNodes
   174 |  */
   175 | std::vector<mrcpp::FunctionNode<3> *> xc_utils::fetch_nodes(int n, mrcpp::FunctionTreeVector<3> &inp_trees) {
   176 |     std::vector<mrcpp::FunctionNode<3> *> out_nodes;
   177 |     for (auto i = 0; i < inp_trees.size(); i++) {
   178 |         auto &iTree = mrcpp::get_func(inp_trees, i);
   179 |         auto &iNode = iTree.getEndFuncNode(n);
   180 |         out_nodes.push_back(&iNode);
   181 |     }
   182 |     return out_nodes;
   183 | }
   184 | 
   185 | /** @brief Collect data from FunctionNodes into a matrix
   186 |  *
   187 |  * Collects function values from the input nodes into the rows
   188 |  * of a matrix. Matrix dimension: rows = nNodes, cols = nCoefs.
   189 |  *
   190 |  * param[in] inp_nodes Array of FunctionNodes
   191 |  * param[out] out_data Matrix of function values
   192 |  */
   193 | Eigen::MatrixXd xc_utils::compress_nodes(std::vector<mrcpp::FunctionNode<3> *> &inp_nodes) {
   194 |     Eigen::MatrixXd out_data;
   195 |     auto nNodes = inp_nodes.size();
   196 |     if (nNodes > 0) {
   197 |         auto nCoefs = inp_nodes[0]->getNCoefs();
   198 |         out_data = Eigen::MatrixXd::Zero(nNodes, nCoefs);
   199 |         for (auto i = 0; i < nNodes; i++) {
   200 |             auto &node = inp_nodes[i];
   201 |             Eigen::VectorXd row_i;
   202 |             node->getValues(row_i);
   203 |             if (row_i.size() != nCoefs) MSG_ABORT("Size mismatch");
   204 |             out_data.row(i) = row_i;
   205 |         }
   206 |     }
   207 |     return out_data;
   208 | }
   209 | 
   210 | /** @brief Put data from a matrix into FunctionNodes
   211 |  *
   212 |  * Each row of the input data is used as function values
   213 |  * of the corresponding FunctionNode in the output vector.
   214 |  * Matrix dimension: rows = nNodes, cols = nCoefs.
   215 |  *
   216 |  * param[inout] out_nodes Array of FunctionNodes
   217 |  * param[in] inp_data Matrix of function values
   218 |  */
   219 | void xc_utils::expand_nodes(std::vector<mrcpp::FunctionNode<3> *> &out_nodes, Eigen::MatrixXd &inp_data) {
   220 |     auto nFuncs = out_nodes.size();
   221 |     if (inp_data.rows() != nFuncs) MSG_ERROR("Size mismatch " << inp_data.rows() << " vs " << nFuncs);
   222 | 
   223 |     for (auto i = 0; i < nFuncs; i++) {
   224 |         auto &node = out_nodes[i];
   225 |         node->setValues(inp_data.row(i));
   226 |     }
   227 | }
   228 | 
   229 | /** @brief Compute the gradient using a log parametrization
   230 |  *
   231 |  * zeta = log(inp_func)
   232 |  * grad(inp_func) = inp_func * grad(zeta)
   233 |  *
   234 |  * param[in] diff_oper Derivative operator
   235 |  * param[in] inp_func Function to differentiate
   236 |  * param[out] out_grad Gradient of input function
   237 |  */
   238 | mrcpp::FunctionTreeVector<3> xc_utils::log_gradient(mrcpp::DerivativeOperator<3> &diff_oper, mrcpp::FunctionTree<3> &inp_func) {
   239 |     mrcpp::FunctionTree<3> zeta(inp_func.getMRA());
   240 |     mrcpp::copy_grid(zeta, inp_func);
   241 |     mrcpp::copy_func(zeta, inp_func);
   242 |     for (auto i = 0; i < zeta.getNEndNodes(); i++) {
   243 |         auto &node = zeta.getEndFuncNode(i);
   244 |         Eigen::VectorXd values;
   245 |         node.getValues(values);
   246 |         for (auto j = 0; j < node.getNCoefs(); j++) {
   247 |             if (values[j] > mrcpp::MachineZero) {
   248 |                 values[j] = std::log(values[j]);
   249 |             } else {
   250 |                 values[j] = mrcpp::MachineZero;
   251 |             }
   252 |         }
   253 |         node.setValues(values);
   254 |     }
   255 |     zeta.mwTransform(mrcpp::BottomUp);
   256 | 
   257 |     mrcpp::FunctionTreeVector<3> grad_zeta = mrcpp::gradient(diff_oper, zeta);
   258 | 
   259 |     mrcpp::FunctionTreeVector<3> out_grad;
   260 |     for (int i = 0; i < 3; i++) {
   261 |         mrcpp::FunctionTree<3> *grad_comp = new mrcpp::FunctionTree<3>(inp_func.getMRA());
   262 |         mrcpp::copy_grid(*grad_comp, inp_func);
   263 |         mrcpp::multiply(-1.0, *grad_comp, 1.0, inp_func, mrcpp::get_func(grad_zeta, i));
   264 |         out_grad.push_back(std::make_tuple(1.0, grad_comp));
   265 |     }
   266 |     mrcpp::clear(grad_zeta, true);
   267 |     return out_grad;
   268 | }
   269 | 
   270 | } // namespace mrdft
   271 | 
   272 | ===== END src/mrdft/xc_utils.cpp =====
   273 | 
   274 | ===== BEGIN src/mrdft/Functional.h =====
   275 | /*
   276 |  * MRChem, a numerical real-space code for molecular electronic structure
   277 |  * calculations within the self-consistent field (SCF) approximations of quantum
   278 |  * chemistry (Hartree-Fock and Density Functional Theory).
   279 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
   280 |  *
   281 |  * This file is part of MRChem.
   282 |  *
   283 |  * MRChem is free software: you can redistribute it and/or modify
   284 |  * it under the terms of the GNU Lesser General Public License as published by
   285 |  * the Free Software Foundation, either version 3 of the License, or
   286 |  * (at your option) any later version.
   287 |  *
   288 |  * MRChem is distributed in the hope that it will be useful,
   289 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
   290 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   291 |  * GNU Lesser General Public License for more details.
   292 |  *
   293 |  * You should have received a copy of the GNU Lesser General Public License
   294 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
   295 |  *
   296 |  * For information on the complete list of contributors to MRChem, see:
   297 |  * <https://mrchem.readthedocs.io/>
   298 |  */
   299 | 
   300 | #pragma once
   301 | 
   302 | #include <memory>
   303 | 
   304 | #include <Eigen/Core>
   305 | #include <MRCPP/MWFunctions>
   306 | #include <MRCPP/MWOperators>
   307 | #include <MRCPP/trees/FunctionNode.h>
   308 | #include <XCFun/xcfun.h>
   309 | 
   310 | namespace mrdft {
   311 | 
   312 | using XC_p = std::unique_ptr<xcfun_t, decltype(&xcfun_delete)>;
   313 | 
   314 | class Functional {
   315 | public:
   316 |     Functional(int k, XC_p &f)
   317 |             : order(k)
   318 |             , xcfun(std::move(f)) {}
   319 |     virtual ~Functional() = default;
   320 | 
   321 |     void makepot(mrcpp::FunctionTreeVector<3> &inp, std::vector<mrcpp::FunctionNode<3> *> xcNodes) const;
   322 | 
   323 |     void setLogGradient(bool log) { log_grad = log; }
   324 |     void setDensityCutoff(double cut) { cutoff = cut; }
   325 |     void setDerivOp(std::unique_ptr<mrcpp::DerivativeOperator<3>> &d) {derivOp = std::move(d);}
   326 | 
   327 |     virtual bool isSpin() const = 0;
   328 |     bool isLDA() const { return (not(isGGA() or isMetaGGA())); }
   329 |     bool isGGA() const { return xcfun_is_gga(xcfun.get()); }
   330 |     bool isMetaGGA() const { return xcfun_is_metagga(xcfun.get()); }
   331 |     bool isHybrid() const { return (std::abs(amountEXX()) > 1.0e-10); }
   332 |     double amountEXX() const {
   333 |         double exx = 0.0;
   334 |         xcfun_get(xcfun.get(), "exx", &exx);
   335 |         return exx;
   336 |     }
   337 |     double XCenergy = 0.0;
   338 | 
   339 |     Eigen::MatrixXd evaluate(Eigen::MatrixXd &inp) const;
   340 |     Eigen::MatrixXd evaluate_transposed(Eigen::MatrixXd &inp) const;
   341 |     friend class MRDFT;
   342 | 
   343 | protected:
   344 |     const int order;
   345 |     bool log_grad{false};
   346 |     double cutoff{-1.0};
   347 |     Eigen::VectorXi d_mask;
   348 |     Eigen::MatrixXi xc_mask;
   349 |     XC_p xcfun;
   350 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> derivOp{nullptr};
   351 | 
   352 |     int getXCInputLength() const { return xcfun_input_length(xcfun.get()); }
   353 |     int getXCOutputLength() const { return xcfun_output_length(xcfun.get()); }
   354 |     virtual int getCtrInputLength() const = 0;
   355 |     virtual int getCtrOutputLength() const = 0;
   356 | 
   357 |     Eigen::MatrixXd contract(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const;
   358 |     Eigen::MatrixXd contract_transposed(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const;
   359 | 
   360 |     virtual void clear() = 0;
   361 |     virtual mrcpp::FunctionTreeVector<3> setupXCInput() = 0;
   362 |     virtual mrcpp::FunctionTreeVector<3> setupCtrInput() = 0;
   363 | 
   364 |     virtual void preprocess(mrcpp::FunctionTreeVector<3> &inp) = 0;
   365 |     virtual mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) = 0;
   366 | };
   367 | 
   368 | } // namespace mrdft
   369 | 
   370 | ===== END src/mrdft/Functional.h =====
   371 | 
   372 | ===== BEGIN src/mrdft/Functional.cpp =====
   373 | /*
   374 |  * MRChem, a numerical real-space code for molecular electronic structure
   375 |  * calculations within the self-consistent field (SCF) approximations of quantum
   376 |  * chemistry (Hartree-Fock and Density Functional Theory).
   377 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
   378 |  *
   379 |  * This file is part of MRChem.
   380 |  *
   381 |  * MRChem is free software: you can redistribute it and/or modify
   382 |  * it under the terms of the GNU Lesser General Public License as published by
   383 |  * the Free Software Foundation, either version 3 of the License, or
   384 |  * (at your option) any later version.
   385 |  *
   386 |  * MRChem is distributed in the hope that it will be useful,
   387 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
   388 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   389 |  * GNU Lesser General Public License for more details.
   390 |  *
   391 |  * You should have received a copy of the GNU Lesser General Public License
   392 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
   393 |  *
   394 |  * For information on the complete list of contributors to MRChem, see:
   395 |  * <https://mrchem.readthedocs.io/>
   396 |  */
   397 | 
   398 | #include <MRCPP/Printer>
   399 | 
   400 | #include "Functional.h"
   401 | 
   402 | namespace mrdft {
   403 | 
   404 | /** @brief Run a collection of grid points through XCFun
   405 |  *
   406 |  * Each row corresponds to one grid point.
   407 |  *
   408 |  * param[in] inp_data Matrix of input values
   409 |  * param[out] out_data Matrix of output values
   410 |  */
   411 | Eigen::MatrixXd Functional::evaluate(Eigen::MatrixXd &inp) const {
   412 |     int nInp = xcfun_input_length(xcfun.get());  // Input parameters to XCFun
   413 |     int nOut = xcfun_output_length(xcfun.get()); // Input parameters to XCFun
   414 |     int nPts = inp.cols();
   415 |     if (nInp != inp.rows()) MSG_ABORT("Invalid input");
   416 | 
   417 |     Eigen::MatrixXd out = Eigen::MatrixXd::Zero(nOut, nPts);
   418 |     for (int i = 0; i < nPts; i++) {
   419 |         bool calc = true;
   420 |         if (isSpin()) {
   421 |             if (inp(0, i) < cutoff and inp(1, i) < cutoff) calc = false;
   422 |         } else {
   423 |             if (inp(0, i) < cutoff) calc = false;
   424 |         }
   425 |         // NB: the data is stored colomn major, i.e. two consecutive points of for example energy density, are not consecutive in memory
   426 |         // That means that we cannot extract the energy density data with out.row(0).data() for example.
   427 |         if (calc) xcfun_eval(xcfun.get(), inp.col(i).data(), out.col(i).data());
   428 |     }
   429 |     return out;
   430 | }
   431 | 
   432 | 
   433 | /** @brief Run a collection of grid points through XCFun
   434 |  *
   435 |  * Each column corresponds to one grid point.
   436 |  * From a performance point of view, (in pre and postprocessing) it is much more
   437 |  * efficient to have the two consecutive points in two consecutive adresses in memory
   438 |  *
   439 |  * param[in] inp_data Matrix of input values
   440 |  * param[out] out_data Matrix of output values
   441 |  */
   442 | Eigen::MatrixXd Functional::evaluate_transposed(Eigen::MatrixXd &inp) const {
   443 |     int nInp = xcfun_input_length(xcfun.get());  // Input parameters to XCFun
   444 |     int nOut = xcfun_output_length(xcfun.get()); // Input parameters to XCFun
   445 |     int nPts = inp.rows();
   446 |     if (nInp != inp.cols()) MSG_ABORT("Invalid input");
   447 | 
   448 |     Eigen::MatrixXd out = Eigen::MatrixXd::Zero(nPts, nOut);
   449 |     Eigen::VectorXd inp_row = Eigen::VectorXd::Zero(nInp);
   450 |     Eigen::VectorXd out_row = Eigen::VectorXd::Zero(nOut);
   451 |     for (int i = 0; i < nPts; i++) {
   452 |         bool calc = true;
   453 |         if (isSpin()) {
   454 |             if (inp(i, 0) < cutoff and inp(i, 1) < cutoff) calc = false;
   455 |         } else {
   456 |             if (inp(i, 0) < cutoff) calc = false;
   457 |         }
   458 |         for (int j = 0; j < nInp; j++) inp_row(j) = inp(i, j);
   459 |         if (calc) xcfun_eval(xcfun.get(), inp_row.data(), out_row.data());
   460 |         for (int j = 0; j < nOut; j++) out(i, j) = out_row(j);
   461 |     }
   462 |     return out;
   463 | }
   464 | 
   465 | 
   466 | /** @brief Contract a collection of grid points
   467 |  *
   468 |  * Each row corresponds to one grid point.
   469 |  *
   470 |  * param[in] xc_data Matrix of functional partial derivative values
   471 |  * param[in] d_data Matrix of density input values
   472 |  * param[out] out_data Matrix of contracted output values
   473 |  */
   474 | Eigen::MatrixXd Functional::contract(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const {
   475 |     auto nPts = xc_data.cols();
   476 |     auto nFcs = getCtrOutputLength();
   477 |     Eigen::MatrixXd out_data = Eigen::MatrixXd::Zero(nFcs, nPts);
   478 |     out_data.row(0) = xc_data.row(0); // we always keep the energy functional
   479 | 
   480 |     for (int i = 0; i < this->xc_mask.rows(); i++) {
   481 |         Eigen::VectorXd cont_i = Eigen::VectorXd::Zero(nPts);
   482 |         for (int j = 0; j < this->xc_mask.cols(); j++) {
   483 |             Eigen::VectorXd cont_ij = Eigen::VectorXd::Zero(nPts);
   484 |             int xc_idx = this->xc_mask(i, j);
   485 |             int d_idx = this->d_mask(j);
   486 |             if (d_idx >= 0) {
   487 |                 cont_ij = xc_data.row(xc_idx).array() * d_data.row(d_idx).array();
   488 |             } else {
   489 |                 cont_ij = xc_data.row(xc_idx);
   490 |             }
   491 |             cont_i += cont_ij;
   492 |         }
   493 |         out_data.row(i + 1) = cont_i; // The first column contains the energy functional
   494 |     }
   495 |     return out_data;
   496 | }
   497 | 
   498 | /** @brief Contract a collection of grid points
   499 |  *
   500 |  * Each column corresponds to one set of grid points.
   501 |  *
   502 |  * param[in] xc_data Matrix of functional partial derivative values
   503 |  * param[in] d_data Matrix of density input values
   504 |  * param[out] out_data Matrix of contracted output values
   505 |  */
   506 | Eigen::MatrixXd Functional::contract_transposed(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const {
   507 |     auto nPts = xc_data.rows();
   508 |     auto nFcs = getCtrOutputLength();
   509 |     Eigen::MatrixXd out_data = Eigen::MatrixXd::Zero(nPts, nFcs);
   510 |     out_data.col(0) = xc_data.col(0); // we always keep the energy functional
   511 | 
   512 |     for (int i = 0; i < this->xc_mask.rows(); i++) {
   513 |         Eigen::VectorXd cont_i = Eigen::VectorXd::Zero(nPts);
   514 |         for (int j = 0; j < this->xc_mask.cols(); j++) {
   515 |             Eigen::VectorXd cont_ij = Eigen::VectorXd::Zero(nPts);
   516 |             int xc_idx = this->xc_mask(i, j);
   517 |             int d_idx = this->d_mask(j);
   518 |             if (d_idx >= 0) {
   519 |                 //elementwise product of one column of xc_data and d_data
   520 |                 out_data.col(i + 1) += xc_data.col(xc_idx).cwiseProduct(d_data.col(d_idx));
   521 |             } else {
   522 |                 out_data.col(i + 1) += xc_data.col(xc_idx);
   523 |             }
   524 |         }
   525 |     }
   526 |     return out_data;
   527 | }
   528 | 
   529 | 
   530 | /** @brief  Evaluates XC functional and derivatives for a given NodeIndex
   531 |  *
   532 |  * The electronic densities (total/alpha/beta) are given as input.
   533 |  * The values of the zero order densities and their gradient are sent to xcfun.
   534 |  * The output of xcfun must then be combined ("contract") with the gradients
   535 |  * of the higher order densities.
   536 |  *
   537 |  * XCFunctional output (with k=1 and explicit derivatives):
   538 |  *
   539 |  * LDA: \f$ \left(F_{xc}, \frac{\partial F_{xc}}{\partial \rho}\right) \f$
   540 |  *
   541 |  * GGA: \f$ \left(F_{xc},
   542 |  *  \frac{\partial F_{xc}}{\partial \rho},
   543 |  *  \frac{\partial F_{xc}}{\partial \rho_x},
   544 |  *  \frac{\partial F_{xc}}{\partial \rho_y},
   545 |  *  \frac{\partial F_{xc}}{\partial \rho_z}\right) \f$
   546 |  *
   547 |  * Spin LDA: \f$ \left(F_{xc}, \frac{\partial F_{xc}}{\partial \rho^\alpha},
   548 |  *  \frac{\partial F_{xc}}{\partial \rho^\beta}\right) \f$
   549 |  *
   550 |  * Spin GGA: \f$ \left(F_{xc},
   551 |  *  \frac{\partial F_{xc}}{\partial \rho^\alpha},
   552 |  *  \frac{\partial F_{xc}}{\partial \rho^\beta},
   553 |  *  \frac{\partial F_{xc}}{\partial \rho_x^\alpha},
   554 |  *  \frac{\partial F_{xc}}{\partial \rho_y^\alpha},
   555 |  *  \frac{\partial F_{xc}}{\partial \rho_z^\alpha},
   556 |  *  \frac{\partial F_{xc}}{\partial \rho_x^\beta},
   557 |  *  \frac{\partial F_{xc}}{\partial \rho_y^\beta},
   558 |  *  \frac{\partial F_{xc}}{\partial \rho_z^\beta}
   559 |  *  \right) \f$
   560 |  *
   561 |  * XCFunctional output (with k=1 and gamma-type derivatives):
   562 |  *
   563 |  * GGA: \f$ \left(F_{xc},
   564 |  *  \frac{\partial F_{xc}}{\partial \rho},
   565 |  *  \frac{\partial F_{xc}}{\partial \gamma} \f$
   566 |  *
   567 |  * Spin GGA: \f$ \left(F_{xc},
   568 |  *  \frac{\partial F_{xc}}{\partial \rho^\alpha},
   569 |  *  \frac{\partial F_{xc}}{\partial \rho^\beta },
   570 |  *  \frac{\partial F_{xc}}{\partial \gamma^{\alpha \alpha}},
   571 |  *  \frac{\partial F_{xc}}{\partial \gamma^{\alpha \beta }},
   572 |  *  \frac{\partial F_{xc}}{\partial \gamma^{\beta  \beta }}
   573 |  *  \right) \f$
   574 |  *
   575 |  * param[in] inp Input values
   576 |  * param[out] xcNodes Output values
   577 |  *
   578 |  */
   579 | void Functional::makepot(mrcpp::FunctionTreeVector<3> &inp, std::vector<mrcpp::FunctionNode<3> *> xcNodes)  const {
   580 |     if (this->log_grad){
   581 |         MSG_ERROR("log_grad not implemented");
   582 |     }
   583 | 
   584 |     mrcpp::NodeIndex<3> nodeIdx = xcNodes[0]->getNodeIndex();
   585 |     mrcpp::FunctionTree<3>* rho0=std::get<1>(inp[0]);
   586 |     mrcpp::MWNode<3> node(rho0->getNode(nodeIdx),true,false); //copy node from rho, but do not copy coef
   587 |     int ncoefs = rho0->getTDim() * rho0->getKp1_d();
   588 |     int xcfun_inpsize = 1; // rho
   589 |     int spinsize = 1; // paired
   590 |     if (isSpin()) spinsize = 2; // alpha, beta
   591 |     xcfun_inpsize *= spinsize; // alpha and beta
   592 |     if (isGGA()) xcfun_inpsize *= 4; // add gradient (3 components for each spin)
   593 | 
   594 |     Eigen::MatrixXd xcfun_inp(ncoefs, xcfun_inpsize); //input for xcfun
   595 |     double* coef = node.getCoefs();
   596 | 
   597 |     for (int i = 0; i < spinsize; i++) {
   598 |         // make cv representation of density
   599 |         mrcpp::FunctionTree<3>* rho=std::get<1>(inp[i]);
   600 |         // we link into the node, in order to be able to do a mwtransform without copying the data back and forth
   601 |         node.attachCoefs(xcfun_inp.col(i).data());
   602 |         for (int j = 0; j < ncoefs; j++) xcfun_inp(j,i) = rho->getNode(nodeIdx).getCoefs()[j];
   603 |         node.mwTransform(mrcpp::Reconstruction);
   604 |         node.cvTransform(mrcpp::Forward);
   605 | 
   606 |         if (isGGA()) {
   607 |             //make gradient of input
   608 |             for (int d = 0; d < 3; d++) {
   609 |                 node.attachCoefs(xcfun_inp.col(spinsize + 3*i + d).data());
   610 | 
   611 |                 mrcpp::DerivativeCalculator<3> derivcalc(d, *this->derivOp, *rho);
   612 |                 // derive rho and put result into xcfun_inp aka node
   613 |                 derivcalc.calcNode(rho->getNode(nodeIdx), node);
   614 |                 // make cv representation of gradient of density
   615 |                 node.mwTransform(mrcpp::Reconstruction);
   616 |                 node.cvTransform(mrcpp::Forward);
   617 |             }
   618 |        }
   619 |     }
   620 | 
   621 |     // send rho and grad rho to xcfun
   622 |     Eigen::MatrixXd xc_out = Functional::evaluate_transposed(xcfun_inp);
   623 | 
   624 |     // make gradient of the higher order densities
   625 |     //order:
   626 |     // rho_a_1
   627 |     // rho_b_1
   628 |     // drho_a_1/dx
   629 |     // drho_a_1/dy
   630 |     // drho_a_1/dz
   631 |     // drho_b_1/dx
   632 |     // drho_b_1/dy
   633 |     // drho_b_1/dz
   634 |     int ctrsize = inp.size()-spinsize; //number of higher order inputs
   635 |     int d_datasize = ctrsize;
   636 |     if (isGGA()) d_datasize *= 4; // add gradient (3 components for each higher order rho)
   637 |     Eigen::MatrixXd d_data = Eigen::MatrixXd::Zero(ncoefs, d_datasize);
   638 |     if (d_datasize > 0) {
   639 |         for (int i = 0; i < ctrsize; i++) {
   640 |             // make cv representation of density
   641 |             mrcpp::FunctionTree<3>* rho = std::get<1>(inp[i+spinsize]);
   642 |             // we link into the node, in order to be able to do a mwtransform without copying the data back and forth
   643 |             node.attachCoefs(d_data.col(i).data());
   644 |             for (int j = 0; j < ncoefs; j++) d_data(j,i) = rho->getNode(nodeIdx).getCoefs()[j];
   645 |             node.mwTransform(mrcpp::Reconstruction);
   646 |             node.cvTransform(mrcpp::Forward);
   647 |             if (isGGA()) {
   648 |                 //make gradient of input
   649 |                 for (int d = 0; d < 3; d++) {
   650 |                     node.attachCoefs(d_data.col(ctrsize + 3*i + d).data());
   651 |                     mrcpp::DerivativeCalculator<3> derivcalc(d, *this->derivOp, *rho);
   652 |                     derivcalc.calcNode(rho->getNode(nodeIdx), node);
   653 |                     // make cv representation of gradient of density
   654 |                     node.mwTransform(mrcpp::Reconstruction);
   655 |                     node.cvTransform(mrcpp::Forward);
   656 |                 }
   657 |             }
   658 |         }
   659 |     }
   660 | 
   661 |     Eigen::MatrixXd Ctrout = contract_transposed(xc_out, d_data); //size output: LDA=1, GGA=4, spin *2
   662 | 
   663 |     // postprocess
   664 |     //For SpinGGA:
   665 |     //f_xc         : out[0] = inp[0]
   666 |     //df_xc/drho_a : out[1] = inp[1] - div(inp[3,4,5])
   667 |     //df_xc/drho_b : out[2] = inp[2] - div(inp[6,7,8])
   668 |     int xc_outsize = 2;
   669 |     if (isSpin()) xc_outsize = 3;
   670 |     for (int i = 0; i < xc_outsize; i++) {
   671 |         // from cv to node values
   672 |         node.attachCoefs(Ctrout.col(i).data());
   673 |         node.cvTransform(mrcpp::Backward);
   674 |         node.mwTransform(mrcpp::Compression);
   675 |         for (int j = 0; j < ncoefs; j++) xcNodes[i]->getCoefs()[j] = Ctrout(j,i);
   676 |         xcNodes[i]->setHasCoefs();
   677 |         if (isGGA() and i>0) {
   678 |             for (int d = 0; d < 3; d++) {
   679 |                 node.attachCoefs(Ctrout.col(xc_outsize + 3*(i-1) + d).data());
   680 |                 node.cvTransform(mrcpp::Backward);
   681 |                 node.mwTransform(mrcpp::Compression);
   682 |                 mrcpp::DerivativeCalculator<3> derivcalc(d,*this->derivOp, *rho0);//TODO: define outside loops
   683 |                 mrcpp::MWNode<3> noded(rho0->getNode(nodeIdx),true,false);
   684 |                 derivcalc.calcNode(node, noded);
   685 |                 //xcNodes[i] = Ctrout[i] - div(Ctrout[d_i])
   686 |                 for (int j = 0; j < ncoefs; j++) xcNodes[i]->getCoefs()[j] -= noded.getCoefs()[j];
   687 |             }
   688 |         }
   689 |     }
   690 |     node.attachCoefs(coef); // restablish the original link (for proper destructor behaviour)
   691 | }
   692 | } // namespace mrdft
   693 | 
   694 | ===== END src/mrdft/Functional.cpp =====
   695 | 
   696 | ===== BEGIN src/mrdft/Factory.h =====
   697 | /*
   698 |  * MRChem, a numerical real-space code for molecular electronic structure
   699 |  * calculations within the self-consistent field (SCF) approximations of quantum
   700 |  * chemistry (Hartree-Fock and Density Functional Theory).
   701 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
   702 |  *
   703 |  * This file is part of MRChem.
   704 |  *
   705 |  * MRChem is free software: you can redistribute it and/or modify
   706 |  * it under the terms of the GNU Lesser General Public License as published by
   707 |  * the Free Software Foundation, either version 3 of the License, or
   708 |  * (at your option) any later version.
   709 |  *
   710 |  * MRChem is distributed in the hope that it will be useful,
   711 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
   712 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   713 |  * GNU Lesser General Public License for more details.
   714 |  *
   715 |  * You should have received a copy of the GNU Lesser General Public License
   716 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
   717 |  *
   718 |  * For information on the complete list of contributors to MRChem, see:
   719 |  * <https://mrchem.readthedocs.io/>
   720 |  */
   721 | 
   722 | #pragma once
   723 | 
   724 | #include <MRCPP/MWOperators>
   725 | #include <XCFun/xcfun.h>
   726 | 
   727 | #include "MRDFT.h"
   728 | 
   729 | namespace mrdft {
   730 | 
   731 | class Factory final {
   732 | public:
   733 |     Factory(const mrcpp::MultiResolutionAnalysis<3> &MRA);
   734 |     ~Factory() = default;
   735 | 
   736 |     void setSpin(bool s) { spin = s; }
   737 |     void setOrder(int k) { order = k; }
   738 |     void setUseGamma(bool g) { gamma = g; }
   739 |     void setLogGradient(bool lg) { log_grad = lg; }
   740 |     void setDensityCutoff(double c) { cutoff = c; }
   741 |     void setDerivative(const std::string &n) { diff_s = n; }
   742 |     void setFunctional(const std::string &n, double c = 1.0) { xcfun_set(xcfun_p.get(), n.c_str(), c); }
   743 | 
   744 |     std::unique_ptr<MRDFT> build();
   745 | 
   746 | private:
   747 |     int order{1};
   748 |     bool spin{false};
   749 |     bool gamma{false};
   750 |     bool log_grad{false};
   751 |     double cutoff{-1.0};
   752 |     std::string diff_s{"abgv_00"};
   753 |     const mrcpp::MultiResolutionAnalysis<3> mra;
   754 | 
   755 |     XC_p xcfun_p;
   756 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> diff_p;
   757 | };
   758 | 
   759 | } // namespace mrdft
   760 | 
   761 | ===== END src/mrdft/Factory.h =====
   762 | 
   763 | ===== BEGIN src/mrdft/Factory.cpp =====
   764 | /*
   765 |  * MRChem, a numerical real-space code for molecular electronic structure
   766 |  * calculations within the self-consistent field (SCF) approximations of quantum
   767 |  * chemistry (Hartree-Fock and Density Functional Theory).
   768 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
   769 |  *
   770 |  * This file is part of MRChem.
   771 |  *
   772 |  * MRChem is free software: you can redistribute it and/or modify
   773 |  * it under the terms of the GNU Lesser General Public License as published by
   774 |  * the Free Software Foundation, either version 3 of the License, or
   775 |  * (at your option) any later version.
   776 |  *
   777 |  * MRChem is distributed in the hope that it will be useful,
   778 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
   779 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   780 |  * GNU Lesser General Public License for more details.
   781 |  *
   782 |  * You should have received a copy of the GNU Lesser General Public License
   783 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
   784 |  *
   785 |  * For information on the complete list of contributors to MRChem, see:
   786 |  * <https://mrchem.readthedocs.io/>
   787 |  */
   788 | 
   789 | #include "Factory.h"
   790 | 
   791 | #include <MRCPP/MWOperators>
   792 | #include <MRCPP/Printer>
   793 | #include <XCFun/xcfun.h>
   794 | 
   795 | #include "GGA.h"
   796 | #include "Grid.h"
   797 | #include "LDA.h"
   798 | #include "MRDFT.h"
   799 | #include "SpinGGA.h"
   800 | #include "SpinLDA.h"
   801 | 
   802 | namespace mrdft {
   803 | 
   804 | Factory::Factory(const mrcpp::MultiResolutionAnalysis<3> &MRA)
   805 |         : mra(MRA)
   806 |         , xcfun_p(xcfun_new(), xcfun_delete) {}
   807 | 
   808 | /** @brief Build a MRDFT object from the currently defined parameters */
   809 | std::unique_ptr<MRDFT> Factory::build() {
   810 |     // Init DFT grid
   811 |     auto grid_p = std::make_unique<Grid>(mra);
   812 | 
   813 |     // Init XCFun
   814 |     bool gga = xcfun_is_gga(xcfun_p.get());
   815 |     bool lda = not(gga);
   816 |     unsigned int mode = 1;                    //!< only partial derivative mode implemented
   817 |     unsigned int func_type = (gga) ? 1 : 0;   //!< only LDA and GGA supported for now
   818 |     unsigned int dens_type = 1 + spin;        //!< only n (dens_type = 1) or alpha & beta (denst_type = 2) supported now.
   819 |     unsigned int laplacian = 0;               //!< no laplacian
   820 |     unsigned int kinetic = 0;                 //!< no kinetic energy density
   821 |     unsigned int current = 0;                 //!< no current density
   822 |     unsigned int exp_derivative = not(gamma); //!< use gamma or explicit derivatives
   823 |     if (not(gga)) exp_derivative = 0;         //!< fall back to gamma-type derivatives if LDA
   824 |     xcfun_user_eval_setup(xcfun_p.get(), order, func_type, dens_type, mode, laplacian, kinetic, current, exp_derivative);
   825 | 
   826 |     // Init MW derivative
   827 |     if (gga) {
   828 |         if (diff_s == "bspline") diff_p = std::make_unique<mrcpp::BSOperator<3>>(mra, 1);
   829 |         if (diff_s == "abgv_00") diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.0, 0.0);
   830 |         if (diff_s == "abgv_55") diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.5, 0.5);
   831 |     }
   832 | 
   833 |     // Init XC functional
   834 |     std::unique_ptr<Functional> func_p{nullptr};
   835 |     if (spin) {
   836 |         if (gga) func_p = std::make_unique<SpinGGA>(order, xcfun_p, diff_p);
   837 |         if (lda) func_p = std::make_unique<SpinLDA>(order, xcfun_p);
   838 |     } else {
   839 |         if (gga) func_p = std::make_unique<GGA>(order, xcfun_p, diff_p);
   840 |         if (lda) func_p = std::make_unique<LDA>(order, xcfun_p);
   841 |     }
   842 |     if (func_p == nullptr) MSG_ABORT("Invalid functional type");
   843 |     diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.0, 0.0);
   844 |     func_p->setDerivOp(diff_p);
   845 |     func_p->setLogGradient(log_grad);
   846 |     func_p->setDensityCutoff(cutoff);
   847 | 
   848 |     auto mrdft_p = std::make_unique<MRDFT>(grid_p, func_p);
   849 |     return mrdft_p;
   850 | }
   851 | 
   852 | } // namespace mrdft
   853 | 
   854 | ===== END src/mrdft/Factory.cpp =====
   855 | 
   856 | ===== BEGIN src/mrdft/LDA.h =====
   857 | /*
   858 |  * MRChem, a numerical real-space code for molecular electronic structure
   859 |  * calculations within the self-consistent field (SCF) approximations of quantum
   860 |  * chemistry (Hartree-Fock and Density Functional Theory).
   861 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
   862 |  *
   863 |  * This file is part of MRChem.
   864 |  *
   865 |  * MRChem is free software: you can redistribute it and/or modify
   866 |  * it under the terms of the GNU Lesser General Public License as published by
   867 |  * the Free Software Foundation, either version 3 of the License, or
   868 |  * (at your option) any later version.
   869 |  *
   870 |  * MRChem is distributed in the hope that it will be useful,
   871 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
   872 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   873 |  * GNU Lesser General Public License for more details.
   874 |  *
   875 |  * You should have received a copy of the GNU Lesser General Public License
   876 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
   877 |  *
   878 |  * For information on the complete list of contributors to MRChem, see:
   879 |  * <https://mrchem.readthedocs.io/>
   880 |  */
   881 | 
   882 | #pragma once
   883 | 
   884 | #include <XCFun/xcfun.h>
   885 | 
   886 | #include "Functional.h"
   887 | 
   888 | namespace mrdft {
   889 | 
   890 | class LDA final : public Functional {
   891 | public:
   892 |     LDA(int k, XC_p &f);
   893 |     ~LDA() override = default;
   894 | 
   895 |     bool isSpin() const override { return false; }
   896 | 
   897 | private:
   898 |     mrcpp::FunctionTreeVector<3> rho;
   899 | 
   900 |     int getCtrInputLength() const override;
   901 |     int getCtrOutputLength() const override { return 2; }
   902 | 
   903 |     void clear() override;
   904 |     mrcpp::FunctionTreeVector<3> setupXCInput() override;
   905 |     mrcpp::FunctionTreeVector<3> setupCtrInput() override;
   906 | 
   907 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
   908 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
   909 | };
   910 | 
   911 | } // namespace mrdft
   912 | 
   913 | ===== END src/mrdft/LDA.h =====
   914 | 
   915 | ===== BEGIN src/mrdft/LDA.cpp =====
   916 | /*
   917 |  * MRChem, a numerical real-space code for molecular electronic structure
   918 |  * calculations within the self-consistent field (SCF) approximations of quantum
   919 |  * chemistry (Hartree-Fock and Density Functional Theory).
   920 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
   921 |  *
   922 |  * This file is part of MRChem.
   923 |  *
   924 |  * MRChem is free software: you can redistribute it and/or modify
   925 |  * it under the terms of the GNU Lesser General Public License as published by
   926 |  * the Free Software Foundation, either version 3 of the License, or
   927 |  * (at your option) any later version.
   928 |  *
   929 |  * MRChem is distributed in the hope that it will be useful,
   930 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
   931 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   932 |  * GNU Lesser General Public License for more details.
   933 |  *
   934 |  * You should have received a copy of the GNU Lesser General Public License
   935 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
   936 |  *
   937 |  * For information on the complete list of contributors to MRChem, see:
   938 |  * <https://mrchem.readthedocs.io/>
   939 |  */
   940 | 
   941 | #include "MRCPP/MWFunctions"
   942 | #include "MRCPP/Printer"
   943 | 
   944 | #include "LDA.h"
   945 | #include "xc_utils.h"
   946 | 
   947 | namespace mrdft {
   948 | 
   949 | LDA::LDA(int k, XC_p &f)
   950 |         : Functional(k, f) {
   951 |     xc_mask = xc_utils::build_output_mask(true, false, this->order);
   952 |     d_mask = xc_utils::build_density_mask(true, false, this->order);
   953 | }
   954 | 
   955 | /** @brief Clear internal functions
   956 |  *
   957 |  * Ownership of densities is outside MRDFT -> clear
   958 |  * Ownership of gradients is inside MRDFT -> free
   959 |  */
   960 | void LDA::clear() {
   961 |     mrcpp::clear(this->rho, false);
   962 | }
   963 | 
   964 | /** @brief Number of function involved in contraction step */
   965 | int LDA::getCtrInputLength() const {
   966 |     int length = -1;
   967 |     if (this->order < 2) length = 0;
   968 |     if (this->order == 2) length = 1;
   969 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
   970 |     return length;
   971 | }
   972 | 
   973 | /** @brief Collect input functions to xcfun evaluation step
   974 |  *
   975 |  * For LDA : [rho_0]
   976 |  */
   977 | mrcpp::FunctionTreeVector<3> LDA::setupXCInput() {
   978 |     if (this->rho.size() < 1) MSG_ERROR("Density not initialized");
   979 |     mrcpp::FunctionTreeVector<3> out_vec;
   980 |     out_vec.push_back(this->rho[0]);
   981 |     return out_vec;
   982 | }
   983 | 
   984 | /** @brief Collect input functions to contraction step
   985 |  *
   986 |  * For LDA:
   987 |  * Ground State: No contraction, empty vector
   988 |  * Linear Response: [rho_1]
   989 |  * Higher Response: NOT_IMPLEMENTED
   990 |  */
   991 | mrcpp::FunctionTreeVector<3> LDA::setupCtrInput() {
   992 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
   993 |     mrcpp::FunctionTreeVector<3> out_vec;
   994 |     if (order == 2) out_vec.push_back(this->rho[1]);
   995 |     return out_vec;
   996 | }
   997 | 
   998 | /** @brief Prepare input functions to xcfun
   999 |  *
  1000 |  * Collects input densities and computes necessary gradients.
  1001 |  *
  1002 |  * Ordering of input:
  1003 |  * inp_vec[0] = alpha_0
  1004 |  * inp_vec[1] = beta_0
  1005 |  * inp_vec[2] = alpha_1
  1006 |  * inp_vec[3] = beta_1
  1007 |  * ...
  1008 |  */
  1009 | void LDA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1010 |     if (inp_vec.size() != this->order) MSG_ERROR("Invalid input length");
  1011 |     if (this->rho.size() > 0) MSG_ERROR("Density not empty");
  1012 | 
  1013 |     for (auto i = 0; i < this->order; i++) this->rho.push_back(inp_vec[i]);
  1014 | }
  1015 | 
  1016 | /** @brief Compute final output functions
  1017 |  *
  1018 |  * Combine the raw partial derivatives from xcfun into functional derivatives.
  1019 |  *
  1020 |  * For LDA:
  1021 |  * f_xc       : out[0] = inp[0]
  1022 |  * df_xc/drho : out[1] = inp[1]
  1023 |  */
  1024 | mrcpp::FunctionTreeVector<3> LDA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1025 |     // Energy density
  1026 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
  1027 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1028 | 
  1029 |     // XC potential
  1030 |     mrcpp::FunctionTree<3> &v_xc = mrcpp::get_func(inp_vec, 1);
  1031 |     inp_vec[1] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1032 | 
  1033 |     mrcpp::FunctionTreeVector<3> out_vec;
  1034 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
  1035 |     out_vec.push_back(std::make_tuple(1.0, &v_xc));
  1036 |     return out_vec;
  1037 | }
  1038 | 
  1039 | } // namespace mrdft
  1040 | 
  1041 | ===== END src/mrdft/LDA.cpp =====
  1042 | 
  1043 | ===== BEGIN src/mrdft/GGA.h =====
  1044 | /*
  1045 |  * MRChem, a numerical real-space code for molecular electronic structure
  1046 |  * calculations within the self-consistent field (SCF) approximations of quantum
  1047 |  * chemistry (Hartree-Fock and Density Functional Theory).
  1048 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1049 |  *
  1050 |  * This file is part of MRChem.
  1051 |  *
  1052 |  * MRChem is free software: you can redistribute it and/or modify
  1053 |  * it under the terms of the GNU Lesser General Public License as published by
  1054 |  * the Free Software Foundation, either version 3 of the License, or
  1055 |  * (at your option) any later version.
  1056 |  *
  1057 |  * MRChem is distributed in the hope that it will be useful,
  1058 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  1059 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1060 |  * GNU Lesser General Public License for more details.
  1061 |  *
  1062 |  * You should have received a copy of the GNU Lesser General Public License
  1063 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  1064 |  *
  1065 |  * For information on the complete list of contributors to MRChem, see:
  1066 |  * <https://mrchem.readthedocs.io/>
  1067 |  */
  1068 | 
  1069 | #pragma once
  1070 | 
  1071 | #include <XCFun/xcfun.h>
  1072 | 
  1073 | #include "Functional.h"
  1074 | 
  1075 | namespace mrdft {
  1076 | 
  1077 | class GGA final : public Functional {
  1078 | public:
  1079 |     GGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d);
  1080 |     ~GGA() override = default;
  1081 | 
  1082 |     bool isSpin() const override { return false; }
  1083 | 
  1084 | private:
  1085 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> derivative{nullptr};
  1086 |     mrcpp::FunctionTreeVector<3> rho;
  1087 |     mrcpp::FunctionTreeVector<3> grad;
  1088 | 
  1089 |     int getCtrInputLength() const override;
  1090 |     int getCtrOutputLength() const override { return 5; }
  1091 | 
  1092 |     void clear() override;
  1093 |     virtual mrcpp::FunctionTreeVector<3> setupXCInput() override;
  1094 |     virtual mrcpp::FunctionTreeVector<3> setupCtrInput() override;
  1095 | 
  1096 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
  1097 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
  1098 | };
  1099 | 
  1100 | } // namespace mrdft
  1101 | 
  1102 | ===== END src/mrdft/GGA.h =====
  1103 | 
  1104 | ===== BEGIN src/mrdft/GGA.cpp =====
  1105 | /*
  1106 |  * MRChem, a numerical real-space code for molecular electronic structure
  1107 |  * calculations within the self-consistent field (SCF) approximations of quantum
  1108 |  * chemistry (Hartree-Fock and Density Functional Theory).
  1109 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1110 |  *
  1111 |  * This file is part of MRChem.
  1112 |  *
  1113 |  * MRChem is free software: you can redistribute it and/or modify
  1114 |  * it under the terms of the GNU Lesser General Public License as published by
  1115 |  * the Free Software Foundation, either version 3 of the License, or
  1116 |  * (at your option) any later version.
  1117 |  *
  1118 |  * MRChem is distributed in the hope that it will be useful,
  1119 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  1120 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1121 |  * GNU Lesser General Public License for more details.
  1122 |  *
  1123 |  * You should have received a copy of the GNU Lesser General Public License
  1124 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  1125 |  *
  1126 |  * For information on the complete list of contributors to MRChem, see:
  1127 |  * <https://mrchem.readthedocs.io/>
  1128 | 
  1129 |  */
  1130 | #include "MRCPP/MWOperators"
  1131 | #include "MRCPP/Printer"
  1132 | 
  1133 | #include "GGA.h"
  1134 | #include "xc_utils.h"
  1135 | 
  1136 | namespace mrdft {
  1137 | 
  1138 | GGA::GGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d)
  1139 |         : Functional(k, f)
  1140 |         , derivative(std::move(d)) {
  1141 |     xc_mask = xc_utils::build_output_mask(false, false, this->order);
  1142 |     d_mask = xc_utils::build_density_mask(false, false, this->order);
  1143 | }
  1144 | 
  1145 | /** @brief Clear internal functions
  1146 |  *
  1147 |  * Ownership of densities is outside MRDFT -> clear
  1148 |  * Ownership of gradients is inside MRDFT -> free
  1149 |  */
  1150 | void GGA::clear() {
  1151 |     mrcpp::clear(this->rho, false);
  1152 |     mrcpp::clear(this->grad, true);
  1153 | }
  1154 | 
  1155 | /** @brief Number of function involved in contraction step */
  1156 | int GGA::getCtrInputLength() const {
  1157 |     int length = -1;
  1158 |     if (this->order < 2) length = 0;
  1159 |     if (this->order == 2) length = 4;
  1160 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
  1161 |     return length;
  1162 | }
  1163 | 
  1164 | /** @brief Collect input functions to xcfun evaluation step
  1165 |  *
  1166 |  * For GGA : [rho_0, grad(rho_0)]
  1167 |  */
  1168 | mrcpp::FunctionTreeVector<3> GGA::setupXCInput() {
  1169 |     if (this->rho.size() < 1) MSG_ERROR("Density not initialized");
  1170 |     if (this->grad.size() < 3) MSG_ERROR("Gradient not initialized");
  1171 | 
  1172 |     mrcpp::FunctionTreeVector<3> out_vec;
  1173 |     out_vec.push_back(this->rho[0]);
  1174 |     out_vec.insert(out_vec.end(), this->grad.begin(), this->grad.begin() + 3);
  1175 |     return out_vec;
  1176 | }
  1177 | 
  1178 | /** @brief Collect input functions to contraction step
  1179 |  *
  1180 |  * For GGA:
  1181 |  * Ground State: No contraction, empty vector
  1182 |  * Linear Response: [rho_1, grad(rho_1)]
  1183 |  * Higher Response: NOT_IMPLEMENTED
  1184 |  */
  1185 | mrcpp::FunctionTreeVector<3> GGA::setupCtrInput() {
  1186 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
  1187 |     mrcpp::FunctionTreeVector<3> out_vec;
  1188 |     if (this->order == 2) {
  1189 |         out_vec.push_back(this->rho[1]);
  1190 |         out_vec.insert(out_vec.end(), this->grad.begin() + 3, this->grad.begin() + 6);
  1191 |     }
  1192 |     return out_vec;
  1193 | }
  1194 | 
  1195 | /** @brief Prepare input functions to xcfun
  1196 |  *
  1197 |  * Collects input densities and computes necessary gradients.
  1198 |  *
  1199 |  * Ordering of input:
  1200 |  * inp_vec[0] = alpha_0
  1201 |  * inp_vec[1] = beta_0
  1202 |  * inp_vec[2] = alpha_1
  1203 |  * inp_vec[3] = beta_1
  1204 |  * ...
  1205 |  */
  1206 | void GGA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1207 |     if (inp_vec.size() != this->order) MSG_ERROR("Invalid input length");
  1208 |     if (this->rho.size() > 0) MSG_ERROR("Density not empty");
  1209 |     if (this->grad.size() > 0) MSG_ERROR("Gradient not empty");
  1210 | 
  1211 |     int n = 0;
  1212 |     for (int i = 0; i < this->order; i++) this->rho.push_back(inp_vec[n++]);
  1213 | 
  1214 |     for (int i = 0; i < this->order; i++) {
  1215 |         mrcpp::FunctionTreeVector<3> tmp;
  1216 |         if (this->log_grad and i == 0) {
  1217 |             tmp = xc_utils::log_gradient(*this->derivative, mrcpp::get_func(this->rho, i));
  1218 |         } else {
  1219 |             tmp = mrcpp::gradient(*this->derivative, mrcpp::get_func(this->rho, i));
  1220 |         }
  1221 |         this->grad.insert(this->grad.end(), tmp.begin(), tmp.end());
  1222 |     }
  1223 | }
  1224 | 
  1225 | /** @brief Compute final output functions
  1226 |  *
  1227 |  * Combine the raw partial derivatives from xcfun into functional derivatives.
  1228 |  *
  1229 |  * For GGA:
  1230 |  * f_xc       : out[0] = inp[0]
  1231 |  * df_xc/drho : out[1] = inp[1] - div(inp[2,3,4])
  1232 |  */
  1233 | mrcpp::FunctionTreeVector<3> GGA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1234 |     // Energy density
  1235 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
  1236 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1237 | 
  1238 |     // Potential part
  1239 |     mrcpp::FunctionTree<3> &df_dr = mrcpp::get_func(inp_vec, 1);
  1240 |     mrcpp::FunctionTreeVector<3> df_dg(inp_vec.begin() + 2, inp_vec.begin() + 5);
  1241 | 
  1242 |     auto *tmp = new mrcpp::FunctionTree<3>(df_dr.getMRA());
  1243 |     mrcpp::divergence(*tmp, *this->derivative, df_dg);
  1244 | 
  1245 |     auto *v_xc = new mrcpp::FunctionTree<3>(df_dr.getMRA());
  1246 |     mrcpp::build_grid(*v_xc, df_dr);
  1247 |     mrcpp::build_grid(*v_xc, *tmp);
  1248 |     mrcpp::add(-1.0, *v_xc, 1.0, df_dr, -1.0, *tmp);
  1249 |     delete tmp;
  1250 | 
  1251 |     // Collect output
  1252 |     mrcpp::FunctionTreeVector<3> out_vec;
  1253 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
  1254 |     out_vec.push_back(std::make_tuple(1.0, v_xc));
  1255 |     v_xc = nullptr;
  1256 | 
  1257 |     return out_vec;
  1258 | }
  1259 | 
  1260 | } // namespace mrdft
  1261 | 
  1262 | ===== END src/mrdft/GGA.cpp =====
  1263 | 
  1264 | ===== BEGIN src/mrdft/SpinLDA.h =====
  1265 | /*
  1266 |  * MRChem, a numerical real-space code for molecular electronic structure
  1267 |  * calculations within the self-consistent field (SCF) approximations of quantum
  1268 |  * chemistry (Hartree-Fock and Density Functional Theory).
  1269 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1270 |  *
  1271 |  * This file is part of MRChem.
  1272 |  *
  1273 |  * MRChem is free software: you can redistribute it and/or modify
  1274 |  * it under the terms of the GNU Lesser General Public License as published by
  1275 |  * the Free Software Foundation, either version 3 of the License, or
  1276 |  * (at your option) any later version.
  1277 |  *
  1278 |  * MRChem is distributed in the hope that it will be useful,
  1279 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  1280 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1281 |  * GNU Lesser General Public License for more details.
  1282 |  *
  1283 |  * You should have received a copy of the GNU Lesser General Public License
  1284 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  1285 |  *
  1286 |  * For information on the complete list of contributors to MRChem, see:
  1287 |  * <https://mrchem.readthedocs.io/>
  1288 |  */
  1289 | 
  1290 | #pragma once
  1291 | 
  1292 | #include <XCFun/xcfun.h>
  1293 | 
  1294 | #include "Functional.h"
  1295 | 
  1296 | namespace mrdft {
  1297 | 
  1298 | class SpinLDA final : public Functional {
  1299 | public:
  1300 |     SpinLDA(int k, XC_p &f);
  1301 |     ~SpinLDA() override = default;
  1302 | 
  1303 |     bool isSpin() const override { return true; }
  1304 | 
  1305 | private:
  1306 |     mrcpp::FunctionTreeVector<3> rho_a;
  1307 |     mrcpp::FunctionTreeVector<3> rho_b;
  1308 | 
  1309 |     int getCtrInputLength() const override;
  1310 |     int getCtrOutputLength() const override { return 3; }
  1311 | 
  1312 |     void clear() override;
  1313 |     virtual mrcpp::FunctionTreeVector<3> setupXCInput() override;
  1314 |     virtual mrcpp::FunctionTreeVector<3> setupCtrInput() override;
  1315 | 
  1316 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
  1317 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
  1318 | };
  1319 | 
  1320 | } // namespace mrdft
  1321 | 
  1322 | ===== END src/mrdft/SpinLDA.h =====
  1323 | 
  1324 | ===== BEGIN src/mrdft/SpinLDA.cpp =====
  1325 | /*
  1326 |  * MRChem, a numerical real-space code for molecular electronic structure
  1327 |  * calculations within the self-consistent field (SCF) approximations of quantum
  1328 |  * chemistry (Hartree-Fock and Density Functional Theory).
  1329 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1330 |  *
  1331 |  * This file is part of MRChem.
  1332 |  *
  1333 |  * MRChem is free software: you can redistribute it and/or modify
  1334 |  * it under the terms of the GNU Lesser General Public License as published by
  1335 |  * the Free Software Foundation, either version 3 of the License, or
  1336 |  * (at your option) any later version.
  1337 |  *
  1338 |  * MRChem is distributed in the hope that it will be useful,
  1339 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  1340 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1341 |  * GNU Lesser General Public License for more details.
  1342 |  *
  1343 |  * You should have received a copy of the GNU Lesser General Public License
  1344 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  1345 |  *
  1346 |  * For information on the complete list of contributors to MRChem, see:
  1347 |  * <https://mrchem.readthedocs.io/>
  1348 |  */
  1349 | 
  1350 | #include "MRCPP/MWFunctions"
  1351 | #include "MRCPP/Printer"
  1352 | 
  1353 | #include "SpinLDA.h"
  1354 | #include "xc_utils.h"
  1355 | 
  1356 | namespace mrdft {
  1357 | 
  1358 | SpinLDA::SpinLDA(int k, XC_p &f)
  1359 |         : Functional(k, f) {
  1360 |     xc_mask = xc_utils::build_output_mask(true, true, this->order);
  1361 |     d_mask = xc_utils::build_density_mask(true, true, this->order);
  1362 | }
  1363 | 
  1364 | /** @brief Clear internal functions
  1365 |  *
  1366 |  * Ownership of densities is outside MRDFT -> clear
  1367 |  * Ownership of gradients is inside MRDFT -> free
  1368 |  */
  1369 | void SpinLDA::clear() {
  1370 |     mrcpp::clear(this->rho_a, false);
  1371 |     mrcpp::clear(this->rho_b, false);
  1372 | }
  1373 | 
  1374 | /** @brief Number of function involved in contraction step */
  1375 | int SpinLDA::getCtrInputLength() const {
  1376 |     int length = -1;
  1377 |     if (this->order < 2) length = 0;
  1378 |     if (this->order == 2) length = 2;
  1379 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
  1380 |     return length;
  1381 | }
  1382 | 
  1383 | /** @brief Collect input functions to xcfun evaluation step
  1384 |  *
  1385 |  * For SpinLDA : [alpha_0, beta_0]
  1386 |  */
  1387 | mrcpp::FunctionTreeVector<3> SpinLDA::setupXCInput() {
  1388 |     if (this->rho_a.size() < 1) MSG_ERROR("Alpha density not initialized");
  1389 |     if (this->rho_b.size() < 1) MSG_ERROR("Beta density not initialized");
  1390 | 
  1391 |     mrcpp::FunctionTreeVector<3> out_vec;
  1392 |     out_vec.push_back(this->rho_a[0]);
  1393 |     out_vec.push_back(this->rho_b[0]);
  1394 |     return out_vec;
  1395 | }
  1396 | 
  1397 | /** @brief Collect input functions to contraction step
  1398 |  *
  1399 |  * For SpinLDA:
  1400 |  * Ground State: No contraction, empty vector
  1401 |  * Linear Response: [alpha_1, beta_1]
  1402 |  * Higher Response: NOT_IMPLEMENTED
  1403 |  */
  1404 | mrcpp::FunctionTreeVector<3> SpinLDA::setupCtrInput() {
  1405 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
  1406 |     mrcpp::FunctionTreeVector<3> out_vec;
  1407 |     if (order == 2) {
  1408 |         out_vec.push_back(this->rho_a[1]);
  1409 |         out_vec.push_back(this->rho_b[1]);
  1410 |     }
  1411 |     return out_vec;
  1412 | }
  1413 | 
  1414 | /** @brief Prepare input functions to xcfun
  1415 |  *
  1416 |  * Collects input densities and computes necessary gradients.
  1417 |  *
  1418 |  * Ordering of input:
  1419 |  * inp_vec[0] = alpha_0
  1420 |  * inp_vec[1] = beta_0
  1421 |  * inp_vec[2] = alpha_1
  1422 |  * inp_vec[3] = beta_1
  1423 |  * ...
  1424 |  */
  1425 | void SpinLDA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1426 |     if (inp_vec.size() != 2 * this->order) MSG_ERROR("Invalid input length");
  1427 |     if (this->rho_a.size() > 0) MSG_ERROR("Alpha density not empty");
  1428 |     if (this->rho_b.size() > 0) MSG_ERROR("Beta density not empty");
  1429 | 
  1430 |     int n = 0;
  1431 |     for (int i = 0; i < this->order; i++) {
  1432 |         this->rho_a.push_back(inp_vec[n++]);
  1433 |         this->rho_b.push_back(inp_vec[n++]);
  1434 |     }
  1435 | }
  1436 | 
  1437 | /** @brief Compute final output functions
  1438 |  *
  1439 |  * Combine the raw partial derivatives from xcfun into functional derivatives.
  1440 |  *
  1441 |  * For SpinLDA:
  1442 |  * f_xc         : out[0] = inp[0]
  1443 |  * df_xc/drho_a : out[1] = inp[1]
  1444 |  * df_xc/drho_b : out[2] = inp[2]
  1445 |  */
  1446 | mrcpp::FunctionTreeVector<3> SpinLDA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1447 |     // Energy density
  1448 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
  1449 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1450 | 
  1451 |     // Alpha potential
  1452 |     mrcpp::FunctionTree<3> &v_a = mrcpp::get_func(inp_vec, 1);
  1453 |     inp_vec[1] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1454 | 
  1455 |     // Beta potential
  1456 |     mrcpp::FunctionTree<3> &v_b = mrcpp::get_func(inp_vec, 2);
  1457 |     inp_vec[2] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1458 | 
  1459 |     // Collect output
  1460 |     mrcpp::FunctionTreeVector<3> out_vec;
  1461 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
  1462 |     out_vec.push_back(std::make_tuple(1.0, &v_a));
  1463 |     out_vec.push_back(std::make_tuple(1.0, &v_b));
  1464 |     return out_vec;
  1465 | }
  1466 | } // namespace mrdft
  1467 | 
  1468 | ===== END src/mrdft/SpinLDA.cpp =====
  1469 | 
  1470 | ===== BEGIN src/mrdft/SpinGGA.h =====
  1471 | /*
  1472 |  * MRChem, a numerical real-space code for molecular electronic structure
  1473 |  * calculations within the self-consistent field (SCF) approximations of quantum
  1474 |  * chemistry (Hartree-Fock and Density Functional Theory).
  1475 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1476 |  *
  1477 |  * This file is part of MRChem.
  1478 |  *
  1479 |  * MRChem is free software: you can redistribute it and/or modify
  1480 |  * it under the terms of the GNU Lesser General Public License as published by
  1481 |  * the Free Software Foundation, either version 3 of the License, or
  1482 |  * (at your option) any later version.
  1483 |  *
  1484 |  * MRChem is distributed in the hope that it will be useful,
  1485 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  1486 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1487 |  * GNU Lesser General Public License for more details.
  1488 |  *
  1489 |  * You should have received a copy of the GNU Lesser General Public License
  1490 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  1491 |  *
  1492 |  * For information on the complete list of contributors to MRChem, see:
  1493 |  * <https://mrchem.readthedocs.io/>
  1494 |  */
  1495 | 
  1496 | #pragma once
  1497 | 
  1498 | #include <XCFun/xcfun.h>
  1499 | 
  1500 | #include "Functional.h"
  1501 | 
  1502 | namespace mrdft {
  1503 | 
  1504 | class SpinGGA final : public Functional {
  1505 | public:
  1506 |     SpinGGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d);
  1507 |     ~SpinGGA() override = default;
  1508 | 
  1509 |     bool isSpin() const override { return true; }
  1510 | 
  1511 | private:
  1512 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> derivative{nullptr};
  1513 |     mrcpp::FunctionTreeVector<3> rho_a;
  1514 |     mrcpp::FunctionTreeVector<3> rho_b;
  1515 |     mrcpp::FunctionTreeVector<3> grad_a;
  1516 |     mrcpp::FunctionTreeVector<3> grad_b;
  1517 | 
  1518 |     int getCtrInputLength() const override;
  1519 |     int getCtrOutputLength() const override { return 9; }
  1520 | 
  1521 |     void clear() override;
  1522 |     virtual mrcpp::FunctionTreeVector<3> setupXCInput() override;
  1523 |     virtual mrcpp::FunctionTreeVector<3> setupCtrInput() override;
  1524 | 
  1525 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
  1526 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
  1527 | };
  1528 | 
  1529 | } // namespace mrdft
  1530 | 
  1531 | ===== END src/mrdft/SpinGGA.h =====
  1532 | 
  1533 | ===== BEGIN src/mrdft/SpinGGA.cpp =====
  1534 | /*
  1535 |  * MRChem, a numerical real-space code for molecular electronic structure
  1536 |  * calculations within the self-consistent field (SCF) approximations of quantum
  1537 |  * chemistry (Hartree-Fock and Density Functional Theory).
  1538 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1539 |  *
  1540 |  * This file is part of MRChem.
  1541 |  *
  1542 |  * MRChem is free software: you can redistribute it and/or modify
  1543 |  * it under the terms of the GNU Lesser General Public License as published by
  1544 |  * the Free Software Foundation, either version 3 of the License, or
  1545 |  * (at your option) any later version.
  1546 |  *
  1547 |  * MRChem is distributed in the hope that it will be useful,
  1548 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  1549 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1550 |  * GNU Lesser General Public License for more details.
  1551 |  *
  1552 |  * You should have received a copy of the GNU Lesser General Public License
  1553 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  1554 |  *
  1555 |  * For information on the complete list of contributors to MRChem, see:
  1556 |  * <https://mrchem.readthedocs.io/>
  1557 |  */
  1558 | 
  1559 | #include "MRCPP/MWOperators"
  1560 | #include "MRCPP/Printer"
  1561 | 
  1562 | #include "SpinGGA.h"
  1563 | #include "xc_utils.h"
  1564 | 
  1565 | namespace mrdft {
  1566 | 
  1567 | SpinGGA::SpinGGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d)
  1568 |         : Functional(k, f)
  1569 |         , derivative(std::move(d)) {
  1570 |     xc_mask = xc_utils::build_output_mask(false, true, this->order);
  1571 |     d_mask = xc_utils::build_density_mask(false, true, this->order);
  1572 | }
  1573 | 
  1574 | /** @brief Clear internal functions
  1575 |  *
  1576 |  * Ownership of densities is outside MRDFT -> clear
  1577 |  * Ownership of gradients is inside MRDFT -> free
  1578 |  */
  1579 | void SpinGGA::clear() {
  1580 |     mrcpp::clear(this->rho_a, false);
  1581 |     mrcpp::clear(this->rho_b, false);
  1582 |     mrcpp::clear(this->grad_a, true);
  1583 |     mrcpp::clear(this->grad_b, true);
  1584 | }
  1585 | 
  1586 | /** @brief Number of function involved in contraction step */
  1587 | int SpinGGA::getCtrInputLength() const {
  1588 |     int length = -1;
  1589 |     if (this->order < 2) length = 0;
  1590 |     if (this->order == 2) length = 8;
  1591 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
  1592 |     return length;
  1593 | }
  1594 | 
  1595 | /** @brief Collect input functions to xcfun evaluation step
  1596 |  *
  1597 |  * For SpinGGA : [alpha_0, beta_0, grad(alpha_0), grad(beta_0)]
  1598 |  */
  1599 | mrcpp::FunctionTreeVector<3> SpinGGA::setupXCInput() {
  1600 |     if (this->rho_a.size() < 1) MSG_ERROR("Alpha density not initialized");
  1601 |     if (this->rho_b.size() < 1) MSG_ERROR("Beta density not initialized");
  1602 |     if (this->grad_a.size() < 3) MSG_ERROR("Alpha gradient not initialized");
  1603 |     if (this->grad_b.size() < 3) MSG_ERROR("Beta gradient not initialized");
  1604 | 
  1605 |     mrcpp::FunctionTreeVector<3> out_vec;
  1606 |     out_vec.push_back(this->rho_a[0]);
  1607 |     out_vec.push_back(this->rho_b[0]);
  1608 |     out_vec.insert(out_vec.end(), this->grad_a.begin(), this->grad_a.begin() + 3);
  1609 |     out_vec.insert(out_vec.end(), this->grad_b.begin(), this->grad_b.begin() + 3);
  1610 |     return out_vec;
  1611 | }
  1612 | 
  1613 | /** @brief Collect input functions to contraction step
  1614 |  *
  1615 |  * For SpinGGA:
  1616 |  * Ground State: No contraction, empty vector
  1617 |  * Linear Response: [alpha_1, beta_1, grad(alpha_1), grad(beta_1)]
  1618 |  * Higher Response: NOT_IMPLEMENTED
  1619 |  */
  1620 | mrcpp::FunctionTreeVector<3> SpinGGA::setupCtrInput() {
  1621 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
  1622 |     mrcpp::FunctionTreeVector<3> out_vec;
  1623 |     if (this->order == 2) {
  1624 |         out_vec.push_back(this->rho_a[1]);
  1625 |         out_vec.push_back(this->rho_b[1]);
  1626 |         out_vec.insert(out_vec.end(), this->grad_a.begin() + 3, this->grad_a.begin() + 6);
  1627 |         out_vec.insert(out_vec.end(), this->grad_b.begin() + 3, this->grad_b.begin() + 6);
  1628 |     }
  1629 |     return out_vec;
  1630 | }
  1631 | 
  1632 | /** @brief Prepare input functions to xcfun
  1633 |  *
  1634 |  * Collects input densities and computes necessary gradients.
  1635 |  *
  1636 |  * Ordering of input:
  1637 |  * inp_vec[0] = alpha_0
  1638 |  * inp_vec[1] = beta_0
  1639 |  * inp_vec[2] = alpha_1
  1640 |  * inp_vec[3] = beta_1
  1641 |  * ...
  1642 |  */
  1643 | void SpinGGA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1644 |     if (inp_vec.size() != 2 * this->order) MSG_ERROR("Invalid input length");
  1645 |     if (this->rho_a.size() > 0) MSG_ERROR("Alpha density not empty");
  1646 |     if (this->rho_b.size() > 0) MSG_ERROR("Beta density not empty");
  1647 |     if (this->grad_a.size() > 0) MSG_ERROR("Alpha gradient not empty");
  1648 |     if (this->grad_b.size() > 0) MSG_ERROR("Beta gradient not empty");
  1649 | 
  1650 |     int n = 0;
  1651 |     for (int i = 0; i < this->order; i++) {
  1652 |         this->rho_a.push_back(inp_vec[n++]);
  1653 |         this->rho_b.push_back(inp_vec[n++]);
  1654 |     }
  1655 | 
  1656 |     for (int i = 0; i < this->order; i++) {
  1657 |         mrcpp::FunctionTreeVector<3> tmp_a, tmp_b;
  1658 |         if (this->log_grad and i == 0) {
  1659 |             tmp_a = xc_utils::log_gradient(*this->derivative, mrcpp::get_func(this->rho_a, i));
  1660 |             tmp_b = xc_utils::log_gradient(*this->derivative, mrcpp::get_func(this->rho_b, i));
  1661 |         } else {
  1662 |             tmp_a = mrcpp::gradient(*this->derivative, mrcpp::get_func(this->rho_a, i));
  1663 |             tmp_b = mrcpp::gradient(*this->derivative, mrcpp::get_func(this->rho_b, i));
  1664 |         }
  1665 |         this->grad_a.insert(this->grad_a.end(), tmp_a.begin(), tmp_a.end());
  1666 |         this->grad_b.insert(this->grad_b.end(), tmp_b.begin(), tmp_b.end());
  1667 |     }
  1668 | }
  1669 | 
  1670 | /** @brief Compute final output functions
  1671 |  *
  1672 |  * Combine the raw partial derivatives from xcfun into functional derivatives.
  1673 |  *
  1674 |  * For SpinGGA:
  1675 |  * f_xc         : out[0] = inp[0]
  1676 |  * df_xc/drho_a : out[1] = inp[1] - div(inp[3,4,5])
  1677 |  * df_xc/drho_b : out[2] = inp[2] - div(inp[6,7,8])
  1678 |  */
  1679 | mrcpp::FunctionTreeVector<3> SpinGGA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1680 |     // Energy density
  1681 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
  1682 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1683 | 
  1684 |     // Alpha part
  1685 |     mrcpp::FunctionTree<3> &df_da = mrcpp::get_func(inp_vec, 1);
  1686 |     mrcpp::FunctionTreeVector<3> df_dga(inp_vec.begin() + 3, inp_vec.begin() + 6);
  1687 | 
  1688 |     auto *tmp_a = new mrcpp::FunctionTree<3>(df_da.getMRA());
  1689 |     mrcpp::divergence(*tmp_a, *this->derivative, df_dga);
  1690 | 
  1691 |     auto *v_a = new mrcpp::FunctionTree<3>(df_da.getMRA());
  1692 |     mrcpp::build_grid(*v_a, df_da);
  1693 |     mrcpp::build_grid(*v_a, *tmp_a);
  1694 |     mrcpp::add(-1.0, *v_a, 1.0, df_da, -1.0, *tmp_a);
  1695 |     delete tmp_a;
  1696 | 
  1697 |     // Beta part
  1698 |     mrcpp::FunctionTree<3> &df_db = mrcpp::get_func(inp_vec, 2);
  1699 |     mrcpp::FunctionTreeVector<3> df_dgb(inp_vec.begin() + 6, inp_vec.begin() + 9);
  1700 | 
  1701 |     auto *tmp_b = new mrcpp::FunctionTree<3>(df_db.getMRA());
  1702 |     mrcpp::divergence(*tmp_b, *this->derivative, df_dgb);
  1703 | 
  1704 |     auto *v_b = new mrcpp::FunctionTree<3>(df_db.getMRA());
  1705 |     mrcpp::build_grid(*v_b, df_db);
  1706 |     mrcpp::build_grid(*v_b, *tmp_b);
  1707 |     mrcpp::add(-1.0, *v_b, 1.0, df_db, -1.0, *tmp_b);
  1708 |     delete tmp_b;
  1709 | 
  1710 |     // Collect output
  1711 |     mrcpp::FunctionTreeVector<3> out_vec;
  1712 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
  1713 |     out_vec.push_back(std::make_tuple(1.0, v_a));
  1714 |     out_vec.push_back(std::make_tuple(1.0, v_b));
  1715 |     v_a = nullptr;
  1716 |     v_b = nullptr;
  1717 | 
  1718 |     return out_vec;
  1719 | }
  1720 | 
  1721 | } // namespace mrdft
  1722 | 
  1723 | ===== END src/mrdft/SpinGGA.cpp =====
  1724 | 
  1725 | ===== MISSING src/qmoperators/xc_operator_lda.cpp =====
  1726 | 
  1727 | ===== MISSING src/qmoperators/xc_operator_blyp.cpp =====
  1728 | 
  1729 | ===== MISSING src/qmoperators/xc_hessian_lda.cpp =====
  1730 | 
  1731 | ===== MISSING src/qmoperators/xc_hessian_pbe.cpp =====
  1732 | 
  1733 | ===== BEGIN src/surface_forces/xcStress.h =====
  1734 | #pragma once
  1735 | 
  1736 | #include "mrchem.h"
  1737 | #include <Eigen/Core>
  1738 | #include "qmfunctions/Density.h"
  1739 | #include "qmfunctions/Orbital.h"
  1740 | #include "mrdft/MRDFT.h"
  1741 | #include <vector>
  1742 | #include "qmoperators/one_electron/NablaOperator.h"
  1743 | 
  1744 | namespace surface_force {
  1745 | 
  1746 | std::vector<Eigen::Matrix3d> xcLDAStress(std::unique_ptr<mrdft::MRDFT> &mrdft_p, Eigen::MatrixXd &rhoGrid);
  1747 | std::vector<Eigen::Matrix3d> xcLDASpinStress(std::unique_ptr<mrdft::MRDFT> &mrdft_p, Eigen::MatrixXd &rhoGridAlpha, Eigen::MatrixXd &rhoGridBeta);
  1748 | std::vector<Eigen::Matrix3d> xcGGAStress(std::unique_ptr<mrdft::MRDFT> &mrdft_p, Eigen::MatrixXd &rhoGrid, Eigen::MatrixXd &nablaRhoGrid);
  1749 | std::vector<Eigen::Matrix3d> xcGGASpinStress(std::unique_ptr<mrdft::MRDFT> &mrdft_p, Eigen::MatrixXd &rhoGridAlpha, Eigen::MatrixXd &rhoGridBeta, Eigen::MatrixXd &nablaRhoGridAlpha, Eigen::MatrixXd &nablaRhoGridBeta);
  1750 | std::vector<Eigen::Matrix3d> getXCStress(std::unique_ptr<mrdft::MRDFT> &mrdft_p, mrcpp::FunctionTreeVector<3> &xc_pots, std::shared_ptr<mrchem::OrbitalVector> phi, std::shared_ptr<mrchem::NablaOperator> nabla, Eigen::MatrixXd &gridPos, bool isOpenShell, double prec);
  1751 | 
  1752 | } // namespace surface_force
  1753 | 
  1754 | ===== END src/surface_forces/xcStress.h =====
  1755 | 
  1756 | ===== BEGIN src/surface_forces/xcStress.cpp =====
  1757 | #include "surface_forces/xcStress.h"
  1758 | 
  1759 | #include "qmfunctions/Density.h"
  1760 | #include "qmfunctions/Orbital.h"
  1761 | #include "mrdft/MRDFT.h"
  1762 | #include "qmfunctions/Density.h"
  1763 | #include "qmfunctions/density_utils.h"
  1764 | #include "qmoperators/one_electron/NablaOperator.h"
  1765 | 
  1766 | using namespace Eigen;
  1767 | using namespace mrchem;
  1768 | using namespace std;
  1769 | 
  1770 | namespace surface_force{
  1771 | 
  1772 | /**
  1773 |  * @brief Compute the exchange-correlation stress tensor for LDA functional
  1774 |  * 
  1775 |  * @param mrdft_p MRDFT object
  1776 |  * @param rhoGrid MatrixXd with density values, shape (nGrid, 1)
  1777 |  * @return std::vector<Eigen::Matrix3d> vector of 3x3 matrices with stress tensor at each grid point
  1778 |  */
  1779 | std::vector<Eigen::Matrix3d> xcLDAStress(unique_ptr<mrdft::MRDFT> &mrdft_p, Eigen::MatrixXd &rhoGrid){
  1780 |     int nGrid = rhoGrid.rows();
  1781 |     std::vector<Eigen::Matrix3d> out(nGrid);
  1782 |     Eigen::MatrixXd xcOUT =  mrdft_p->functional().evaluate_transposed(rhoGrid);
  1783 |     for (int i = 0; i < nGrid; i++) {
  1784 |         out[i] = Matrix3d::Zero();
  1785 |         for (int j = 0; j < 3; j++) {
  1786 |             out[i](j, j) = xcOUT(i, 0) - xcOUT(i, 1) * rhoGrid(i);
  1787 |         }
  1788 |     }
  1789 |     return out;
  1790 | }
  1791 | 
  1792 | /**
  1793 |  * @brief Compute the exchange-correlation stress tensor for LDA functional for open shell systems
  1794 |  * 
  1795 |  * @param mrdft_p MRDFT object
  1796 |  * @param rhoGridAlpha MatrixXd with alpha density values, shape (nGrid, 1)
  1797 |  * @param rhoGridBeta MatrixXd with beta density values, shape (nGrid, 1)
  1798 |  * @return std::vector<Eigen::Matrix3d> vector of 3x3 matrices with stress tensor at each grid point
  1799 |  */
  1800 | std::vector<Matrix3d> xcLDASpinStress(unique_ptr<mrdft::MRDFT> &mrdft_p, MatrixXd &rhoGridAlpha, MatrixXd &rhoGridBeta){
  1801 |     int nGrid = rhoGridAlpha.rows();
  1802 |     Eigen::MatrixXd inp(rhoGridAlpha.rows(), 2);
  1803 |     std::vector<Matrix3d> out = std::vector<Eigen::Matrix3d>(nGrid);
  1804 |     inp.col(0) = rhoGridAlpha.col(0);
  1805 |     inp.col(1) = rhoGridBeta.col(0);
  1806 |     Eigen::MatrixXd xc = mrdft_p->functional().evaluate_transposed(inp);
  1807 |     for (int i = 0; i < rhoGridAlpha.rows(); i++) {
  1808 |         out[i] = Matrix3d::Zero();
  1809 |         for (int j = 0; j < 3; j++) {
  1810 |             out[i](j, j) = xc(i, 0) - xc(i, 1) * rhoGridAlpha(i) - xc(i, 2) * rhoGridBeta(i);
  1811 |         }
  1812 |     }
  1813 |     return out;
  1814 | }
  1815 | 
  1816 | /**
  1817 |  * @brief Compute the exchange-correlation stress tensor for GGA functional
  1818 |  * 
  1819 |  * @param mrdft_p MRDFT object
  1820 |  * @param rhoGrid MatrixXd with density values, shape (nGrid, 1)
  1821 |  * @param nablaRhoGrid MatrixXd with gradient of density values, shape (nGrid, 3)
  1822 |  * @return std::vector<Eigen::Matrix3d> vector of 3x3 matrices with stress tensor at each grid point
  1823 |  */
  1824 | std::vector<Matrix3d> xcGGAStress(unique_ptr<mrdft::MRDFT> &mrdft_p, mrcpp::FunctionTreeVector<3> &xc_pots, MatrixXd &rhoGrid, MatrixXd &nablaRhoGrid, Eigen::MatrixXd &gridPos){
  1825 |     int nGrid = rhoGrid.rows();
  1826 |     Eigen::MatrixXd inp(rhoGrid.rows(), 4);
  1827 |     inp.col(0) = rhoGrid.col(0);
  1828 |     inp.col(1) = nablaRhoGrid.col(0);
  1829 |     inp.col(2) = nablaRhoGrid.col(1);
  1830 |     inp.col(3) = nablaRhoGrid.col(2);
  1831 |     Eigen::MatrixXd xcOUT =  mrdft_p->functional().evaluate_transposed(inp);
  1832 |     std::vector<Matrix3d> out(nGrid);
  1833 |     std::array<double, 3> pos;
  1834 |     for (int i = 0; i < rhoGrid.rows(); i++) {
  1835 |         out[i] = Matrix3d::Zero();
  1836 |         pos[0] = gridPos(i, 0);
  1837 |         pos[1] = gridPos(i, 1);
  1838 |         pos[2] = gridPos(i, 2);
  1839 |         for (int j = 0; j < 3; j++) {
  1840 |             out[i](j, j) = xcOUT(i, 0) - rhoGrid(i) * std::get<1>(xc_pots[0])->evalf(pos);
  1841 |         }
  1842 |         for (int j1 = 0; j1 < 3; j1++) {
  1843 |             for (int j2 = 0; j2 < 3; j2++) {
  1844 |                 out[i](j1, j2) = out[i](j1, j2) - xcOUT(i, 2 + j1) * nablaRhoGrid(i, j2);
  1845 |             }
  1846 |         }
  1847 |     }
  1848 |     return out;
  1849 | }
  1850 | 
  1851 | /**
  1852 |  * @brief Compute the exchange-correlation stress tensor for GGA functional for open shell systems
  1853 |  * 
  1854 |  * @param mrdft_p MRDFT object
  1855 |  * @param rhoGridAlpha MatrixXd with alpha density values, shape (nGrid, 1)
  1856 |  * @param rhoGridBeta MatrixXd with beta density values, shape (nGrid, 1)
  1857 |  * @param nablaRhoGridAlpha MatrixXd with gradient of alpha density values, shape (nGrid, 3)
  1858 |  * @param nablaRhoGridBeta MatrixXd with gradient of beta density values, shape (nGrid, 3)
  1859 |  * @return std::vector<Eigen::Matrix3d> vector of 3x3 matrices with stress tensor at each grid point
  1860 |  */
  1861 | std::vector<Matrix3d> xcGGASpinStress(unique_ptr<mrdft::MRDFT> &mrdft_p, mrcpp::FunctionTreeVector<3> &xc_pots, MatrixXd &rhoGridAlpha, MatrixXd &rhoGridBeta, MatrixXd &nablaRhoGridAlpha, MatrixXd &nablaRhoGridBeta, Eigen::MatrixXd &gridPos){
  1862 |     int nGrid = rhoGridAlpha.rows();
  1863 |     Eigen::MatrixXd inp(rhoGridAlpha.rows(), 8);
  1864 |     std::vector<Matrix3d> out = std::vector<Eigen::Matrix3d>(nGrid);
  1865 |     inp.col(0) = rhoGridAlpha.col(0);
  1866 |     inp.col(1) = rhoGridBeta.col(0);
  1867 |     inp.col(2) = nablaRhoGridAlpha.col(0);
  1868 |     inp.col(3) = nablaRhoGridAlpha.col(1);
  1869 |     inp.col(4) = nablaRhoGridAlpha.col(2);
  1870 |     inp.col(5) = nablaRhoGridBeta.col(0);
  1871 |     inp.col(6) = nablaRhoGridBeta.col(1);
  1872 |     inp.col(7) = nablaRhoGridBeta.col(2);
  1873 |     Eigen::MatrixXd xc = mrdft_p->functional().evaluate_transposed(inp);
  1874 |     std::array<double, 3> pos;
  1875 |     for (int i = 0; i < rhoGridAlpha.rows(); i++) {
  1876 |         out[i] = Matrix3d::Zero();
  1877 |         pos[0] = gridPos(i, 0);
  1878 |         pos[1] = gridPos(i, 1);
  1879 |         pos[2] = gridPos(i, 2);
  1880 |         for (int j = 0; j < 3; j++) {
  1881 |             out[i](j, j) = xc(i, 0) - std::get<1>(xc_pots[0])->evalf(pos) * rhoGridAlpha(i) - std::get<1>(xc_pots[1])->evalf(pos) * rhoGridBeta(i);
  1882 |         }
  1883 |         for (int j1 = 0; j1 < 3; j1++) {
  1884 |             for (int j2 = 0; j2 < 3; j2++) {
  1885 |                 out[i](j1, j2) = out[i](j1, j2) 
  1886 |                     - xc(i, 3 + j1) * nablaRhoGridAlpha(i, j2) - xc(i, 6 + j1) * nablaRhoGridBeta(i, j2);
  1887 |             }
  1888 |         }
  1889 |     }
  1890 |     return out;
  1891 | }
  1892 | 
  1893 | /**
  1894 |  * @brief Compute the exchange-correlation stress tensor on a grid
  1895 |  * 
  1896 |  * @param mrdft_p MRDFT object
  1897 |  * @param phi OrbitalVector
  1898 |  * @param nabla NablaOperator (must be set up prior to calling this function)
  1899 |  * @param gridPos MatrixXd with grid positions, shape (nGrid, 3)
  1900 |  * @param isOpenShell bool, true if open shell calculation
  1901 |  * @param prec precision to use in density representation
  1902 |  */
  1903 | std::vector<Eigen::Matrix3d> getXCStress(unique_ptr<mrdft::MRDFT> &mrdft_p, mrcpp::FunctionTreeVector<3> &xc_pots, std::shared_ptr<OrbitalVector> phi,
  1904 |         std::shared_ptr<NablaOperator> nabla, MatrixXd &gridPos, bool isOpenShell, double prec){
  1905 | 
  1906 |     bool isGGA = mrdft_p->functional().isGGA();
  1907 |     bool isHybrid = mrdft_p->functional().isHybrid();
  1908 |     if (isHybrid) {
  1909 |         MSG_ABORT("Exact exchange is not implemented for forces computed with surface integrals");
  1910 |     }
  1911 | 
  1912 |     std::array<double, 3> pos;
  1913 |     int nGrid = gridPos.rows();
  1914 | 
  1915 |     vector<Matrix3d> xcStress;
  1916 | 
  1917 |     if (isOpenShell) {
  1918 |         MatrixXd rhoGridAlpha(nGrid, 1);
  1919 |         MatrixXd rhoGridBeta(nGrid, 1);
  1920 |         mrchem::Density rhoA(false);
  1921 |         mrchem::Density rhoB(false);
  1922 |         mrchem::density::compute(prec, rhoA, *phi, DensityType::Alpha);
  1923 |         mrchem::density::compute(prec, rhoB, *phi, DensityType::Beta);
  1924 | 
  1925 |         for (int i = 0; i < nGrid; i++) { // compute density on grid
  1926 |             pos[0] = gridPos(i, 0);
  1927 |             pos[1] = gridPos(i, 1);
  1928 |             pos[2] = gridPos(i, 2);
  1929 |             rhoGridAlpha(i) = rhoA.real().evalf(pos);
  1930 |             rhoGridBeta(i) = rhoB.real().evalf(pos);
  1931 |         }
  1932 | 
  1933 |         if (isGGA) {
  1934 |             mrchem::NablaOperator nablaOP = *nabla;
  1935 |             std::vector<mrchem::Orbital> nablaRhoAlpha = nablaOP(rhoA);
  1936 |             std::vector<mrchem::Orbital> nablaRhoBeta = nablaOP(rhoB);
  1937 |             MatrixXd nablaRhoGridAlpha(nGrid, 3);
  1938 |             MatrixXd nablaRhoGridBeta(nGrid, 3);
  1939 |             for (int i = 0; i < nGrid; i++) {
  1940 |                 pos[0] = gridPos(i, 0);
  1941 |                 pos[1] = gridPos(i, 1);
  1942 |                 pos[2] = gridPos(i, 2);
  1943 |                 nablaRhoGridAlpha(i, 0) = nablaRhoAlpha[0].real().evalf(pos);
  1944 |                 nablaRhoGridAlpha(i, 1) = nablaRhoAlpha[1].real().evalf(pos);
  1945 |                 nablaRhoGridAlpha(i, 2) = nablaRhoAlpha[2].real().evalf(pos);
  1946 |                 nablaRhoGridBeta(i, 0) = nablaRhoBeta[0].real().evalf(pos);
  1947 |                 nablaRhoGridBeta(i, 1) = nablaRhoBeta[1].real().evalf(pos);
  1948 |                 nablaRhoGridBeta(i, 2) = nablaRhoBeta[2].real().evalf(pos);
  1949 |             }
  1950 | 
  1951 |             xcStress = xcGGASpinStress(mrdft_p, xc_pots, rhoGridAlpha, rhoGridBeta, nablaRhoGridAlpha, nablaRhoGridBeta, gridPos);
  1952 |         } else {
  1953 |             xcStress = xcLDASpinStress(mrdft_p, rhoGridAlpha, rhoGridBeta);
  1954 |         }
  1955 | 
  1956 |     } else { // closed shell
  1957 |         MatrixXd rhoGrid(nGrid, 1);
  1958 |         mrchem::Density rho(false);
  1959 |         mrchem::density::compute(prec, rho, *phi, DensityType::Total);
  1960 | 
  1961 |         for (int i = 0; i < nGrid; i++) { // compute density on grid
  1962 |             pos[0] = gridPos(i, 0);
  1963 |             pos[1] = gridPos(i, 1);
  1964 |             pos[2] = gridPos(i, 2);
  1965 |             rhoGrid(i) = rho.real().evalf(pos);
  1966 |         }
  1967 | 
  1968 |         if (isGGA) {
  1969 |             mrchem::NablaOperator nablaOP = *nabla;
  1970 |             std::vector<mrchem::Orbital> nablaRho = nablaOP(rho);
  1971 |             MatrixXd nablaRhoGrid(nGrid, 3);
  1972 |             for (int i = 0; i < nGrid; i++) {
  1973 |                 pos[0] = gridPos(i, 0);
  1974 |                 pos[1] = gridPos(i, 1);
  1975 |                 pos[2] = gridPos(i, 2);
  1976 |                 nablaRhoGrid(i, 0) = nablaRho[0].real().evalf(pos);
  1977 |                 nablaRhoGrid(i, 1) = nablaRho[1].real().evalf(pos);
  1978 |                 nablaRhoGrid(i, 2) = nablaRho[2].real().evalf(pos);
  1979 |             }
  1980 |             xcStress = xcGGAStress(mrdft_p, xc_pots, rhoGrid, nablaRhoGrid, gridPos);
  1981 |         } else {
  1982 |             xcStress = xcLDAStress(mrdft_p, rhoGrid);
  1983 |         }
  1984 |     }
  1985 |     return xcStress;
  1986 | }
  1987 | } // namespace surface_force
  1988 | ===== END src/surface_forces/xcStress.cpp =====
  1989 | 
  1990 | ===== BEGIN src/qmoperators/two_electron/XCPotential.h =====
  1991 | /*
  1992 |  * MRChem, a numerical real-space code for molecular electronic structure
  1993 |  * calculations within the self-consistent field (SCF) approximations of quantum
  1994 |  * chemistry (Hartree-Fock and Density Functional Theory).
  1995 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1996 |  *
  1997 |  * This file is part of MRChem.
  1998 |  *
  1999 |  * MRChem is free software: you can redistribute it and/or modify
  2000 |  * it under the terms of the GNU Lesser General Public License as published by
  2001 |  * the Free Software Foundation, either version 3 of the License, or
  2002 |  * (at your option) any later version.
  2003 |  *
  2004 |  * MRChem is distributed in the hope that it will be useful,
  2005 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  2006 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2007 |  * GNU Lesser General Public License for more details.
  2008 |  *
  2009 |  * You should have received a copy of the GNU Lesser General Public License
  2010 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  2011 |  *
  2012 |  * For information on the complete list of contributors to MRChem, see:
  2013 |  * <https://mrchem.readthedocs.io/>
  2014 |  */
  2015 | 
  2016 | #pragma once
  2017 | 
  2018 | #include "qmoperators/QMPotential.h"
  2019 | #include "qmfunctions/Density.h"
  2020 | 
  2021 | #include "mrdft/MRDFT.h"
  2022 | 
  2023 | /**
  2024 |  * @class XCPotential
  2025 |  * @brief Exchange-Correlation potential defined by a particular (spin) density
  2026 |  *
  2027 |  * The XC potential is computed by mapping of the density through a XC functional,
  2028 |  * provided by the XCFun library. There are two ways of defining the density:
  2029 |  *
  2030 |  *  1) Use getDensity() prior to setup() and build the density as you like.
  2031 |  *  2) Provide a default set of orbitals in the constructor that is used to
  2032 |  *     compute the density on-the-fly in setup().
  2033 |  *
  2034 |  * If a set of orbitals has NOT been given in the constructor, the density
  2035 |  * MUST be explicitly computed prior to setup(). The density will be computed
  2036 |  * on-the-fly in setup() ONLY if it is not already available. After setup() the
  2037 |  * operator will be fixed until clear(), which deletes both the density and the
  2038 |  * potential.
  2039 |  *
  2040 |  * LDA and GGA functionals are supported as well as two different ways to compute
  2041 |  * the XC potentials: either with explicit derivatives or gamma-type derivatives.
  2042 |  *
  2043 |  */
  2044 | 
  2045 | namespace mrchem {
  2046 | 
  2047 | class XCPotential : public QMPotential {
  2048 | public:
  2049 |     explicit XCPotential(std::unique_ptr<mrdft::MRDFT> &F, std::shared_ptr<OrbitalVector> Phi = nullptr, bool mpi_shared = false)
  2050 |             : QMPotential(1, mpi_shared)
  2051 |             , energy(0.0)
  2052 |             , orbitals(Phi)
  2053 |             , mrdft(std::move(F)) {}
  2054 |     ~XCPotential() override = default;
  2055 | 
  2056 |     /**
  2057 |      * @brief Get the XC potential. For unrestricted calculations, the potential is a vector of two functions.
  2058 |      */
  2059 |     std::shared_ptr<mrcpp::FunctionTreeVector<3>> getPotentialVector() { 
  2060 |         return std::make_shared<mrcpp::FunctionTreeVector<3>>(potentials); 
  2061 |     }
  2062 | 
  2063 |     friend class XCOperator;
  2064 | 
  2065 | protected:
  2066 |     double energy;                           ///< XC energy
  2067 |     std::vector<Density> densities;          ///< XC densities (total or alpha/beta)
  2068 |     mrcpp::FunctionTreeVector<3> potentials; ///< XC Potential functions collected in a vector
  2069 |     std::shared_ptr<mrcpp::FunctionTree<3>> v_tot{nullptr};            ///< Total XC potential
  2070 |     std::shared_ptr<OrbitalVector> orbitals; ///< External set of orbitals used to build the density
  2071 |     std::unique_ptr<mrdft::MRDFT> mrdft;     ///< External XC functional to be used
  2072 | 
  2073 |     double getEnergy() const { return this->energy; }
  2074 |     Density &getDensity(DensityType spin, int pert_idx);
  2075 |     mrcpp::FunctionTree<3> &getPotential(int spin);
  2076 | 
  2077 |     void setup(double prec) override;
  2078 |     void clear() override;
  2079 | 
  2080 |     virtual mrcpp::FunctionTreeVector<3> setupDensities(double prec, mrcpp::FunctionTree<3> &grid) = 0;
  2081 | 
  2082 |     Orbital apply(Orbital phi) override;
  2083 |     Orbital dagger(Orbital phi) override;
  2084 |     QMOperatorVector apply(std::shared_ptr<QMOperator> &O) override;
  2085 | };
  2086 | 
  2087 | } // namespace mrchem
  2088 | ===== END src/qmoperators/two_electron/XCPotential.h =====
  2089 | 
  2090 | ===== BEGIN src/qmoperators/two_electron/XCPotential.cpp =====
  2091 | /*
  2092 |  * MRChem, a numerical real-space code for molecular electronic structure
  2093 |  * calculations within the self-consistent field (SCF) approximations of quantum
  2094 |  * chemistry (Hartree-Fock and Density Functional Theory).
  2095 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  2096 |  *
  2097 |  * This file is part of MRChem.
  2098 |  *
  2099 |  * MRChem is free software: you can redistribute it and/or modify
  2100 |  * it under the terms of the GNU Lesser General Public License as published by
  2101 |  * the Free Software Foundation, either version 3 of the License, or
  2102 |  * (at your option) any later version.
  2103 |  *
  2104 |  * MRChem is distributed in the hope that it will be useful,
  2105 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  2106 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2107 |  * GNU Lesser General Public License for more details.
  2108 |  *
  2109 |  * You should have received a copy of the GNU Lesser General Public License
  2110 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  2111 |  *
  2112 |  * For information on the complete list of contributors to MRChem, see:
  2113 |  * <https://mrchem.readthedocs.io/>
  2114 |  */
  2115 | 
  2116 | #include <MRCPP/Printer>
  2117 | #include <MRCPP/Timer>
  2118 | 
  2119 | #include "XCPotential.h"
  2120 | #include "qmfunctions/density_utils.h"
  2121 | #include "qmfunctions/orbital_utils.h"
  2122 | 
  2123 | using mrcpp::FunctionTree;
  2124 | using mrcpp::Printer;
  2125 | using mrcpp::Timer;
  2126 | 
  2127 | using QMOperator_p = std::shared_ptr<mrchem::QMOperator>;
  2128 | 
  2129 | namespace mrchem {
  2130 | 
  2131 | /** @brief Prepare the operator for application
  2132 |  *
  2133 |  * @param[in] prec Apply precision
  2134 |  *
  2135 |  * Sequence of steps required to compute the XC potentials:
  2136 |  *
  2137 |  * 1) Compute density
  2138 |  * 2) Setup xcfun input functions (gradients etc.)
  2139 |  * 3) Evaluate xcfun
  2140 |  * 4) Compute XC energy by integrating energy density
  2141 |  * 5) Compute XC potential(s) from xcfun output functions
  2142 |  *
  2143 |  */
  2144 | void XCPotential::setup(double prec) {
  2145 |     if (isSetup(prec)) return;
  2146 |     setApplyPrec(prec);
  2147 |     Timer timer;
  2148 |     auto plevel = Printer::getPrintLevel();
  2149 |     mrcpp::print::header(3, "Building XC operator");
  2150 |     mrcpp::print::value(3, "Precision", prec, "(rel)", 5);
  2151 |     mrcpp::print::separator(3, '-');
  2152 |     if (this->mrdft == nullptr) MSG_ERROR("XCFunctional not initialized");
  2153 |     if (this->potentials.size() != 0) MSG_ERROR("Potential not properly cleared");
  2154 | 
  2155 |     auto &grid = this->mrdft->grid().get();
  2156 |     mrcpp::FunctionTreeVector<3> xc_inp = setupDensities(prec, grid);
  2157 |     mrcpp::FunctionTreeVector<3> xc_out = this->mrdft->evaluate(xc_inp);
  2158 | 
  2159 |     // Fetch energy
  2160 |     this->energy = this->mrdft->functional().XCenergy;
  2161 | 
  2162 |     // Fetch potential
  2163 |     auto &v_local = mrcpp::get_func(xc_out, 1);
  2164 |     auto *v_global = new mrcpp::FunctionTree<3>(v_local.getMRA());
  2165 |     mrcpp::copy_grid(*v_global, v_local);
  2166 |     mrcpp::copy_func(*v_global, v_local);
  2167 |     this->potentials.push_back(std::make_tuple(1.0, v_global));
  2168 | 
  2169 |     // Fetch potential
  2170 |     if (this->mrdft->functional().isSpin()) {
  2171 |         auto &v_local = mrcpp::get_func(xc_out, 2);
  2172 |         auto *v_global = new mrcpp::FunctionTree<3>(v_local.getMRA());
  2173 |         mrcpp::copy_grid(*v_global, v_local);
  2174 |         mrcpp::copy_func(*v_global, v_local);
  2175 |         this->potentials.push_back(std::make_tuple(1.0, v_global));
  2176 |     }
  2177 | 
  2178 | 
  2179 |     if (plevel == 2) {
  2180 |         int totNodes = 0;
  2181 |         int totSize = 0;
  2182 |         for (auto i = 0; i < this->potentials.size(); i++) {
  2183 |             auto &f_i = mrcpp::get_func(this->potentials, i);
  2184 |             totNodes += f_i.getNNodes();
  2185 |             totSize += f_i.getSizeNodes();
  2186 |         }
  2187 |         auto t = timer.elapsed();
  2188 |         mrcpp::print::tree(2, "XC operator", totNodes, totSize, t);
  2189 |     }
  2190 |     mrcpp::clear(xc_out, true);
  2191 |     mrcpp::print::footer(3, timer, 2);
  2192 | }
  2193 | 
  2194 | /** @brief Clears all data in the XCPotential object */
  2195 | void XCPotential::clear() {
  2196 |     this->energy = 0.0;
  2197 |     for (auto &rho : this->densities) rho.free(NUMBER::Total);
  2198 |     mrcpp::clear(this->potentials, true);
  2199 |     clearApplyPrec();
  2200 | }
  2201 | 
  2202 | Density &XCPotential::getDensity(DensityType spin, int pert_idx) {
  2203 |     int dens_idx = -1;
  2204 |     if (spin == DensityType::Total) {
  2205 |         if (pert_idx == 0) dens_idx = 0;
  2206 |         if (pert_idx == 1) dens_idx = 3;
  2207 |     } else if (spin == DensityType::Alpha) {
  2208 |         if (pert_idx == 0) dens_idx = 1;
  2209 |         if (pert_idx == 1) dens_idx = 4;
  2210 |     } else if (spin == DensityType::Beta) {
  2211 |         if (pert_idx == 0) dens_idx = 2;
  2212 |         if (pert_idx == 1) dens_idx = 5;
  2213 |     } else {
  2214 |         NOT_IMPLEMENTED_ABORT;
  2215 |     }
  2216 |     if (dens_idx < 0) MSG_ABORT("Invalid density index");
  2217 |     if (dens_idx > densities.size()) MSG_ABORT("Invalid density index");
  2218 |     return densities[dens_idx];
  2219 | }
  2220 | 
  2221 | /** @brief Return FunctionTree for the XC spin potential
  2222 |  *
  2223 |  * @param[in] type Which spin potential to return (alpha, beta or total)
  2224 |  */
  2225 | FunctionTree<3> &XCPotential::getPotential(int spin) {
  2226 |     int nPots = this->potentials.size();
  2227 |     if (nPots < 1 or nPots > 2) MSG_ERROR("Invalid potential");
  2228 | 
  2229 |     bool spinFunctional = this->mrdft->functional().isSpin();
  2230 |     int pot_idx = -1;
  2231 |     if (spinFunctional and spin == SPIN::Alpha) {
  2232 |         pot_idx = 0;
  2233 |     } else if (spinFunctional and spin == SPIN::Beta) {
  2234 |         pot_idx = 1;
  2235 |     } else if (not spinFunctional) {
  2236 |         pot_idx = 0;
  2237 |     } else if (spinFunctional and spin == SPIN::Paired) {
  2238 |         this->v_tot = std::make_shared<FunctionTree<3>>(*MRA);
  2239 |         mrcpp::add(prec(), *this->v_tot, this->potentials);
  2240 |         return *this->v_tot;
  2241 |     } else {
  2242 |         NOT_IMPLEMENTED_ABORT;
  2243 |     }
  2244 |     return mrcpp::get_func(this->potentials, pot_idx);
  2245 | }
  2246 | 
  2247 | /** @brief XCPotentialD1 application
  2248 |  *
  2249 |  * @param[in] phi Orbital to which the potential is applied
  2250 |  *
  2251 |  * The operator is applied by choosing the correct potential function
  2252 |  * which is then assigned to the real function part of the operator
  2253 |  * base-class before the base class function is called.
  2254 |  */
  2255 | Orbital XCPotential::apply(Orbital phi) {
  2256 |     QMPotential &V = *this;
  2257 |     if (V.hasImag()) MSG_ERROR("Imaginary part of XC potential non-zero");
  2258 | 
  2259 |     FunctionTree<3> &pot = getPotential(phi.spin());
  2260 |     V.setReal(&pot);
  2261 |     Orbital Vphi = QMPotential::apply(phi);
  2262 |     V.setReal(nullptr);
  2263 |     return Vphi;
  2264 | }
  2265 | 
  2266 | Orbital XCPotential::dagger(Orbital phi) {
  2267 |     QMPotential &V = *this;
  2268 |     if (V.hasImag()) MSG_ERROR("Imaginary part of XC potential non-zero");
  2269 | 
  2270 |     FunctionTree<3> &pot = getPotential(phi.spin());
  2271 |     V.setReal(&pot);
  2272 |     Orbital Vphi = QMPotential::dagger(phi);
  2273 |     V.setReal(nullptr);
  2274 |     return Vphi;
  2275 | }
  2276 | 
  2277 | QMOperatorVector XCPotential::apply(QMOperator_p &O) {
  2278 |     NOT_IMPLEMENTED_ABORT;
  2279 | }
  2280 | 
  2281 | } // namespace mrchem
  2282 | ===== END src/qmoperators/two_electron/XCPotential.cpp =====
  2283 | 
  2284 | ===== BEGIN src/qmoperators/two_electron/XCPotentialD1.h =====
  2285 | /*
  2286 |  * MRChem, a numerical real-space code for molecular electronic structure
  2287 |  * calculations within the self-consistent field (SCF) approximations of quantum
  2288 |  * chemistry (Hartree-Fock and Density Functional Theory).
  2289 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  2290 |  *
  2291 |  * This file is part of MRChem.
  2292 |  *
  2293 |  * MRChem is free software: you can redistribute it and/or modify
  2294 |  * it under the terms of the GNU Lesser General Public License as published by
  2295 |  * the Free Software Foundation, either version 3 of the License, or
  2296 |  * (at your option) any later version.
  2297 |  *
  2298 |  * MRChem is distributed in the hope that it will be useful,
  2299 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  2300 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2301 |  * GNU Lesser General Public License for more details.
  2302 |  *
  2303 |  * You should have received a copy of the GNU Lesser General Public License
  2304 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  2305 |  *
  2306 |  * For information on the complete list of contributors to MRChem, see:
  2307 |  * <https://mrchem.readthedocs.io/>
  2308 |  */
  2309 | 
  2310 | #pragma once
  2311 | 
  2312 | #include "XCPotential.h"
  2313 | 
  2314 | /** @class XCPotential
  2315 |  *
  2316 |  * @brief Exchange-Correlation potential defined by a particular (spin) density
  2317 |  *
  2318 |  * The XC potential is computed by mapping of the density through a XC functional,
  2319 |  * provided by the XCFun library. There are two ways of defining the density:
  2320 |  *
  2321 |  *  1) Use getDensity() prior to setup() and build the density as you like.
  2322 |  *  2) Provide a default set of orbitals in the constructor that is used to
  2323 |  *     compute the density on-the-fly in setup().
  2324 |  *
  2325 |  * If a set of orbitals has NOT been given in the constructor, the density
  2326 |  * MUST be explicitly computed prior to setup(). The density will be computed
  2327 |  * on-the-fly in setup() ONLY if it is not already available. After setup() the
  2328 |  * operator will be fixed until clear(), which deletes both the density and the
  2329 |  * potential.
  2330 |  *
  2331 |  * LDA and GGA functionals are supported as well as two different ways to compute
  2332 |  * the XC potentials: either with explicit derivatives or gamma-type derivatives.
  2333 |  */
  2334 | 
  2335 | namespace mrchem {
  2336 | 
  2337 | class XCPotentialD1 final : public XCPotential {
  2338 | public:
  2339 |     explicit XCPotentialD1(std::unique_ptr<mrdft::MRDFT> &F, std::shared_ptr<OrbitalVector> Phi = nullptr, bool mpi_shared = false);
  2340 | 
  2341 | private:
  2342 |     mrcpp::FunctionTreeVector<3> setupDensities(double prec, mrcpp::FunctionTree<3> &grid) override;
  2343 | };
  2344 | 
  2345 | } // namespace mrchem
  2346 | 
  2347 | ===== END src/qmoperators/two_electron/XCPotentialD1.h =====
  2348 | 
  2349 | ===== BEGIN src/qmoperators/two_electron/XCPotentialD1.cpp =====
  2350 | /*
  2351 |  * MRChem, a numerical real-space code for molecular electronic structure
  2352 |  * calculations within the self-consistent field (SCF) approximations of quantum
  2353 |  * chemistry (Hartree-Fock and Density Functional Theory).
  2354 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  2355 |  *
  2356 |  * This file is part of MRChem.
  2357 |  *
  2358 |  * MRChem is free software: you can redistribute it and/or modify
  2359 |  * it under the terms of the GNU Lesser General Public License as published by
  2360 |  * the Free Software Foundation, either version 3 of the License, or
  2361 |  * (at your option) any later version.
  2362 |  *
  2363 |  * MRChem is distributed in the hope that it will be useful,
  2364 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  2365 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2366 |  * GNU Lesser General Public License for more details.
  2367 |  *
  2368 |  * You should have received a copy of the GNU Lesser General Public License
  2369 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  2370 |  *
  2371 |  * For information on the complete list of contributors to MRChem, see:
  2372 |  * <https://mrchem.readthedocs.io/>
  2373 |  */
  2374 | 
  2375 | #include "MRCPP/Printer"
  2376 | #include "MRCPP/Timer"
  2377 | 
  2378 | #include "XCPotential.h"
  2379 | #include "XCPotentialD1.h"
  2380 | #include "qmfunctions/Density.h"
  2381 | #include "qmfunctions/Orbital.h"
  2382 | #include "qmfunctions/density_utils.h"
  2383 | #include "qmfunctions/orbital_utils.h"
  2384 | #include "utils/print_utils.h"
  2385 | 
  2386 | using mrcpp::Printer;
  2387 | using mrcpp::Timer;
  2388 | 
  2389 | namespace mrchem {
  2390 | 
  2391 | XCPotentialD1::XCPotentialD1(std::unique_ptr<mrdft::MRDFT> &F, std::shared_ptr<OrbitalVector> Phi, bool mpi_shared)
  2392 |         : XCPotential(F, Phi, mpi_shared) {
  2393 |     densities.push_back(Density(false)); // rho_0 total
  2394 |     densities.push_back(Density(false)); // rho_0 alpha
  2395 |     densities.push_back(Density(false)); // rho_0 beta
  2396 | }
  2397 | 
  2398 | mrcpp::FunctionTreeVector<3> XCPotentialD1::setupDensities(double prec, mrcpp::FunctionTree<3> &grid) {
  2399 |     mrcpp::FunctionTreeVector<3> dens_vec;
  2400 |     if (not this->mrdft->functional().isSpin()) {
  2401 |         { // Unperturbed total density
  2402 |             Timer timer;
  2403 |             Density &rho = getDensity(DensityType::Total, 0);
  2404 |             if (not rho.hasReal()) {
  2405 |                 rho.alloc(NUMBER::Real);
  2406 |                 mrcpp::copy_grid(rho.real(), grid);
  2407 |                 density::compute(prec, rho, *orbitals, DensityType::Total);
  2408 |             }
  2409 |             print_utils::qmfunction(3, "Compute rho", rho, timer);
  2410 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2411 |         }
  2412 |     } else {
  2413 |         { // Unperturbed alpha density
  2414 |             Timer timer;
  2415 |             Density &rho = getDensity(DensityType::Alpha, 0);
  2416 |             if (not rho.hasReal()) {
  2417 |                 rho.alloc(NUMBER::Real);
  2418 |                 mrcpp::copy_grid(rho.real(), grid);
  2419 |                 density::compute(prec, rho, *orbitals, DensityType::Alpha);
  2420 |             }
  2421 |             print_utils::qmfunction(3, "Compute rho (alpha)", rho, timer);
  2422 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2423 |         }
  2424 |         { // Unperturbed beta density
  2425 |             Timer timer;
  2426 |             Density &rho = getDensity(DensityType::Beta, 0);
  2427 |             if (not rho.hasReal()) {
  2428 |                 rho.alloc(NUMBER::Real);
  2429 |                 mrcpp::copy_grid(rho.real(), grid);
  2430 |                 density::compute(prec, rho, *orbitals, DensityType::Beta);
  2431 |             }
  2432 |             print_utils::qmfunction(3, "Compute rho (beta)", rho, timer);
  2433 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2434 |         }
  2435 |     }
  2436 |     return dens_vec;
  2437 | }
  2438 | 
  2439 | } // namespace mrchem
  2440 | 
  2441 | ===== END src/qmoperators/two_electron/XCPotentialD1.cpp =====
  2442 | 
  2443 | ===== BEGIN src/qmoperators/two_electron/XCPotentialD2.h =====
  2444 | /*
  2445 |  * MRChem, a numerical real-space code for molecular electronic structure
  2446 |  * calculations within the self-consistent field (SCF) approximations of quantum
  2447 |  * chemistry (Hartree-Fock and Density Functional Theory).
  2448 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  2449 |  *
  2450 |  * This file is part of MRChem.
  2451 |  *
  2452 |  * MRChem is free software: you can redistribute it and/or modify
  2453 |  * it under the terms of the GNU Lesser General Public License as published by
  2454 |  * the Free Software Foundation, either version 3 of the License, or
  2455 |  * (at your option) any later version.
  2456 |  *
  2457 |  * MRChem is distributed in the hope that it will be useful,
  2458 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  2459 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2460 |  * GNU Lesser General Public License for more details.
  2461 |  *
  2462 |  * You should have received a copy of the GNU Lesser General Public License
  2463 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  2464 |  *
  2465 |  * For information on the complete list of contributors to MRChem, see:
  2466 |  * <https://mrchem.readthedocs.io/>
  2467 |  */
  2468 | 
  2469 | #pragma once
  2470 | 
  2471 | #include "qmoperators/two_electron/XCPotential.h"
  2472 | 
  2473 | /** @class XCPotential
  2474 |  *
  2475 |  * @brief Exchange-Correlation potential defined by a particular (spin) density
  2476 |  *
  2477 |  * The XC potential is computed by mapping of the density through a XC functional,
  2478 |  * provided by the XCFun library. There are two ways of defining the density:
  2479 |  *
  2480 |  *  1) Use getDensity() prior to setup() and build the density as you like.
  2481 |  *  2) Provide a default set of orbitals in the constructor that is used to
  2482 |  *     compute the density on-the-fly in setup().
  2483 |  *
  2484 |  * If a set of orbitals has NOT been given in the constructor, the density
  2485 |  * MUST be explicitly computed prior to setup(). The density will be computed
  2486 |  * on-the-fly in setup() ONLY if it is not already available. After setup() the
  2487 |  * operator will be fixed until clear(), which deletes both the density and the
  2488 |  * potential.
  2489 |  *
  2490 |  * LDA and GGA functionals are supported as well as two different ways to compute
  2491 |  * the XC potentials: either with explicit derivatives or gamma-type derivatives.
  2492 |  */
  2493 | 
  2494 | namespace mrchem {
  2495 | 
  2496 | class XCPotentialD2 final : public XCPotential {
  2497 | public:
  2498 |     XCPotentialD2(std::unique_ptr<mrdft::MRDFT> &F, std::shared_ptr<OrbitalVector> Phi, std::shared_ptr<OrbitalVector> X, std::shared_ptr<OrbitalVector> Y, bool mpi_shared = false);
  2499 | 
  2500 | private:
  2501 |     std::shared_ptr<OrbitalVector> orbitals_x; ///< 1st external set of perturbed orbitals used to build the density
  2502 |     std::shared_ptr<OrbitalVector> orbitals_y; ///< 2nd external set of perturbed orbitals used to build the density
  2503 | 
  2504 |     mrcpp::FunctionTreeVector<3> setupDensities(double prec, mrcpp::FunctionTree<3> &grid);
  2505 | };
  2506 | 
  2507 | } // namespace mrchem
  2508 | 
  2509 | ===== END src/qmoperators/two_electron/XCPotentialD2.h =====
  2510 | 
  2511 | ===== BEGIN src/qmoperators/two_electron/XCPotentialD2.cpp =====
  2512 | /*
  2513 |  * MRChem, a numerical real-space code for molecular electronic structure
  2514 |  * calculations within the self-consistent field (SCF) approximations of quantum
  2515 |  * chemistry (Hartree-Fock and Density Functional Theory).
  2516 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  2517 |  *
  2518 |  * This file is part of MRChem.
  2519 |  *
  2520 |  * MRChem is free software: you can redistribute it and/or modify
  2521 |  * it under the terms of the GNU Lesser General Public License as published by
  2522 |  * the Free Software Foundation, either version 3 of the License, or
  2523 |  * (at your option) any later version.
  2524 |  *
  2525 |  * MRChem is distributed in the hope that it will be useful,
  2526 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  2527 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2528 |  * GNU Lesser General Public License for more details.
  2529 |  *
  2530 |  * You should have received a copy of the GNU Lesser General Public License
  2531 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  2532 |  *
  2533 |  * For information on the complete list of contributors to MRChem, see:
  2534 |  * <https://mrchem.readthedocs.io/>
  2535 |  */
  2536 | 
  2537 | #include "MRCPP/MWOperators"
  2538 | #include "MRCPP/Printer"
  2539 | #include "MRCPP/Timer"
  2540 | 
  2541 | #include "XCPotential.h"
  2542 | #include "XCPotentialD2.h"
  2543 | #include "qmfunctions/Density.h"
  2544 | #include "qmfunctions/density_utils.h"
  2545 | #include "qmfunctions/orbital_utils.h"
  2546 | #include "utils/print_utils.h"
  2547 | 
  2548 | using mrcpp::FunctionTree;
  2549 | using mrcpp::Printer;
  2550 | using mrcpp::Timer;
  2551 | 
  2552 | namespace mrchem {
  2553 | 
  2554 | XCPotentialD2::XCPotentialD2(std::unique_ptr<mrdft::MRDFT> &F, std::shared_ptr<OrbitalVector> Phi, std::shared_ptr<OrbitalVector> X, std::shared_ptr<OrbitalVector> Y, bool mpi_shared)
  2555 |         : XCPotential(F, Phi, mpi_shared)
  2556 |         , orbitals_x(X)
  2557 |         , orbitals_y(Y) {
  2558 |     densities.push_back(Density(false)); // rho_0 total
  2559 |     densities.push_back(Density(false)); // rho_0 alpha
  2560 |     densities.push_back(Density(false)); // rho_0 beta
  2561 |     densities.push_back(Density(false)); // rho_1 total
  2562 |     densities.push_back(Density(false)); // rho_1 alpha
  2563 |     densities.push_back(Density(false)); // rho_1 beta
  2564 | }
  2565 | 
  2566 | /** @brief Prepare the operator for application
  2567 |  *
  2568 |  * @param[in] prec Apply precision
  2569 |  *
  2570 |  * Sequence of steps required to compute the XC potentials:
  2571 |  *
  2572 |  * 1) Compute density
  2573 |  * 2) Setup xcfun input functions (gradients etc.)
  2574 |  * 3) Evaluate xcfun
  2575 |  * 4) Compute XC energy by integrating energy density
  2576 |  * 5) Compute XC potential(s) from xcfun output functions
  2577 |  * 6) Remove excess grid nodes based on precision
  2578 |  * 7) Add extra grid nodes based on precision
  2579 |  * 8) Clear internal functions in XCFunctional (density grid is kept)
  2580 |  *
  2581 |  */
  2582 | mrcpp::FunctionTreeVector<3> XCPotentialD2::setupDensities(double prec, mrcpp::FunctionTree<3> &grid) {
  2583 |     mrcpp::FunctionTreeVector<3> dens_vec;
  2584 |     if (not this->mrdft->functional().isSpin()) {
  2585 |         { // Unperturbed total density
  2586 |             Timer timer;
  2587 |             Density &rho = getDensity(DensityType::Total, 0);
  2588 |             if (not rho.hasReal()) {
  2589 |                 rho.alloc(NUMBER::Real);
  2590 |                 mrcpp::copy_grid(rho.real(), grid);
  2591 |                 density::compute(prec, rho, *orbitals, DensityType::Total);
  2592 |             }
  2593 |             print_utils::qmfunction(3, "Compute rho_0", rho, timer);
  2594 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2595 |         }
  2596 |         { // Perturbed total density
  2597 |             Timer timer;
  2598 |             Density &rho = getDensity(DensityType::Total, 1);
  2599 |             if (not rho.hasReal()) {
  2600 |                 rho.alloc(NUMBER::Real);
  2601 |                 mrcpp::copy_grid(rho.real(), grid);
  2602 |                 density::compute(prec, rho, *orbitals, *orbitals_x, *orbitals_y, DensityType::Total);
  2603 |             }
  2604 |             print_utils::qmfunction(3, "Compute rho_1", rho, timer);
  2605 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2606 |         }
  2607 |     } else {
  2608 |         { // Unperturbed alpha density
  2609 |             Timer timer;
  2610 |             Density &rho = getDensity(DensityType::Alpha, 0);
  2611 |             if (not rho.hasReal()) {
  2612 |                 rho.alloc(NUMBER::Real);
  2613 |                 mrcpp::copy_grid(rho.real(), grid);
  2614 |                 density::compute(prec, rho, *orbitals, DensityType::Alpha);
  2615 |             }
  2616 |             print_utils::qmfunction(3, "Compute rho_0 (alpha)", rho, timer);
  2617 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2618 |         }
  2619 |         { // Unperturbed beta density
  2620 |             Timer timer;
  2621 |             Density &rho = getDensity(DensityType::Beta, 0);
  2622 |             if (not rho.hasReal()) {
  2623 |                 rho.alloc(NUMBER::Real);
  2624 |                 mrcpp::copy_grid(rho.real(), grid);
  2625 |                 density::compute(prec, rho, *orbitals, DensityType::Beta);
  2626 |             }
  2627 |             print_utils::qmfunction(3, "Compute rho_0 (beta)", rho, timer);
  2628 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2629 |         }
  2630 |         { // Perturbed alpha density
  2631 |             Timer timer;
  2632 |             Density &rho = getDensity(DensityType::Alpha, 1);
  2633 |             if (not rho.hasReal()) {
  2634 |                 rho.alloc(NUMBER::Real);
  2635 |                 mrcpp::copy_grid(rho.real(), grid);
  2636 |                 density::compute(prec, rho, *orbitals, *orbitals_x, *orbitals_y, DensityType::Alpha);
  2637 |             }
  2638 |             print_utils::qmfunction(3, "Compute rho_1 (alpha)", rho, timer);
  2639 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2640 |         }
  2641 |         { // Perturbed beta density
  2642 |             Timer timer;
  2643 |             Density &rho = getDensity(DensityType::Beta, 1);
  2644 |             if (not rho.hasReal()) {
  2645 |                 rho.alloc(NUMBER::Real);
  2646 |                 mrcpp::copy_grid(rho.real(), grid);
  2647 |                 density::compute(prec, rho, *orbitals, *orbitals_x, *orbitals_y, DensityType::Beta);
  2648 |             }
  2649 |             print_utils::qmfunction(3, "Compute rho_1 (beta)", rho, timer);
  2650 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2651 |         }
  2652 |     }
  2653 |     return dens_vec;
  2654 | }
  2655 | 
  2656 | } // namespace mrchem
  2657 | 
  2658 | ===== END src/qmoperators/two_electron/XCPotentialD2.cpp =====
  2659 | 
  2660 | ===== BEGIN CMakeLists.txt =====
  2661 | # This file is autogenerated by Autocmake v1.0.0 http://autocmake.org
  2662 | # Copyright (c) 2015-2020 by Radovan Bast, Roberto Di Remigio, Jonas Juselius, and contributors.
  2663 | 
  2664 | # set minimum cmake version
  2665 | cmake_minimum_required(VERSION 3.14 FATAL_ERROR)
  2666 | 
  2667 | # project name
  2668 | project(MRChem LANGUAGES CXX)
  2669 | 
  2670 | # do not rebuild if rules (compiler flags) change
  2671 | set(CMAKE_SKIP_RULE_DEPENDENCY TRUE)
  2672 | 
  2673 | # if CMAKE_BUILD_TYPE undefined, we set it to Release
  2674 | if(NOT CMAKE_BUILD_TYPE)
  2675 |     set(CMAKE_BUILD_TYPE "Release")
  2676 | endif()
  2677 | 
  2678 | # Options handling utilities
  2679 | include(CMakeDependentOption)
  2680 | # Macro for printing an option in a consistent manner
  2681 | # Written by Lori A. Burns (@loriab) and Ryan M. Richard (@ryanmrichard)
  2682 | # Syntax: print_option(<option to print> <was specified>)
  2683 | macro(print_option variable default)
  2684 |   if(NOT DEFINED ${variable} OR "${${variable}}" STREQUAL "")
  2685 |     message(STATUS "Setting (unspecified) option ${variable}: ${default}")
  2686 |   else()
  2687 |     message(STATUS "Setting option ${variable}: ${${variable}}")
  2688 |   endif()
  2689 | endmacro()
  2690 | 
  2691 | # Wraps an option with default ON/OFF. Adds nice messaging to option()
  2692 | # Written by Lori A. Burns (@loriab) and Ryan M. Richard (@ryanmrichard)
  2693 | # Syntax: option_with_print(<option name> <description> <default value>)
  2694 | macro(option_with_print variable msge default)
  2695 |   print_option(${variable} ${default})
  2696 |   option(${variable} ${msge} ${default})
  2697 | endmacro()
  2698 | 
  2699 | # Wraps an option with a default other than ON/OFF and prints it
  2700 | # Written by Lori A. Burns (@loriab) and Ryan M. Richard (@ryanmrichard)
  2701 | # NOTE: Can't combine with above b/c CMake handles ON/OFF options specially
  2702 | # NOTE2: CMake variables are always defined so need to further check for if
  2703 | #       they are the NULL string. This is also why we need the force
  2704 | # Syntax: option_with_default(<option name> <description> <default value>)
  2705 | macro(option_with_default variable msge default)
  2706 |   print_option(${variable} "${default}")
  2707 |   if(NOT DEFINED ${variable} OR "${${variable}}" STREQUAL "")
  2708 |     set(${variable} "${default}" CACHE STRING ${msge} FORCE)
  2709 |   endif()
  2710 | endmacro()
  2711 | 
  2712 | # included cmake modules
  2713 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_cxx.cmake)
  2714 | include(${PROJECT_SOURCE_DIR}/cmake/compiler_flags/CXXFlags.cmake)
  2715 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_default_build_paths.cmake)
  2716 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_safeguards.cmake)
  2717 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_code_coverage.cmake)
  2718 | include(${PROJECT_SOURCE_DIR}/cmake/custom/mpi.cmake)
  2719 | include(${PROJECT_SOURCE_DIR}/cmake/custom/omp.cmake)
  2720 | include(${PROJECT_SOURCE_DIR}/cmake/custom/sad_basis.cmake)
  2721 | include(${PROJECT_SOURCE_DIR}/cmake/custom/hirshfeld.cmake)
  2722 | include(${PROJECT_SOURCE_DIR}/cmake/custom/azora_potentials.cmake)
  2723 | include(${PROJECT_SOURCE_DIR}/cmake/custom/main.cmake)
  2724 | include(${PROJECT_SOURCE_DIR}/cmake/custom/feature_summary.cmake)
  2725 | include(${PROJECT_SOURCE_DIR}/cmake/custom/tests.cmake)
  2726 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_save_flags.cmake)
  2727 | 
  2728 | ===== END CMakeLists.txt =====
  2729 | 
  2730 | ===== BEGIN src/mrdft/CMakeLists.txt =====
  2731 | target_sources(mrchem PRIVATE
  2732 |     ${CMAKE_CURRENT_SOURCE_DIR}/Factory.cpp
  2733 |     ${CMAKE_CURRENT_SOURCE_DIR}/MRDFT.cpp
  2734 |     ${CMAKE_CURRENT_SOURCE_DIR}/Functional.cpp
  2735 |     ${CMAKE_CURRENT_SOURCE_DIR}/LDA.cpp
  2736 |     ${CMAKE_CURRENT_SOURCE_DIR}/SpinLDA.cpp
  2737 |     ${CMAKE_CURRENT_SOURCE_DIR}/GGA.cpp
  2738 |     ${CMAKE_CURRENT_SOURCE_DIR}/SpinGGA.cpp
  2739 |     ${CMAKE_CURRENT_SOURCE_DIR}/xc_utils.cpp
  2740 |     )
  2741 | 
  2742 | ===== END src/mrdft/CMakeLists.txt =====
  2743 | 
  2744 | ===== BEGIN external/upstream/fetch_xcfun.cmake =====
  2745 | find_package(XCFun CONFIG QUIET
  2746 |   NO_CMAKE_PATH
  2747 |   NO_CMAKE_PACKAGE_REGISTRY
  2748 |   NO_CMAKE_SYSTEM_PACKAGE_REGISTRY
  2749 |   )
  2750 | if(TARGET XCFun::xcfun)
  2751 |   get_property(_loc TARGET XCFun::xcfun PROPERTY LOCATION)
  2752 |   message(STATUS "Found XCFun: ${_loc} (found version ${XCFun_VERSION})")
  2753 | else()
  2754 |   message(STATUS "Suitable XCFun could not be located. Fetching and building!")
  2755 |   include(FetchContent)
  2756 |   FetchContent_Declare(xcfun_sources
  2757 |     QUIET
  2758 |     URL
  2759 |       https://github.com/dftlibs/xcfun/archive/v2.1.0.tar.gz
  2760 |     )
  2761 | 
  2762 |   FetchContent_GetProperties(xcfun_sources)
  2763 | 
  2764 |   set(CMAKE_BUILD_TYPE Release)
  2765 |   set(ENABLE_TESTALL FALSE CACHE BOOL "")
  2766 |   set(XCFUN_MAX_ORDER 3)  # TODO Maybe as a user-facing option?
  2767 |   set(XCFUN_PYTHON_INTERFACE FALSE CACHE BOOL "")
  2768 | 
  2769 |   if(NOT xcfun_sources_POPULATED)
  2770 |     FetchContent_Populate(xcfun_sources)
  2771 | 
  2772 |     add_subdirectory(
  2773 |       ${xcfun_sources_SOURCE_DIR}
  2774 |       ${xcfun_sources_BINARY_DIR}
  2775 |       )
  2776 |   endif()
  2777 | endif()
  2778 | 
  2779 | ===== END external/upstream/fetch_xcfun.cmake =====
  2780 | 
  2781 | ===== BEGIN cmake/custom/main.cmake =====
  2782 | file(MAKE_DIRECTORY ${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_INCLUDEDIR}/${PROJECT_NAME})
  2783 | 
  2784 | file(READ "${PROJECT_SOURCE_DIR}/VERSION" MRCHEM_VERSION)
  2785 | string(STRIP "${MRCHEM_VERSION}" MRCHEM_VERSION)
  2786 | 
  2787 | string(REPLACE "." ";" VERSION_LIST ${MRCHEM_VERSION})
  2788 | list(GET VERSION_LIST 0 MRCHEM_VERSION_MAJOR)
  2789 | list(GET VERSION_LIST 1 MRCHEM_VERSION_MINOR)
  2790 | 
  2791 | configure_file (
  2792 |   ${PROJECT_SOURCE_DIR}/config.h.in
  2793 |   ${PROJECT_BINARY_DIR}/config.h
  2794 |   @ONLY
  2795 |   )
  2796 | 
  2797 | add_custom_command(
  2798 |   OUTPUT
  2799 |     ${PROJECT_BINARY_DIR}/version.h
  2800 |   COMMAND
  2801 |     ${CMAKE_COMMAND} -DINPUT_DIR=${PROJECT_SOURCE_DIR}
  2802 |                      -DTARGET_DIR=${PROJECT_BINARY_DIR}
  2803 |                      -DCMAKE_SYSTEM=${CMAKE_SYSTEM}
  2804 |                      -DCMAKE_SYSTEM_PROCESSOR=${CMAKE_SYSTEM_PROCESSOR}
  2805 |                      -DCMAKE_GENERATOR=${CMAKE_GENERATOR}
  2806 |                      -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
  2807 |                      -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}
  2808 |                      -DCMAKE_CXX_COMPILER_VERSION=${CMAKE_CXX_COMPILER_VERSION}
  2809 |                      -DMRCHEM_VERSION=${MRCHEM_VERSION}
  2810 |                      -DMW_FILTER_SOURCE_DIR=${MW_FILTER_SOURCE_DIR}
  2811 |                      -DMW_FILTER_INSTALL_DIR=${MW_FILTER_INSTALL_DIR}
  2812 |                      -P ${CMAKE_CURRENT_LIST_DIR}/binary-info.cmake
  2813 |   MAIN_DEPENDENCY
  2814 |     ${PROJECT_SOURCE_DIR}/version.h.in
  2815 |   WORKING_DIRECTORY
  2816 |     ${CMAKE_CURRENT_LIST_DIR}
  2817 |   )
  2818 | 
  2819 | # rebuild version_info.h every time
  2820 | add_custom_target(
  2821 |   mrchem-info
  2822 |   ALL
  2823 |   COMMAND
  2824 |     ${CMAKE_COMMAND} -E touch_nocreate ${PROJECT_SOURCE_DIR}/version.h.in
  2825 |   DEPENDS
  2826 |     ${PROJECT_BINARY_DIR}/version.h
  2827 |   )
  2828 | 
  2829 | # See here for the reason why: https://gitlab.kitware.com/cmake/cmake/issues/18399
  2830 | set_source_files_properties(${PROJECT_BINARY_DIR}/version.h
  2831 |   PROPERTIES
  2832 |     GENERATED 1
  2833 |   )
  2834 | 
  2835 | # We save CMAKE_BUILD_TYPE, as we will set it to Release for externals
  2836 | set(_build_type ${CMAKE_BUILD_TYPE})
  2837 | # Order IS important here!
  2838 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_nlohmann_json.cmake)
  2839 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_xcfun.cmake)
  2840 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_eigen3.cmake)
  2841 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_mrcpp.cmake)
  2842 | # reset CMAKE_BUILD_TYPE to whatever it was for MRChem
  2843 | set(CMAKE_BUILD_TYPE ${_build_type})
  2844 | 
  2845 | add_subdirectory(src)
  2846 | add_subdirectory(python)
  2847 | add_subdirectory(pilot)
  2848 | 
  2849 | ===== END cmake/custom/main.cmake =====
  2850 | 

=== FILE: xc_bundle_20250825_142614.txt | 90.7 KB ===
     1 | ===== BEGIN src/mrdft/xc_utils.h =====
     2 | /*
     3 |  * MRChem, a numerical real-space code for molecular electronic structure
     4 |  * calculations within the self-consistent field (SCF) approximations of quantum
     5 |  * chemistry (Hartree-Fock and Density Functional Theory).
     6 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
     7 |  *
     8 |  * This file is part of MRChem.
     9 |  *
    10 |  * MRChem is free software: you can redistribute it and/or modify
    11 |  * it under the terms of the GNU Lesser General Public License as published by
    12 |  * the Free Software Foundation, either version 3 of the License, or
    13 |  * (at your option) any later version.
    14 |  *
    15 |  * MRChem is distributed in the hope that it will be useful,
    16 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
    17 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18 |  * GNU Lesser General Public License for more details.
    19 |  *
    20 |  * You should have received a copy of the GNU Lesser General Public License
    21 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
    22 |  *
    23 |  * For information on the complete list of contributors to MRChem, see:
    24 |  * <https://mrchem.readthedocs.io/>
    25 |  */
    26 | 
    27 | #include <Eigen/Core>
    28 | #include <MRCPP/MWFunctions>
    29 | 
    30 | namespace mrdft {
    31 | namespace xc_utils {
    32 | 
    33 | Eigen::MatrixXi build_output_mask(bool is_lda, bool is_spin_sep, int order);
    34 | Eigen::VectorXi build_density_mask(bool is_lda, bool is_spin_sep, int order);
    35 | 
    36 | std::vector<mrcpp::FunctionNode<3> *> fetch_nodes(int n, mrcpp::FunctionTreeVector<3> &inp);
    37 | Eigen::MatrixXd compress_nodes(std::vector<mrcpp::FunctionNode<3> *> &inp_nodes);
    38 | void expand_nodes(std::vector<mrcpp::FunctionNode<3> *> &out_nodes, Eigen::MatrixXd &out_data);
    39 | 
    40 | mrcpp::FunctionTreeVector<3> log_gradient(mrcpp::DerivativeOperator<3> &diff_oper, mrcpp::FunctionTree<3> &rho);
    41 | 
    42 | } // namespace xc_utils
    43 | } // namespace mrdft
    44 | 
    45 | ===== END src/mrdft/xc_utils.h =====
    46 | 
    47 | ===== BEGIN src/mrdft/xc_utils.cpp =====
    48 | /*
    49 |  * MRChem, a numerical real-space code for molecular electronic structure
    50 |  * calculations within the self-consistent field (SCF) approximations of quantum
    51 |  * chemistry (Hartree-Fock and Density Functional Theory).
    52 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
    53 |  *
    54 |  * This file is part of MRChem.
    55 |  *
    56 |  * MRChem is free software: you can redistribute it and/or modify
    57 |  * it under the terms of the GNU Lesser General Public License as published by
    58 |  * the Free Software Foundation, either version 3 of the License, or
    59 |  * (at your option) any later version.
    60 |  *
    61 |  * MRChem is distributed in the hope that it will be useful,
    62 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
    63 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    64 |  * GNU Lesser General Public License for more details.
    65 |  *
    66 |  * You should have received a copy of the GNU Lesser General Public License
    67 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
    68 |  *
    69 |  * For information on the complete list of contributors to MRChem, see:
    70 |  * <https://mrchem.readthedocs.io/>
    71 |  */
    72 | 
    73 | #include <MRCPP/MWOperators>
    74 | #include <MRCPP/Printer>
    75 | #include <MRCPP/trees/FunctionNode.h>
    76 | 
    77 | #include "xc_utils.h"
    78 | 
    79 | namespace mrdft {
    80 | 
    81 | namespace xc_utils {
    82 | void fill_output_mask(Eigen::MatrixXi &mask, int start);
    83 | } // namespace xc_utils
    84 | 
    85 | Eigen::MatrixXi xc_utils::build_output_mask(bool is_lda, bool is_spin_sep, int order) {
    86 |     int start = 2;
    87 |     bool is_gga = not is_lda;
    88 |     Eigen::MatrixXi mask(1, 1);
    89 |     mask << 1;
    90 |     switch (order) {
    91 |         case 0:
    92 |             break;
    93 |         case 1:
    94 |             if (is_lda and is_spin_sep) {
    95 |                 mask.resize(2, 1);
    96 |                 mask << 1, 2;
    97 |             } else if (is_gga and not is_spin_sep) {
    98 |                 mask.resize(4, 1);
    99 |                 mask << 1, 2, 3, 4;
   100 |             } else if (is_gga and is_spin_sep) {
   101 |                 mask.resize(8, 1);
   102 |                 mask << 1, 2, 3, 4, 5, 6, 7, 8;
   103 |             }
   104 |             break;
   105 |         case 2:
   106 |             if (is_lda and is_spin_sep) {
   107 |                 start = 3;
   108 |                 mask.resize(2, 2);
   109 |             } else if (is_gga and not is_spin_sep) {
   110 |                 start = 5;
   111 |                 mask.resize(4, 4);
   112 |             } else if (is_gga and is_spin_sep) {
   113 |                 start = 9;
   114 |                 mask.resize(8, 8);
   115 |             }
   116 |             fill_output_mask(mask, start);
   117 |             break;
   118 |         default:
   119 |             MSG_ABORT("Not implemented");
   120 |     }
   121 |     return mask;
   122 | }
   123 | 
   124 | Eigen::VectorXi xc_utils::build_density_mask(bool is_lda, bool is_spin_sep, int order) {
   125 |     bool is_gga = not is_lda;
   126 |     Eigen::VectorXi mask(1);
   127 |     switch (order) {
   128 |         case 0:
   129 |         case 1:
   130 |             mask(0) = -1;
   131 |             break;
   132 |         case 2:
   133 |             mask(0) = 0;
   134 |             if (is_lda and is_spin_sep) {
   135 |                 mask.resize(2);
   136 |                 mask << 0, 1;
   137 |             } else if (is_gga and not is_spin_sep) {
   138 |                 mask.resize(4);
   139 |                 mask << 0, 1, 2, 3;
   140 |             } else if (is_gga and is_spin_sep) {
   141 |                 mask.resize(8);
   142 |                 mask << 0, 1, 2, 3, 4, 5, 6, 7;
   143 |             }
   144 |             break;
   145 |         default:
   146 |             MSG_ABORT("Not implemented");
   147 |     }
   148 |     return mask;
   149 | }
   150 | 
   151 | void xc_utils::fill_output_mask(Eigen::MatrixXi &mask, int value) {
   152 |     for (int i = 0; i < mask.rows(); i++) {
   153 |         mask(i, i) = value;
   154 |         value++;
   155 |         for (int j = i + 1; j < mask.cols(); j++) {
   156 |             mask(i, j) = value;
   157 |             mask(j, i) = value;
   158 |             value++;
   159 |         }
   160 |     }
   161 | }
   162 | 
   163 | /** @brief Fetch specific node from several FunctionTrees
   164 |  *
   165 |  * This will retrieve one node from each of the input trees and put them
   166 |  * into a vector of FunctionNodes. The node is fetched from position n
   167 |  * in the respective endNodeTables, which means that the tree structures
   168 |  * must be identical for this routine to work as intended.
   169 |  *
   170 |  * param[in] n Node position in EndNodeTable
   171 |  * param[in] inp_trees Array of FunctionTrees
   172 |  * param[out] out_nodes Array of FunctionNodes
   173 |  */
   174 | std::vector<mrcpp::FunctionNode<3> *> xc_utils::fetch_nodes(int n, mrcpp::FunctionTreeVector<3> &inp_trees) {
   175 |     std::vector<mrcpp::FunctionNode<3> *> out_nodes;
   176 |     for (auto i = 0; i < inp_trees.size(); i++) {
   177 |         auto &iTree = mrcpp::get_func(inp_trees, i);
   178 |         auto &iNode = iTree.getEndFuncNode(n);
   179 |         out_nodes.push_back(&iNode);
   180 |     }
   181 |     return out_nodes;
   182 | }
   183 | 
   184 | /** @brief Collect data from FunctionNodes into a matrix
   185 |  *
   186 |  * Collects function values from the input nodes into the rows
   187 |  * of a matrix. Matrix dimension: rows = nNodes, cols = nCoefs.
   188 |  *
   189 |  * param[in] inp_nodes Array of FunctionNodes
   190 |  * param[out] out_data Matrix of function values
   191 |  */
   192 | Eigen::MatrixXd xc_utils::compress_nodes(std::vector<mrcpp::FunctionNode<3> *> &inp_nodes) {
   193 |     Eigen::MatrixXd out_data;
   194 |     auto nNodes = inp_nodes.size();
   195 |     if (nNodes > 0) {
   196 |         auto nCoefs = inp_nodes[0]->getNCoefs();
   197 |         out_data = Eigen::MatrixXd::Zero(nNodes, nCoefs);
   198 |         for (auto i = 0; i < nNodes; i++) {
   199 |             auto &node = inp_nodes[i];
   200 |             Eigen::VectorXd row_i;
   201 |             node->getValues(row_i);
   202 |             if (row_i.size() != nCoefs) MSG_ABORT("Size mismatch");
   203 |             out_data.row(i) = row_i;
   204 |         }
   205 |     }
   206 |     return out_data;
   207 | }
   208 | 
   209 | /** @brief Put data from a matrix into FunctionNodes
   210 |  *
   211 |  * Each row of the input data is used as function values
   212 |  * of the corresponding FunctionNode in the output vector.
   213 |  * Matrix dimension: rows = nNodes, cols = nCoefs.
   214 |  *
   215 |  * param[inout] out_nodes Array of FunctionNodes
   216 |  * param[in] inp_data Matrix of function values
   217 |  */
   218 | void xc_utils::expand_nodes(std::vector<mrcpp::FunctionNode<3> *> &out_nodes, Eigen::MatrixXd &inp_data) {
   219 |     auto nFuncs = out_nodes.size();
   220 |     if (inp_data.rows() != nFuncs) MSG_ERROR("Size mismatch " << inp_data.rows() << " vs " << nFuncs);
   221 | 
   222 |     for (auto i = 0; i < nFuncs; i++) {
   223 |         auto &node = out_nodes[i];
   224 |         node->setValues(inp_data.row(i));
   225 |     }
   226 | }
   227 | 
   228 | /** @brief Compute the gradient using a log parametrization
   229 |  *
   230 |  * zeta = log(inp_func)
   231 |  * grad(inp_func) = inp_func * grad(zeta)
   232 |  *
   233 |  * param[in] diff_oper Derivative operator
   234 |  * param[in] inp_func Function to differentiate
   235 |  * param[out] out_grad Gradient of input function
   236 |  */
   237 | mrcpp::FunctionTreeVector<3> xc_utils::log_gradient(mrcpp::DerivativeOperator<3> &diff_oper, mrcpp::FunctionTree<3> &inp_func) {
   238 |     mrcpp::FunctionTree<3> zeta(inp_func.getMRA());
   239 |     mrcpp::copy_grid(zeta, inp_func);
   240 |     mrcpp::copy_func(zeta, inp_func);
   241 |     for (auto i = 0; i < zeta.getNEndNodes(); i++) {
   242 |         auto &node = zeta.getEndFuncNode(i);
   243 |         Eigen::VectorXd values;
   244 |         node.getValues(values);
   245 |         for (auto j = 0; j < node.getNCoefs(); j++) {
   246 |             if (values[j] > mrcpp::MachineZero) {
   247 |                 values[j] = std::log(values[j]);
   248 |             } else {
   249 |                 values[j] = mrcpp::MachineZero;
   250 |             }
   251 |         }
   252 |         node.setValues(values);
   253 |     }
   254 |     zeta.mwTransform(mrcpp::BottomUp);
   255 | 
   256 |     mrcpp::FunctionTreeVector<3> grad_zeta = mrcpp::gradient(diff_oper, zeta);
   257 | 
   258 |     mrcpp::FunctionTreeVector<3> out_grad;
   259 |     for (int i = 0; i < 3; i++) {
   260 |         mrcpp::FunctionTree<3> *grad_comp = new mrcpp::FunctionTree<3>(inp_func.getMRA());
   261 |         mrcpp::copy_grid(*grad_comp, inp_func);
   262 |         mrcpp::multiply(-1.0, *grad_comp, 1.0, inp_func, mrcpp::get_func(grad_zeta, i));
   263 |         out_grad.push_back(std::make_tuple(1.0, grad_comp));
   264 |     }
   265 |     mrcpp::clear(grad_zeta, true);
   266 |     return out_grad;
   267 | }
   268 | 
   269 | } // namespace mrdft
   270 | 
   271 | ===== END src/mrdft/xc_utils.cpp =====
   272 | 
   273 | ===== BEGIN src/mrdft/Functional.h =====
   274 | // ===== BEGIN src/mrdft/Functional.h =====
   275 | /*
   276 |  * MRChem, a numerical real-space code for molecular electronic structure
   277 |  * calculations within the self-consistent field (SCF) approximations of quantum
   278 |  * chemistry (Hartree-Fock and Density Functional Theory).
   279 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
   280 |  *
   281 |  * This file is part of MRChem.
   282 |  *
   283 |  * MRChem is free software: you can redistribute it and/or modify
   284 |  * it under the terms of the GNU Lesser General Public License as published by
   285 |  * the Free Software Foundation, either version 3 of the License, or
   286 |  * (at your option) any later version.
   287 |  *
   288 |  * MRChem is distributed in the hope that it will be useful,
   289 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
   290 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   291 |  * GNU Lesser General Public License for more details.
   292 |  *
   293 |  * You should have received a copy of the GNU Lesser General Public License
   294 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
   295 |  *
   296 |  * For information on the complete list of contributors to MRChem, see:
   297 |  * <https://mrchem.readthedocs.io/>
   298 |  */
   299 | 
   300 | #pragma once
   301 | 
   302 | #include <memory>
   303 | 
   304 | #include <Eigen/Core>
   305 | #include <MRCPP/MWFunctions>
   306 | #include <MRCPP/MWOperators>
   307 | #include <MRCPP/trees/FunctionNode.h>
   308 | #include <XCFun/xcfun.h>
   309 | 
   310 | namespace mrdft {
   311 | 
   312 | using XC_p = std::unique_ptr<xcfun_t, decltype(&xcfun_delete)>;
   313 | 
   314 | class Functional {
   315 | public:
   316 |     Functional(int k, XC_p &f)
   317 |             : order(k)
   318 |             , xcfun(std::move(f)) {}
   319 |     virtual ~Functional() = default;
   320 | 
   321 |     void makepot(mrcpp::FunctionTreeVector<3> &inp, std::vector<mrcpp::FunctionNode<3> *> xcNodes) const;
   322 | 
   323 |     void setLogGradient(bool log) { log_grad = log; }
   324 |     void setDensityCutoff(double cut) { cutoff = cut; }
   325 |     void setDerivOp(std::unique_ptr<mrcpp::DerivativeOperator<3>> &d) {derivOp = std::move(d);}
   326 | 
   327 |     virtual bool isSpin() const = 0;
   328 |     bool isLDA() const { return (not(isGGA() or isMetaGGA())); }
   329 |     bool isGGA() const { return xcfun_is_gga(xcfun.get()); }
   330 |     bool isMetaGGA() const { return xcfun_is_metagga(xcfun.get()); }
   331 |     bool isHybrid() const { return (std::abs(amountEXX()) > 1.0e-10); }
   332 |     double amountEXX() const {
   333 |         double exx = 0.0;
   334 |         xcfun_get(xcfun.get(), "exx", &exx);
   335 |         return exx;
   336 |     }
   337 |     double XCenergy = 0.0;
   338 | 
   339 |     // MAKE THESE VIRTUAL so LibXC subclasses can override them
   340 |     virtual Eigen::MatrixXd evaluate(Eigen::MatrixXd &inp) const;
   341 |     virtual Eigen::MatrixXd evaluate_transposed(Eigen::MatrixXd &inp) const;
   342 | 
   343 |     friend class MRDFT;
   344 | 
   345 | protected:
   346 |     const int order;
   347 |     bool log_grad{false};
   348 |     double cutoff{-1.0};
   349 |     Eigen::VectorXi d_mask;
   350 |     Eigen::MatrixXi xc_mask;
   351 |     XC_p xcfun;
   352 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> derivOp{nullptr};
   353 | 
   354 |     int getXCInputLength() const { return xcfun_input_length(xcfun.get()); }
   355 |     int getXCOutputLength() const { return xcfun_output_length(xcfun.get()); }
   356 |     virtual int getCtrInputLength() const = 0;
   357 |     virtual int getCtrOutputLength() const = 0;
   358 | 
   359 |     Eigen::MatrixXd contract(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const;
   360 |     Eigen::MatrixXd contract_transposed(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const;
   361 | 
   362 |     virtual void clear() = 0;
   363 |     virtual mrcpp::FunctionTreeVector<3> setupXCInput() = 0;
   364 |     virtual mrcpp::FunctionTreeVector<3> setupCtrInput() = 0;
   365 | 
   366 |     virtual void preprocess(mrcpp::FunctionTreeVector<3> &inp) = 0;
   367 |     virtual mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) = 0;
   368 | };
   369 | 
   370 | } // namespace mrdft
   371 | // ===== END src/mrdft/Functional.h =====
   372 | 
   373 | ===== END src/mrdft/Functional.h =====
   374 | 
   375 | ===== BEGIN src/mrdft/Functional.cpp =====
   376 | /*
   377 |  * MRChem, a numerical real-space code for molecular electronic structure
   378 |  * calculations within the self-consistent field (SCF) approximations of quantum
   379 |  * chemistry (Hartree-Fock and Density Functional Theory).
   380 |  * Copyright (C) ...
   381 |  */
   382 | 
   383 | #include <MRCPP/Printer>
   384 | 
   385 | #include "Functional.h"
   386 | 
   387 | namespace mrdft {
   388 | 
   389 | namespace {
   390 | // Put XCFun into a valid “user eval” mode so input_length/output_length work.
   391 | inline void ensure_xcfun_user_setup(xcfun_t* xf, int order, bool spin, bool is_gga) {
   392 |     const unsigned int mode      = 1u;                    // partial derivatives
   393 |     const unsigned int func_type = is_gga ? 1u : 0u;      // 0=LDA, 1=GGA
   394 |     const unsigned int dens_type = spin ? 2u : 1u;        // 1 (unpol) or 2 (pol)
   395 |     const unsigned int laplacian = 0u;
   396 |     const unsigned int kinetic   = 0u;
   397 |     const unsigned int current   = 0u;
   398 |     const unsigned int exp_deriv = is_gga ? 1u : 0u;      // explicit derivs for GGA only
   399 | 
   400 |     xcfun_user_eval_setup(xf, order, func_type, dens_type,
   401 |                           mode, laplacian, kinetic, current, exp_deriv);
   402 | }
   403 | } // namespace
   404 | 
   405 | /** @brief Run a collection of grid points through XCFun
   406 |  *
   407 |  * Each row corresponds to one grid point.
   408 |  */
   409 | Eigen::MatrixXd Functional::evaluate(Eigen::MatrixXd &inp) const {
   410 |     // Make sure XCFun knows what shape to expect/produce
   411 |     ensure_xcfun_user_setup(xcfun.get(), order, isSpin(), isGGA());
   412 | 
   413 |     int nInp = xcfun_input_length(xcfun.get());   // input parameters to XCFun
   414 |     int nOut = xcfun_output_length(xcfun.get());  // output parameters from XCFun
   415 |     int nPts = inp.cols();
   416 |     if (nInp != inp.rows()) MSG_ABORT("Invalid input");
   417 | 
   418 |     Eigen::MatrixXd out = Eigen::MatrixXd::Zero(nOut, nPts);
   419 |     for (int i = 0; i < nPts; i++) {
   420 |         bool calc = true;
   421 |         if (isSpin()) {
   422 |             if (inp(0, i) < cutoff and inp(1, i) < cutoff) calc = false;
   423 |         } else {
   424 |             if (inp(0, i) < cutoff) calc = false;
   425 |         }
   426 |         if (calc) xcfun_eval(xcfun.get(), inp.col(i).data(), out.col(i).data());
   427 |     }
   428 |     return out;
   429 | }
   430 | 
   431 | /** @brief Run a collection of grid points through XCFun
   432 |  *
   433 |  * Each column corresponds to one grid point.
   434 |  */
   435 | Eigen::MatrixXd Functional::evaluate_transposed(Eigen::MatrixXd &inp) const {
   436 |     // Make sure XCFun knows what shape to expect/produce
   437 |     ensure_xcfun_user_setup(xcfun.get(), order, isSpin(), isGGA());
   438 | 
   439 |     int nInp = xcfun_input_length(xcfun.get());   // input parameters to XCFun
   440 |     int nOut = xcfun_output_length(xcfun.get());  // output parameters from XCFun
   441 |     int nPts = inp.rows();
   442 |     if (nInp != inp.cols()) MSG_ABORT("Invalid input");
   443 | 
   444 |     Eigen::MatrixXd out = Eigen::MatrixXd::Zero(nPts, nOut);
   445 |     Eigen::VectorXd inp_row = Eigen::VectorXd::Zero(nInp);
   446 |     Eigen::VectorXd out_row = Eigen::VectorXd::Zero(nOut);
   447 |     for (int i = 0; i < nPts; i++) {
   448 |         bool calc = true;
   449 |         if (isSpin()) {
   450 |             if (inp(i, 0) < cutoff and inp(i, 1) < cutoff) calc = false;
   451 |         } else {
   452 |             if (inp(i, 0) < cutoff) calc = false;
   453 |         }
   454 |         for (int j = 0; j < nInp; j++) inp_row(j) = inp(i, j);
   455 |         if (calc) xcfun_eval(xcfun.get(), inp_row.data(), out_row.data());
   456 |         for (int j = 0; j < nOut; j++) out(i, j) = out_row(j);
   457 |     }
   458 |     return out;
   459 | }
   460 | 
   461 | /** @brief Contract (row-major) */
   462 | Eigen::MatrixXd Functional::contract(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const {
   463 |     auto nPts = xc_data.cols();
   464 |     auto nFcs = getCtrOutputLength();
   465 |     Eigen::MatrixXd out_data = Eigen::MatrixXd::Zero(nFcs, nPts);
   466 |     out_data.row(0) = xc_data.row(0); // keep energy functional
   467 | 
   468 |     for (int i = 0; i < this->xc_mask.rows(); i++) {
   469 |         Eigen::VectorXd cont_i = Eigen::VectorXd::Zero(nPts);
   470 |         for (int j = 0; j < this->xc_mask.cols(); j++) {
   471 |             Eigen::VectorXd cont_ij = Eigen::VectorXd::Zero(nPts);
   472 |             int xc_idx = this->xc_mask(i, j);
   473 |             int d_idx = this->d_mask(j);
   474 |             if (d_idx >= 0) {
   475 |                 cont_ij = xc_data.row(xc_idx).array() * d_data.row(d_idx).array();
   476 |             } else {
   477 |                 cont_ij = xc_data.row(xc_idx);
   478 |             }
   479 |             cont_i += cont_ij;
   480 |         }
   481 |         out_data.row(i + 1) = cont_i;
   482 |     }
   483 |     return out_data;
   484 | }
   485 | 
   486 | /** @brief Contract (column-major) */
   487 | Eigen::MatrixXd Functional::contract_transposed(Eigen::MatrixXd &xc_data, Eigen::MatrixXd &d_data) const {
   488 |     auto nPts = xc_data.rows();
   489 |     auto nFcs = getCtrOutputLength();
   490 |     Eigen::MatrixXd out_data = Eigen::MatrixXd::Zero(nPts, nFcs);
   491 |     out_data.col(0) = xc_data.col(0); // keep energy functional
   492 | 
   493 |     for (int i = 0; i < this->xc_mask.rows(); i++) {
   494 |         for (int j = 0; j < this->xc_mask.cols(); j++) {
   495 |             int xc_idx = this->xc_mask(i, j);
   496 |             int d_idx = this->d_mask(j);
   497 |             if (d_idx >= 0) {
   498 |                 out_data.col(i + 1) += xc_data.col(xc_idx).cwiseProduct(d_data.col(d_idx));
   499 |             } else {
   500 |                 out_data.col(i + 1) += xc_data.col(xc_idx);
   501 |             }
   502 |         }
   503 |     }
   504 |     return out_data;
   505 | }
   506 | 
   507 | /** @brief makepot: compute XC and contract */
   508 | void Functional::makepot(mrcpp::FunctionTreeVector<3> &inp, std::vector<mrcpp::FunctionNode<3> *> xcNodes)  const {
   509 |     if (this->log_grad){
   510 |         MSG_ERROR("log_grad not implemented");
   511 |     }
   512 | 
   513 |     mrcpp::NodeIndex<3> nodeIdx = xcNodes[0]->getNodeIndex();
   514 |     mrcpp::FunctionTree<3>* rho0=std::get<1>(inp[0]);
   515 |     mrcpp::MWNode<3> node(rho0->getNode(nodeIdx),true,false);
   516 |     int ncoefs = rho0->getTDim() * rho0->getKp1_d();
   517 |     int xcfun_inpsize = 1; // rho
   518 |     int spinsize = 1; // paired
   519 |     if (isSpin()) spinsize = 2; // alpha, beta
   520 |     xcfun_inpsize *= spinsize; // alpha and beta
   521 |     if (isGGA()) xcfun_inpsize *= 4; // add gradient (3 components for each spin)
   522 | 
   523 |     Eigen::MatrixXd xcfun_inp(ncoefs, xcfun_inpsize);
   524 |     double* coef = node.getCoefs();
   525 | 
   526 |     for (int i = 0; i < spinsize; i++) {
   527 |         mrcpp::FunctionTree<3>* rho=std::get<1>(inp[i]);
   528 |         node.attachCoefs(xcfun_inp.col(i).data());
   529 |         for (int j = 0; j < ncoefs; j++) xcfun_inp(j,i) = rho->getNode(nodeIdx).getCoefs()[j];
   530 |         node.mwTransform(mrcpp::Reconstruction);
   531 |         node.cvTransform(mrcpp::Forward);
   532 | 
   533 |         if (isGGA()) {
   534 |             for (int d = 0; d < 3; d++) {
   535 |                 node.attachCoefs(xcfun_inp.col(spinsize + 3*i + d).data());
   536 |                 mrcpp::DerivativeCalculator<3> derivcalc(d, *this->derivOp, *rho);
   537 |                 derivcalc.calcNode(rho->getNode(nodeIdx), node);
   538 |                 node.mwTransform(mrcpp::Reconstruction);
   539 |                 node.cvTransform(mrcpp::Forward);
   540 |             }
   541 |        }
   542 |     }
   543 | 
   544 |     // NB: VIRTUAL DISPATCH here (so LibXC adapters can override)!
   545 |     Eigen::MatrixXd xc_out = this->evaluate_transposed(xcfun_inp);
   546 | 
   547 |     int ctrsize = inp.size()-spinsize;
   548 |     int d_datasize = ctrsize;
   549 |     if (isGGA()) d_datasize *= 4;
   550 |     Eigen::MatrixXd d_data = Eigen::MatrixXd::Zero(ncoefs, d_datasize);
   551 |     if (d_datasize > 0) {
   552 |         for (int i = 0; i < ctrsize; i++) {
   553 |             mrcpp::FunctionTree<3>* rho = std::get<1>(inp[i+spinsize]);
   554 |             node.attachCoefs(d_data.col(i).data());
   555 |             for (int j = 0; j < ncoefs; j++) d_data(j,i) = rho->getNode(nodeIdx).getCoefs()[j];
   556 |             node.mwTransform(mrcpp::Reconstruction);
   557 |             node.cvTransform(mrcpp::Forward);
   558 |             if (isGGA()) {
   559 |                 for (int d = 0; d < 3; d++) {
   560 |                     node.attachCoefs(d_data.col(ctrsize + 3*i + d).data());
   561 |                     mrcpp::DerivativeCalculator<3> derivcalc(d, *this->derivOp, *rho);
   562 |                     derivcalc.calcNode(rho->getNode(nodeIdx), node);
   563 |                     node.mwTransform(mrcpp::Reconstruction);
   564 |                     node.cvTransform(mrcpp::Forward);
   565 |                 }
   566 |             }
   567 |         }
   568 |     }
   569 | 
   570 |     Eigen::MatrixXd Ctrout = contract_transposed(xc_out, d_data);
   571 | 
   572 |     int xc_outsize = 2;
   573 |     if (isSpin()) xc_outsize = 3;
   574 |     for (int i = 0; i < xc_outsize; i++) {
   575 |         node.attachCoefs(Ctrout.col(i).data());
   576 |         node.cvTransform(mrcpp::Backward);
   577 |         node.mwTransform(mrcpp::Compression);
   578 |         for (int j = 0; j < ncoefs; j++) xcNodes[i]->getCoefs()[j] = Ctrout(j,i);
   579 |         xcNodes[i]->setHasCoefs();
   580 |         if (isGGA() and i>0) {
   581 |             for (int d = 0; d < 3; d++) {
   582 |                 node.attachCoefs(Ctrout.col(xc_outsize + 3*(i-1) + d).data());
   583 |                 node.cvTransform(mrcpp::Backward);
   584 |                 node.mwTransform(mrcpp::Compression);
   585 |                 mrcpp::DerivativeCalculator<3> derivcalc(d,*this->derivOp, *rho0);
   586 |                 mrcpp::MWNode<3> noded(rho0->getNode(nodeIdx),true,false);
   587 |                 derivcalc.calcNode(node, noded);
   588 |                 for (int j = 0; j < ncoefs; j++) xcNodes[i]->getCoefs()[j] -= noded.getCoefs()[j];
   589 |             }
   590 |         }
   591 |     }
   592 |     node.attachCoefs(coef);
   593 | }
   594 | 
   595 | } // namespace mrdft
   596 | 
   597 | ===== END src/mrdft/Functional.cpp =====
   598 | 
   599 | ===== BEGIN src/mrdft/Factory.h =====
   600 | #pragma once
   601 | 
   602 | #include <MRCPP/MWOperators>
   603 | #include <XCFun/xcfun.h>
   604 | 
   605 | #include "MRDFT.h"
   606 | 
   607 | namespace mrdft {
   608 | 
   609 | class Factory final {
   610 | public:
   611 |     Factory(const mrcpp::MultiResolutionAnalysis<3> &MRA);
   612 |     ~Factory() = default;
   613 | 
   614 |     void setSpin(bool s) { spin = s; }
   615 |     void setOrder(int k) { order = k; }
   616 |     void setUseGamma(bool g) { gamma = g; }
   617 |     void setLogGradient(bool lg) { log_grad = lg; }
   618 |     void setDensityCutoff(double c) { cutoff = c; }
   619 |     void setDerivative(const std::string &n) { diff_s = n; }
   620 |     void setFunctional(const std::string &n, double c = 1.0) { xcfun_set(xcfun_p.get(), n.c_str(), c); }
   621 | 
   622 |     // Optional: select backend and (for LibXC) functional IDs via code (we also read env vars)
   623 |     void setBackend(const std::string &b) { backend = b; }
   624 |     void setLibXCIDs(const std::vector<int> &ids_in) { libxc_ids = ids_in; }
   625 | 
   626 |     std::unique_ptr<MRDFT> build();
   627 | 
   628 | private:
   629 |     int order{1};
   630 |     bool spin{false};
   631 |     bool gamma{false};
   632 |     bool log_grad{false};
   633 |     double cutoff{-1.0};
   634 |     std::string diff_s{"abgv_00"};
   635 |     std::string backend{"xcfun"};           // "xcfun" (default) or "libxc"
   636 |     std::vector<int> libxc_ids;             // used only if backend == "libxc"
   637 |     const mrcpp::MultiResolutionAnalysis<3> mra;
   638 | 
   639 |     XC_p xcfun_p;
   640 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> diff_p;
   641 | };
   642 | 
   643 | } // namespace mrdft
   644 | 
   645 | ===== END src/mrdft/Factory.h =====
   646 | 
   647 | ===== BEGIN src/mrdft/Factory.cpp =====
   648 | /*
   649 |  * MRChem, a numerical real-space code for molecular electronic structure
   650 |  * calculations within the self-consistent field (SCF) approximations of quantum
   651 |  * chemistry (Hartree-Fock and Density Functional Theory).
   652 |  * Copyright (C) ...
   653 |  *
   654 |  * For information on the complete list of contributors to MRChem, see:
   655 |  * <https://mrchem.readthedocs.io/>
   656 |  */
   657 | 
   658 | #include "Factory.h"
   659 | 
   660 | #include <algorithm>
   661 | #include <cctype>
   662 | #include <cstdlib>
   663 | #include <sstream>
   664 | #include <string>
   665 | #include <vector>
   666 | 
   667 | #include <MRCPP/MWOperators>
   668 | #include <MRCPP/Printer>
   669 | #include <XCFun/xcfun.h>
   670 | 
   671 | #include "GGA.h"
   672 | #include "Grid.h"
   673 | #include "LDA.h"
   674 | #include "MRDFT.h"
   675 | #include "SpinGGA.h"
   676 | #include "SpinLDA.h"
   677 | 
   678 | // LibXC adapters (already added to your tree)
   679 | #include "LibXCBackend.h"
   680 | 
   681 | namespace mrdft {
   682 | 
   683 | static std::string to_lower(std::string s) {
   684 |     std::transform(s.begin(), s.end(), s.begin(),
   685 |                    [](unsigned char c){ return static_cast<char>(std::tolower(c)); });
   686 |     return s;
   687 | }
   688 | 
   689 | Factory::Factory(const mrcpp::MultiResolutionAnalysis<3> &MRA)
   690 |         : mra(MRA)
   691 |         , xcfun_p(xcfun_new(), xcfun_delete) {}
   692 | 
   693 | /** @brief Build a MRDFT object from the currently defined parameters */
   694 | std::unique_ptr<MRDFT> Factory::build() {
   695 |     // Init DFT grid
   696 |     auto grid_p = std::make_unique<Grid>(mra);
   697 | 
   698 |     // Decide backend (member setting can be overridden by env)
   699 |     std::string backend_eff = to_lower(backend);
   700 |     if (const char* be = std::getenv("MRCHEM_XC_BACKEND")) {
   701 |         backend_eff = to_lower(std::string(be));
   702 |     }
   703 |     const bool use_libxc = (backend_eff == "libxc");
   704 | 
   705 |     // If LibXC is requested, make sure we have functional IDs
   706 |     std::vector<int> ids = libxc_ids;
   707 |     if (use_libxc && ids.empty()) {
   708 |         if (const char* ids_env = std::getenv("MRCHEM_LIBXC_IDS")) {
   709 |             std::stringstream ss(ids_env);
   710 |             for (std::string tok; std::getline(ss, tok, ','); ) {
   711 |                 if (!tok.empty()) ids.push_back(std::stoi(tok));
   712 |             }
   713 |         }
   714 |         if (ids.empty()) {
   715 |             MSG_ABORT("LibXC backend selected but no LibXC IDs specified. "
   716 |                       "Set MRCHEM_LIBXC_IDS (e.g. 1,9 for LDA X+PW92 C or 106,131 for BLYP), "
   717 |                       "or call Factory::setLibXCIDs().");
   718 |         }
   719 |     }
   720 | 
   721 |     // Init XCFun (still used for masks, meta info, etc., and for the XCFun path)
   722 |     bool gga = xcfun_is_gga(xcfun_p.get());
   723 |     bool lda = not(gga);
   724 |     unsigned int mode = 1;                    //!< only partial derivative mode implemented
   725 |     unsigned int func_type = (gga) ? 1 : 0;   //!< only LDA and GGA supported for now
   726 |     unsigned int dens_type = 1 + spin;        //!< n (1) or alpha&beta (2)
   727 |     unsigned int laplacian = 0;               //!< no laplacian
   728 |     unsigned int kinetic = 0;                 //!< no kinetic energy density
   729 |     unsigned int current = 0;                 //!< no current density
   730 |     unsigned int exp_derivative = not(gamma); //!< use gamma or explicit derivatives
   731 |     if (not(gga)) exp_derivative = 0;         //!< fall back to gamma-type derivatives if LDA
   732 |     xcfun_user_eval_setup(xcfun_p.get(), order, func_type, dens_type,
   733 |                           mode, laplacian, kinetic, current, exp_derivative);
   734 | 
   735 |     // Init MW derivative if GGA
   736 |     if (gga) {
   737 |         if (diff_s == "bspline") diff_p = std::make_unique<mrcpp::BSOperator<3>>(mra, 1);
   738 |         if (diff_s == "abgv_00") diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.0, 0.0);
   739 |         if (diff_s == "abgv_55") diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.5, 0.5);
   740 |     }
   741 | 
   742 |     // Init XC functional (choose LibXC adapters when requested)
   743 |     std::unique_ptr<Functional> func_p{nullptr};
   744 |     if (spin) {
   745 |         if (gga) {
   746 |             if (use_libxc) func_p = std::make_unique<LibXCSpinGGA>(order, xcfun_p, diff_p, ids);
   747 |             else           func_p = std::make_unique<SpinGGA>(order, xcfun_p, diff_p);
   748 |         }
   749 |         if (lda) {
   750 |             if (use_libxc) func_p = std::make_unique<LibXCSpinLDA>(order, xcfun_p, ids);
   751 |             else           func_p = std::make_unique<SpinLDA>(order, xcfun_p);
   752 |         }
   753 |     } else {
   754 |         if (gga) {
   755 |             if (use_libxc) func_p = std::make_unique<LibXCGGA>(order, xcfun_p, diff_p, ids);
   756 |             else           func_p = std::make_unique<GGA>(order, xcfun_p, diff_p);
   757 |         }
   758 |         if (lda) {
   759 |             if (use_libxc) func_p = std::make_unique<LibXCLDA>(order, xcfun_p, ids);
   760 |             else           func_p = std::make_unique<LDA>(order, xcfun_p);
   761 |         }
   762 |     }
   763 |     if (func_p == nullptr) MSG_ABORT("Invalid functional type");
   764 | 
   765 |     // (Keep your original behavior here)
   766 |     diff_p = std::make_unique<mrcpp::ABGVOperator<3>>(mra, 0.0, 0.0);
   767 |     func_p->setDerivOp(diff_p);
   768 |     func_p->setLogGradient(log_grad);
   769 |     func_p->setDensityCutoff(cutoff);
   770 | 
   771 |     auto mrdft_p = std::make_unique<MRDFT>(grid_p, func_p);
   772 |     return mrdft_p;
   773 | }
   774 | 
   775 | } // namespace mrdft
   776 | 
   777 | ===== END src/mrdft/Factory.cpp =====
   778 | 
   779 | ===== BEGIN src/mrdft/LDA.h =====
   780 | #pragma once
   781 | 
   782 | #include <XCFun/xcfun.h>
   783 | #include "Functional.h"
   784 | 
   785 | namespace mrdft {
   786 | 
   787 | class LDA : public Functional {
   788 | public:
   789 |     LDA(int k, XC_p &f);
   790 |     ~LDA() override = default;
   791 | 
   792 |     bool isSpin() const override { return false; }
   793 | 
   794 | private:
   795 |     mrcpp::FunctionTreeVector<3> rho;
   796 | 
   797 |     int getCtrInputLength() const override;
   798 |     int getCtrOutputLength() const override { return 2; }
   799 | 
   800 |     void clear() override;
   801 |     mrcpp::FunctionTreeVector<3> setupXCInput() override;
   802 |     mrcpp::FunctionTreeVector<3> setupCtrInput() override;
   803 | 
   804 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
   805 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
   806 | };
   807 | 
   808 | } // namespace mrdft
   809 | 
   810 | ===== END src/mrdft/LDA.h =====
   811 | 
   812 | ===== BEGIN src/mrdft/LDA.cpp =====
   813 | /*
   814 |  * (banner unchanged)
   815 |  */
   816 | 
   817 | #include "MRCPP/MWFunctions"
   818 | #include "MRCPP/Printer"
   819 | 
   820 | #include "LDA.h"
   821 | #include "xc_utils.h"
   822 | 
   823 | namespace mrdft {
   824 | 
   825 | LDA::LDA(int k, XC_p &f)
   826 |         : Functional(k, f) {
   827 |     xc_mask = xc_utils::build_output_mask(true, false, this->order);
   828 |     d_mask = xc_utils::build_density_mask(true, false, this->order);
   829 | }
   830 | 
   831 | /** @brief Clear internal functions
   832 |  *
   833 |  * Ownership of densities is outside MRDFT -> clear
   834 |  * Ownership of gradients is inside MRDFT -> free
   835 |  */
   836 | void LDA::clear() {
   837 |     mrcpp::clear(this->rho, false);
   838 | }
   839 | 
   840 | /** @brief Number of function involved in contraction step */
   841 | int LDA::getCtrInputLength() const {
   842 |     int length = -1;
   843 |     if (this->order < 2) length = 0;
   844 |     if (this->order == 2) length = 1;
   845 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
   846 |     return length;
   847 | }
   848 | 
   849 | /** @brief Collect input functions to xcfun evaluation step
   850 |  *
   851 |  * For LDA : [rho_0]
   852 |  */
   853 | mrcpp::FunctionTreeVector<3> LDA::setupXCInput() {
   854 |     if (this->rho.size() < 1) MSG_ERROR("Density not initialized");
   855 |     mrcpp::FunctionTreeVector<3> out_vec;
   856 |     out_vec.push_back(this->rho[0]);
   857 |     return out_vec;
   858 | }
   859 | 
   860 | /** @brief Collect input functions to contraction step
   861 |  *
   862 |  * For LDA:
   863 |  * Ground State: No contraction, empty vector
   864 |  * Linear Response: [rho_1]
   865 |  * Higher Response: NOT_IMPLEMENTED
   866 |  */
   867 | mrcpp::FunctionTreeVector<3> LDA::setupCtrInput() {
   868 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
   869 |     mrcpp::FunctionTreeVector<3> out_vec;
   870 |     if (order == 2) out_vec.push_back(this->rho[1]);
   871 |     return out_vec;
   872 | }
   873 | 
   874 | /** @brief Prepare input functions to xcfun
   875 |  *
   876 |  * Collects input densities and computes necessary gradients.
   877 |  *
   878 |  * Ordering of input:
   879 |  * inp_vec[0] = alpha_0
   880 |  * inp_vec[1] = beta_0
   881 |  * inp_vec[2] = alpha_1
   882 |  * inp_vec[3] = beta_1
   883 |  * ...
   884 |  */
   885 | void LDA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
   886 |     if (inp_vec.size() != this->order) MSG_ERROR("Invalid input length");
   887 |     if (this->rho.size() > 0) MSG_ERROR("Density not empty");
   888 | 
   889 |     for (auto i = 0; i < this->order; i++) this->rho.push_back(inp_vec[i]);
   890 | }
   891 | 
   892 | /** @brief Compute final output functions
   893 |  *
   894 |  * Combine the raw partial derivatives from xcfun into functional derivatives.
   895 |  *
   896 |  * For LDA:
   897 |  * f_xc       : out[0] = inp[0]
   898 |  * df_xc/drho : out[1] = inp[1]
   899 |  */
   900 | mrcpp::FunctionTreeVector<3> LDA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
   901 |     // Energy density
   902 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
   903 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
   904 | 
   905 |     // XC potential
   906 |     mrcpp::FunctionTree<3> &v_xc = mrcpp::get_func(inp_vec, 1);
   907 |     inp_vec[1] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
   908 | 
   909 |     mrcpp::FunctionTreeVector<3> out_vec;
   910 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
   911 |     out_vec.push_back(std::make_tuple(1.0, &v_xc));
   912 |     return out_vec;
   913 | }
   914 | 
   915 | } // namespace mrdft
   916 | 
   917 | ===== END src/mrdft/LDA.cpp =====
   918 | 
   919 | ===== BEGIN src/mrdft/GGA.h =====
   920 | #pragma once
   921 | 
   922 | #include <XCFun/xcfun.h>
   923 | #include "Functional.h"
   924 | 
   925 | namespace mrdft {
   926 | 
   927 | class GGA : public Functional {
   928 | public:
   929 |     GGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d);
   930 |     ~GGA() override = default;
   931 | 
   932 |     bool isSpin() const override { return false; }
   933 | 
   934 | private:
   935 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> derivative{nullptr};
   936 |     mrcpp::FunctionTreeVector<3> rho;
   937 |     mrcpp::FunctionTreeVector<3> grad;
   938 | 
   939 |     int getCtrInputLength() const override;
   940 |     int getCtrOutputLength() const override { return 5; }
   941 | 
   942 |     void clear() override;
   943 |     mrcpp::FunctionTreeVector<3> setupXCInput() override;
   944 |     mrcpp::FunctionTreeVector<3> setupCtrInput() override;
   945 | 
   946 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
   947 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
   948 | };
   949 | 
   950 | } // namespace mrdft
   951 | 
   952 | ===== END src/mrdft/GGA.h =====
   953 | 
   954 | ===== BEGIN src/mrdft/GGA.cpp =====
   955 | /*
   956 |  * (banner unchanged)
   957 |  */
   958 | #include "MRCPP/MWOperators"
   959 | #include "MRCPP/Printer"
   960 | 
   961 | #include "GGA.h"
   962 | #include "xc_utils.h"
   963 | 
   964 | namespace mrdft {
   965 | 
   966 | GGA::GGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d)
   967 |         : Functional(k, f)
   968 |         , derivative(std::move(d)) {
   969 |     xc_mask = xc_utils::build_output_mask(false, false, this->order);
   970 |     d_mask = xc_utils::build_density_mask(false, false, this->order);
   971 | }
   972 | 
   973 | /** @brief Clear internal functions
   974 |  *
   975 |  * Ownership of densities is outside MRDFT -> clear
   976 |  * Ownership of gradients is inside MRDFT -> free
   977 |  */
   978 | void GGA::clear() {
   979 |     mrcpp::clear(this->rho, false);
   980 |     mrcpp::clear(this->grad, true);
   981 | }
   982 | 
   983 | /** @brief Number of function involved in contraction step */
   984 | int GGA::getCtrInputLength() const {
   985 |     int length = -1;
   986 |     if (this->order < 2) length = 0;
   987 |     if (this->order == 2) length = 4;
   988 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
   989 |     return length;
   990 | }
   991 | 
   992 | /** @brief Collect input functions to xcfun evaluation step
   993 |  *
   994 |  * For GGA : [rho_0, grad(rho_0)]
   995 |  */
   996 | mrcpp::FunctionTreeVector<3> GGA::setupXCInput() {
   997 |     if (this->rho.size() < 1) MSG_ERROR("Density not initialized");
   998 |     if (this->grad.size() < 3) MSG_ERROR("Gradient not initialized");
   999 | 
  1000 |     mrcpp::FunctionTreeVector<3> out_vec;
  1001 |     out_vec.push_back(this->rho[0]);
  1002 |     out_vec.insert(out_vec.end(), this->grad.begin(), this->grad.begin() + 3);
  1003 |     return out_vec;
  1004 | }
  1005 | 
  1006 | /** @brief Collect input functions to contraction step
  1007 |  *
  1008 |  * For GGA:
  1009 |  * Ground State: No contraction, empty vector
  1010 |  * Linear Response: [rho_1, grad(rho_1)]
  1011 |  * Higher Response: NOT_IMPLEMENTED
  1012 |  */
  1013 | mrcpp::FunctionTreeVector<3> GGA::setupCtrInput() {
  1014 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
  1015 |     mrcpp::FunctionTreeVector<3> out_vec;
  1016 |     if (this->order == 2) {
  1017 |         out_vec.push_back(this->rho[1]);
  1018 |         out_vec.insert(out_vec.end(), this->grad.begin() + 3, this->grad.begin() + 6);
  1019 |     }
  1020 |     return out_vec;
  1021 | }
  1022 | 
  1023 | /** @brief Prepare input functions to xcfun
  1024 |  *
  1025 |  * Collects input densities and computes necessary gradients.
  1026 |  */
  1027 | void GGA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1028 |     if (inp_vec.size() != this->order) MSG_ERROR("Invalid input length");
  1029 |     if (this->rho.size() > 0) MSG_ERROR("Density not empty");
  1030 |     if (this->grad.size() > 0) MSG_ERROR("Gradient not empty");
  1031 | 
  1032 |     int n = 0;
  1033 |     for (int i = 0; i < this->order; i++) this->rho.push_back(inp_vec[n++]);
  1034 | 
  1035 |     for (int i = 0; i < this->order; i++) {
  1036 |         mrcpp::FunctionTreeVector<3> tmp;
  1037 |         if (this->log_grad and i == 0) {
  1038 |             tmp = xc_utils::log_gradient(*this->derivative, mrcpp::get_func(this->rho, i));
  1039 |         } else {
  1040 |             tmp = mrcpp::gradient(*this->derivative, mrcpp::get_func(this->rho, i));
  1041 |         }
  1042 |         this->grad.insert(this->grad.end(), tmp.begin(), tmp.end());
  1043 |     }
  1044 | }
  1045 | 
  1046 | /** @brief Compute final output functions
  1047 |  *
  1048 |  * For GGA:
  1049 |  * f_xc       : out[0] = inp[0]
  1050 |  * df_xc/drho : out[1] = inp[1] - div(inp[2,3,4])
  1051 |  */
  1052 | mrcpp::FunctionTreeVector<3> GGA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1053 |     // Energy density
  1054 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
  1055 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1056 | 
  1057 |     // Potential part
  1058 |     mrcpp::FunctionTree<3> &df_dr = mrcpp::get_func(inp_vec, 1);
  1059 |     mrcpp::FunctionTreeVector<3> df_dg(inp_vec.begin() + 2, inp_vec.begin() + 5);
  1060 | 
  1061 |     auto *tmp = new mrcpp::FunctionTree<3>(df_dr.getMRA());
  1062 |     mrcpp::divergence(*tmp, *this->derivative, df_dg);
  1063 | 
  1064 |     auto *v_xc = new mrcpp::FunctionTree<3>(df_dr.getMRA());
  1065 |     mrcpp::build_grid(*v_xc, df_dr);
  1066 |     mrcpp::build_grid(*v_xc, *tmp);
  1067 |     mrcpp::add(-1.0, *v_xc, 1.0, df_dr, -1.0, *tmp);
  1068 |     delete tmp;
  1069 | 
  1070 |     // Collect output
  1071 |     mrcpp::FunctionTreeVector<3> out_vec;
  1072 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
  1073 |     out_vec.push_back(std::make_tuple(1.0, v_xc));
  1074 |     v_xc = nullptr;
  1075 | 
  1076 |     return out_vec;
  1077 | }
  1078 | 
  1079 | } // namespace mrdft
  1080 | 
  1081 | ===== END src/mrdft/GGA.cpp =====
  1082 | 
  1083 | ===== BEGIN src/mrdft/SpinLDA.h =====
  1084 | #pragma once
  1085 | 
  1086 | #include <XCFun/xcfun.h>
  1087 | #include "Functional.h"
  1088 | 
  1089 | namespace mrdft {
  1090 | 
  1091 | class SpinLDA : public Functional {
  1092 | public:
  1093 |     SpinLDA(int k, XC_p &f);
  1094 |     ~SpinLDA() override = default;
  1095 | 
  1096 |     bool isSpin() const override { return true; }
  1097 | 
  1098 | private:
  1099 |     mrcpp::FunctionTreeVector<3> rho_a;
  1100 |     mrcpp::FunctionTreeVector<3> rho_b;
  1101 | 
  1102 |     int getCtrInputLength() const override;
  1103 |     int getCtrOutputLength() const override { return 3; }
  1104 | 
  1105 |     void clear() override;
  1106 |     mrcpp::FunctionTreeVector<3> setupXCInput() override;
  1107 |     mrcpp::FunctionTreeVector<3> setupCtrInput() override;
  1108 | 
  1109 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
  1110 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
  1111 | };
  1112 | 
  1113 | } // namespace mrdft
  1114 | 
  1115 | ===== END src/mrdft/SpinLDA.h =====
  1116 | 
  1117 | ===== BEGIN src/mrdft/SpinLDA.cpp =====
  1118 | /*
  1119 |  * (banner unchanged)
  1120 |  */
  1121 | 
  1122 | #include "MRCPP/MWFunctions"
  1123 | #include "MRCPP/Printer"
  1124 | 
  1125 | #include "SpinLDA.h"
  1126 | #include "xc_utils.h"
  1127 | 
  1128 | namespace mrdft {
  1129 | 
  1130 | SpinLDA::SpinLDA(int k, XC_p &f)
  1131 |         : Functional(k, f) {
  1132 |     xc_mask = xc_utils::build_output_mask(true, true, this->order);
  1133 |     d_mask = xc_utils::build_density_mask(true, true, this->order);
  1134 | }
  1135 | 
  1136 | /** @brief Clear internal functions
  1137 |  *
  1138 |  * Ownership of densities is outside MRDFT -> clear
  1139 |  * Ownership of gradients is inside MRDFT -> free
  1140 |  */
  1141 | void SpinLDA::clear() {
  1142 |     mrcpp::clear(this->rho_a, false);
  1143 |     mrcpp::clear(this->rho_b, false);
  1144 | }
  1145 | 
  1146 | /** @brief Number of function involved in contraction step */
  1147 | int SpinLDA::getCtrInputLength() const {
  1148 |     int length = -1;
  1149 |     if (this->order < 2) length = 0;
  1150 |     if (this->order == 2) length = 2;
  1151 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
  1152 |     return length;
  1153 | }
  1154 | 
  1155 | /** @brief Collect input functions to xcfun evaluation step
  1156 |  *
  1157 |  * For SpinLDA : [alpha_0, beta_0]
  1158 |  */
  1159 | mrcpp::FunctionTreeVector<3> SpinLDA::setupXCInput() {
  1160 |     if (this->rho_a.size() < 1) MSG_ERROR("Alpha density not initialized");
  1161 |     if (this->rho_b.size() < 1) MSG_ERROR("Beta density not initialized");
  1162 | 
  1163 |     mrcpp::FunctionTreeVector<3> out_vec;
  1164 |     out_vec.push_back(this->rho_a[0]);
  1165 |     out_vec.push_back(this->rho_b[0]);
  1166 |     return out_vec;
  1167 | }
  1168 | 
  1169 | /** @brief Collect input functions to contraction step
  1170 |  *
  1171 |  * For SpinLDA:
  1172 |  * Ground State: No contraction, empty vector
  1173 |  * Linear Response: [alpha_1, beta_1]
  1174 |  * Higher Response: NOT_IMPLEMENTED
  1175 |  */
  1176 | mrcpp::FunctionTreeVector<3> SpinLDA::setupCtrInput() {
  1177 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
  1178 |     mrcpp::FunctionTreeVector<3> out_vec;
  1179 |     if (order == 2) {
  1180 |         out_vec.push_back(this->rho_a[1]);
  1181 |         out_vec.push_back(this->rho_b[1]);
  1182 |     }
  1183 |     return out_vec;
  1184 | }
  1185 | 
  1186 | /** @brief Prepare input functions to xcfun
  1187 |  *
  1188 |  * Collects input densities and computes necessary gradients.
  1189 |  */
  1190 | void SpinLDA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1191 |     if (inp_vec.size() != 2 * this->order) MSG_ERROR("Invalid input length");
  1192 |     if (this->rho_a.size() > 0) MSG_ERROR("Alpha density not empty");
  1193 |     if (this->rho_b.size() > 0) MSG_ERROR("Beta density not empty");
  1194 | 
  1195 |     int n = 0;
  1196 |     for (int i = 0; i < this->order; i++) {
  1197 |         this->rho_a.push_back(inp_vec[n++]);
  1198 |         this->rho_b.push_back(inp_vec[n++]);
  1199 |     }
  1200 | }
  1201 | 
  1202 | /** @brief Compute final output functions
  1203 |  *
  1204 |  * For SpinLDA:
  1205 |  * f_xc         : out[0] = inp[0]
  1206 |  * df_xc/drho_a : out[1] = inp[1]
  1207 |  * df_xc/drho_b : out[2] = inp[2]
  1208 |  */
  1209 | mrcpp::FunctionTreeVector<3> SpinLDA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1210 |     // Energy density
  1211 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
  1212 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1213 | 
  1214 |     // Alpha potential
  1215 |     mrcpp::FunctionTree<3> &v_a = mrcpp::get_func(inp_vec, 1);
  1216 |     inp_vec[1] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1217 | 
  1218 |     // Beta potential
  1219 |     mrcpp::FunctionTree<3> &v_b = mrcpp::get_func(inp_vec, 2);
  1220 |     inp_vec[2] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1221 | 
  1222 |     // Collect output
  1223 |     mrcpp::FunctionTreeVector<3> out_vec;
  1224 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
  1225 |     out_vec.push_back(std::make_tuple(1.0, &v_a));
  1226 |     out_vec.push_back(std::make_tuple(1.0, &v_b));
  1227 |     return out_vec;
  1228 | }
  1229 | } // namespace mrdft
  1230 | 
  1231 | ===== END src/mrdft/SpinLDA.cpp =====
  1232 | 
  1233 | ===== BEGIN src/mrdft/SpinGGA.h =====
  1234 | #pragma once
  1235 | 
  1236 | #include <XCFun/xcfun.h>
  1237 | #include "Functional.h"
  1238 | 
  1239 | namespace mrdft {
  1240 | 
  1241 | class SpinGGA : public Functional {
  1242 | public:
  1243 |     SpinGGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d);
  1244 |     ~SpinGGA() override = default;
  1245 | 
  1246 |     bool isSpin() const override { return true; }
  1247 | 
  1248 | private:
  1249 |     std::unique_ptr<mrcpp::DerivativeOperator<3>> derivative{nullptr};
  1250 |     mrcpp::FunctionTreeVector<3> rho_a;
  1251 |     mrcpp::FunctionTreeVector<3> rho_b;
  1252 |     mrcpp::FunctionTreeVector<3> grad_a;
  1253 |     mrcpp::FunctionTreeVector<3> grad_b;
  1254 | 
  1255 |     int getCtrInputLength() const override;
  1256 |     int getCtrOutputLength() const override { return 9; }
  1257 | 
  1258 |     void clear() override;
  1259 |     mrcpp::FunctionTreeVector<3> setupXCInput() override;
  1260 |     mrcpp::FunctionTreeVector<3> setupCtrInput() override;
  1261 | 
  1262 |     void preprocess(mrcpp::FunctionTreeVector<3> &inp) override;
  1263 |     mrcpp::FunctionTreeVector<3> postprocess(mrcpp::FunctionTreeVector<3> &inp) override;
  1264 | };
  1265 | 
  1266 | } // namespace mrdft
  1267 | 
  1268 | ===== END src/mrdft/SpinGGA.h =====
  1269 | 
  1270 | ===== BEGIN src/mrdft/SpinGGA.cpp =====
  1271 | /*
  1272 |  * (banner unchanged)
  1273 |  */
  1274 | 
  1275 | #include "MRCPP/MWOperators"
  1276 | #include "MRCPP/Printer"
  1277 | 
  1278 | #include "SpinGGA.h"
  1279 | #include "xc_utils.h"
  1280 | 
  1281 | namespace mrdft {
  1282 | 
  1283 | SpinGGA::SpinGGA(int k, XC_p &f, std::unique_ptr<mrcpp::DerivativeOperator<3>> &d)
  1284 |         : Functional(k, f)
  1285 |         , derivative(std::move(d)) {
  1286 |     xc_mask = xc_utils::build_output_mask(false, true, this->order);
  1287 |     d_mask = xc_utils::build_density_mask(false, true, this->order);
  1288 | }
  1289 | 
  1290 | /** @brief Clear internal functions
  1291 |  *
  1292 |  * Ownership of densities is outside MRDFT -> clear
  1293 |  * Ownership of gradients is inside MRDFT -> free
  1294 |  */
  1295 | void SpinGGA::clear() {
  1296 |     mrcpp::clear(this->rho_a, false);
  1297 |     mrcpp::clear(this->rho_b, false);
  1298 |     mrcpp::clear(this->grad_a, true);
  1299 |     mrcpp::clear(this->grad_b, true);
  1300 | }
  1301 | 
  1302 | /** @brief Number of function involved in contraction step */
  1303 | int SpinGGA::getCtrInputLength() const {
  1304 |     int length = -1;
  1305 |     if (this->order < 2) length = 0;
  1306 |     if (this->order == 2) length = 8;
  1307 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
  1308 |     return length;
  1309 | }
  1310 | 
  1311 | /** @brief Collect input functions to xcfun evaluation step
  1312 |  *
  1313 |  * For SpinGGA : [alpha_0, beta_0, grad(alpha_0), grad(beta_0)]
  1314 |  */
  1315 | mrcpp::FunctionTreeVector<3> SpinGGA::setupXCInput() {
  1316 |     if (this->rho_a.size() < 1) MSG_ERROR("Alpha density not initialized");
  1317 |     if (this->rho_b.size() < 1) MSG_ERROR("Beta density not initialized");
  1318 |     if (this->grad_a.size() < 3) MSG_ERROR("Alpha gradient not initialized");
  1319 |     if (this->grad_b.size() < 3) MSG_ERROR("Beta gradient not initialized");
  1320 | 
  1321 |     mrcpp::FunctionTreeVector<3> out_vec;
  1322 |     out_vec.push_back(this->rho_a[0]);
  1323 |     out_vec.push_back(this->rho_b[0]);
  1324 |     out_vec.insert(out_vec.end(), this->grad_a.begin(), this->grad_a.begin() + 3);
  1325 |     out_vec.insert(out_vec.end(), this->grad_b.begin(), this->grad_b.begin() + 3);
  1326 |     return out_vec;
  1327 | }
  1328 | 
  1329 | /** @brief Collect input functions to contraction step
  1330 |  *
  1331 |  * For SpinGGA:
  1332 |  * Ground State: No contraction, empty vector
  1333 |  * Linear Response: [alpha_1, beta_1, grad(alpha_1), grad(beta_1)]
  1334 |  * Higher Response: NOT_IMPLEMENTED
  1335 |  */
  1336 | mrcpp::FunctionTreeVector<3> SpinGGA::setupCtrInput() {
  1337 |     if (this->order > 2) NOT_IMPLEMENTED_ABORT;
  1338 |     mrcpp::FunctionTreeVector<3> out_vec;
  1339 |     if (this->order == 2) {
  1340 |         out_vec.push_back(this->rho_a[1]);
  1341 |         out_vec.push_back(this->rho_b[1]);
  1342 |         out_vec.insert(out_vec.end(), this->grad_a.begin() + 3, this->grad_a.begin() + 6);
  1343 |         out_vec.insert(out_vec.end(), this->grad_b.begin() + 3, this->grad_b.begin() + 6);
  1344 |     }
  1345 |     return out_vec;
  1346 | }
  1347 | 
  1348 | /** @brief Prepare input functions to xcfun
  1349 |  *
  1350 |  * Collects input densities and computes necessary gradients.
  1351 |  */
  1352 | void SpinGGA::preprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1353 |     if (inp_vec.size() != 2 * this->order) MSG_ERROR("Invalid input length");
  1354 |     if (this->rho_a.size() > 0) MSG_ERROR("Alpha density not empty");
  1355 |     if (this->rho_b.size() > 0) MSG_ERROR("Beta density not empty");
  1356 |     if (this->grad_a.size() > 0) MSG_ERROR("Alpha gradient not empty");
  1357 |     if (this->grad_b.size() > 0) MSG_ERROR("Beta gradient not empty");
  1358 | 
  1359 |     int n = 0;
  1360 |     for (int i = 0; i < this->order; i++) {
  1361 |         this->rho_a.push_back(inp_vec[n++]);
  1362 |         this->rho_b.push_back(inp_vec[n++]);
  1363 |     }
  1364 | 
  1365 |     for (int i = 0; i < this->order; i++) {
  1366 |         mrcpp::FunctionTreeVector<3> tmp_a, tmp_b;
  1367 |         if (this->log_grad and i == 0) {
  1368 |             tmp_a = xc_utils::log_gradient(*this->derivative, mrcpp::get_func(this->rho_a, i));
  1369 |             tmp_b = xc_utils::log_gradient(*this->derivative, mrcpp::get_func(this->rho_b, i));
  1370 |         } else {
  1371 |             tmp_a = mrcpp::gradient(*this->derivative, mrcpp::get_func(this->rho_a, i));
  1372 |             tmp_b = mrcpp::gradient(*this->derivative, mrcpp::get_func(this->rho_b, i));
  1373 |         }
  1374 |         this->grad_a.insert(this->grad_a.end(), tmp_a.begin(), tmp_a.end());
  1375 |         this->grad_b.insert(this->grad_b.end(), tmp_b.begin(), tmp_b.end());
  1376 |     }
  1377 | }
  1378 | 
  1379 | /** @brief Compute final output functions
  1380 |  *
  1381 |  * For SpinGGA:
  1382 |  * f_xc         : out[0] = inp[0]
  1383 |  * df_xc/drho_a : out[1] = inp[1] - div(inp[3,4,5])
  1384 |  * df_xc/drho_b : out[2] = inp[2] - div(inp[6,7,8])
  1385 |  */
  1386 | mrcpp::FunctionTreeVector<3> SpinGGA::postprocess(mrcpp::FunctionTreeVector<3> &inp_vec) {
  1387 |     // Energy density
  1388 |     mrcpp::FunctionTree<3> &f_xc = mrcpp::get_func(inp_vec, 0);
  1389 |     inp_vec[0] = std::make_tuple<double, mrcpp::FunctionTree<3> *>(1.0, nullptr);
  1390 | 
  1391 |     // Alpha part
  1392 |     mrcpp::FunctionTree<3> &df_da = mrcpp::get_func(inp_vec, 1);
  1393 |     mrcpp::FunctionTreeVector<3> df_dga(inp_vec.begin() + 3, inp_vec.begin() + 6);
  1394 | 
  1395 |     auto *tmp_a = new mrcpp::FunctionTree<3>(df_da.getMRA());
  1396 |     mrcpp::divergence(*tmp_a, *this->derivative, df_dga);
  1397 | 
  1398 |     auto *v_a = new mrcpp::FunctionTree<3>(df_da.getMRA());
  1399 |     mrcpp::build_grid(*v_a, df_da);
  1400 |     mrcpp::build_grid(*v_a, *tmp_a);
  1401 |     mrcpp::add(-1.0, *v_a, 1.0, df_da, -1.0, *tmp_a);
  1402 |     delete tmp_a;
  1403 | 
  1404 |     // Beta part
  1405 |     mrcpp::FunctionTree<3> &df_db = mrcpp::get_func(inp_vec, 2);
  1406 |     mrcpp::FunctionTreeVector<3> df_dgb(inp_vec.begin() + 6, inp_vec.begin() + 9);
  1407 | 
  1408 |     auto *tmp_b = new mrcpp::FunctionTree<3>(df_db.getMRA());
  1409 |     mrcpp::divergence(*tmp_b, *this->derivative, df_dgb);
  1410 | 
  1411 |     auto *v_b = new mrcpp::FunctionTree<3>(df_db.getMRA());
  1412 |     mrcpp::build_grid(*v_b, df_db);
  1413 |     mrcpp::build_grid(*v_b, *tmp_b);
  1414 |     mrcpp::add(-1.0, *v_b, 1.0, df_db, -1.0, *tmp_b);
  1415 |     delete tmp_b;
  1416 | 
  1417 |     // Collect output
  1418 |     mrcpp::FunctionTreeVector<3> out_vec;
  1419 |     out_vec.push_back(std::make_tuple(1.0, &f_xc));
  1420 |     out_vec.push_back(std::make_tuple(1.0, v_a));
  1421 |     out_vec.push_back(std::make_tuple(1.0, v_b));
  1422 |     v_a = nullptr;
  1423 |     v_b = nullptr;
  1424 | 
  1425 |     return out_vec;
  1426 | }
  1427 | 
  1428 | } // namespace mrdft
  1429 | 
  1430 | ===== END src/mrdft/SpinGGA.cpp =====
  1431 | 
  1432 | ===== MISSING src/qmoperators/xc_operator_lda.cpp =====
  1433 | 
  1434 | ===== MISSING src/qmoperators/xc_operator_blyp.cpp =====
  1435 | 
  1436 | ===== MISSING src/qmoperators/xc_hessian_lda.cpp =====
  1437 | 
  1438 | ===== MISSING src/qmoperators/xc_hessian_pbe.cpp =====
  1439 | 
  1440 | ===== BEGIN src/surface_forces/xcStress.h =====
  1441 | #pragma once
  1442 | 
  1443 | #include "mrchem.h"
  1444 | #include <Eigen/Core>
  1445 | #include "qmfunctions/Density.h"
  1446 | #include "qmfunctions/Orbital.h"
  1447 | #include "mrdft/MRDFT.h"
  1448 | #include <vector>
  1449 | #include "qmoperators/one_electron/NablaOperator.h"
  1450 | 
  1451 | namespace surface_force {
  1452 | 
  1453 | std::vector<Eigen::Matrix3d> xcLDAStress(std::unique_ptr<mrdft::MRDFT> &mrdft_p, Eigen::MatrixXd &rhoGrid);
  1454 | std::vector<Eigen::Matrix3d> xcLDASpinStress(std::unique_ptr<mrdft::MRDFT> &mrdft_p, Eigen::MatrixXd &rhoGridAlpha, Eigen::MatrixXd &rhoGridBeta);
  1455 | std::vector<Eigen::Matrix3d> xcGGAStress(std::unique_ptr<mrdft::MRDFT> &mrdft_p, Eigen::MatrixXd &rhoGrid, Eigen::MatrixXd &nablaRhoGrid);
  1456 | std::vector<Eigen::Matrix3d> xcGGASpinStress(std::unique_ptr<mrdft::MRDFT> &mrdft_p, Eigen::MatrixXd &rhoGridAlpha, Eigen::MatrixXd &rhoGridBeta, Eigen::MatrixXd &nablaRhoGridAlpha, Eigen::MatrixXd &nablaRhoGridBeta);
  1457 | std::vector<Eigen::Matrix3d> getXCStress(std::unique_ptr<mrdft::MRDFT> &mrdft_p, mrcpp::FunctionTreeVector<3> &xc_pots, std::shared_ptr<mrchem::OrbitalVector> phi, std::shared_ptr<mrchem::NablaOperator> nabla, Eigen::MatrixXd &gridPos, bool isOpenShell, double prec);
  1458 | 
  1459 | } // namespace surface_force
  1460 | 
  1461 | ===== END src/surface_forces/xcStress.h =====
  1462 | 
  1463 | ===== BEGIN src/surface_forces/xcStress.cpp =====
  1464 | #include "surface_forces/xcStress.h"
  1465 | 
  1466 | #include "qmfunctions/Density.h"
  1467 | #include "qmfunctions/Orbital.h"
  1468 | #include "mrdft/MRDFT.h"
  1469 | #include "qmfunctions/Density.h"
  1470 | #include "qmfunctions/density_utils.h"
  1471 | #include "qmoperators/one_electron/NablaOperator.h"
  1472 | 
  1473 | using namespace Eigen;
  1474 | using namespace mrchem;
  1475 | using namespace std;
  1476 | 
  1477 | namespace surface_force{
  1478 | 
  1479 | /**
  1480 |  * @brief Compute the exchange-correlation stress tensor for LDA functional
  1481 |  * 
  1482 |  * @param mrdft_p MRDFT object
  1483 |  * @param rhoGrid MatrixXd with density values, shape (nGrid, 1)
  1484 |  * @return std::vector<Eigen::Matrix3d> vector of 3x3 matrices with stress tensor at each grid point
  1485 |  */
  1486 | std::vector<Eigen::Matrix3d> xcLDAStress(unique_ptr<mrdft::MRDFT> &mrdft_p, Eigen::MatrixXd &rhoGrid){
  1487 |     int nGrid = rhoGrid.rows();
  1488 |     std::vector<Eigen::Matrix3d> out(nGrid);
  1489 |     Eigen::MatrixXd xcOUT =  mrdft_p->functional().evaluate_transposed(rhoGrid);
  1490 |     for (int i = 0; i < nGrid; i++) {
  1491 |         out[i] = Matrix3d::Zero();
  1492 |         for (int j = 0; j < 3; j++) {
  1493 |             out[i](j, j) = xcOUT(i, 0) - xcOUT(i, 1) * rhoGrid(i);
  1494 |         }
  1495 |     }
  1496 |     return out;
  1497 | }
  1498 | 
  1499 | /**
  1500 |  * @brief Compute the exchange-correlation stress tensor for LDA functional for open shell systems
  1501 |  * 
  1502 |  * @param mrdft_p MRDFT object
  1503 |  * @param rhoGridAlpha MatrixXd with alpha density values, shape (nGrid, 1)
  1504 |  * @param rhoGridBeta MatrixXd with beta density values, shape (nGrid, 1)
  1505 |  * @return std::vector<Eigen::Matrix3d> vector of 3x3 matrices with stress tensor at each grid point
  1506 |  */
  1507 | std::vector<Matrix3d> xcLDASpinStress(unique_ptr<mrdft::MRDFT> &mrdft_p, MatrixXd &rhoGridAlpha, MatrixXd &rhoGridBeta){
  1508 |     int nGrid = rhoGridAlpha.rows();
  1509 |     Eigen::MatrixXd inp(rhoGridAlpha.rows(), 2);
  1510 |     std::vector<Matrix3d> out = std::vector<Eigen::Matrix3d>(nGrid);
  1511 |     inp.col(0) = rhoGridAlpha.col(0);
  1512 |     inp.col(1) = rhoGridBeta.col(0);
  1513 |     Eigen::MatrixXd xc = mrdft_p->functional().evaluate_transposed(inp);
  1514 |     for (int i = 0; i < rhoGridAlpha.rows(); i++) {
  1515 |         out[i] = Matrix3d::Zero();
  1516 |         for (int j = 0; j < 3; j++) {
  1517 |             out[i](j, j) = xc(i, 0) - xc(i, 1) * rhoGridAlpha(i) - xc(i, 2) * rhoGridBeta(i);
  1518 |         }
  1519 |     }
  1520 |     return out;
  1521 | }
  1522 | 
  1523 | /**
  1524 |  * @brief Compute the exchange-correlation stress tensor for GGA functional
  1525 |  * 
  1526 |  * @param mrdft_p MRDFT object
  1527 |  * @param rhoGrid MatrixXd with density values, shape (nGrid, 1)
  1528 |  * @param nablaRhoGrid MatrixXd with gradient of density values, shape (nGrid, 3)
  1529 |  * @return std::vector<Eigen::Matrix3d> vector of 3x3 matrices with stress tensor at each grid point
  1530 |  */
  1531 | std::vector<Matrix3d> xcGGAStress(unique_ptr<mrdft::MRDFT> &mrdft_p, mrcpp::FunctionTreeVector<3> &xc_pots, MatrixXd &rhoGrid, MatrixXd &nablaRhoGrid, Eigen::MatrixXd &gridPos){
  1532 |     int nGrid = rhoGrid.rows();
  1533 |     Eigen::MatrixXd inp(rhoGrid.rows(), 4);
  1534 |     inp.col(0) = rhoGrid.col(0);
  1535 |     inp.col(1) = nablaRhoGrid.col(0);
  1536 |     inp.col(2) = nablaRhoGrid.col(1);
  1537 |     inp.col(3) = nablaRhoGrid.col(2);
  1538 |     Eigen::MatrixXd xcOUT =  mrdft_p->functional().evaluate_transposed(inp);
  1539 |     std::vector<Matrix3d> out(nGrid);
  1540 |     std::array<double, 3> pos;
  1541 |     for (int i = 0; i < rhoGrid.rows(); i++) {
  1542 |         out[i] = Matrix3d::Zero();
  1543 |         pos[0] = gridPos(i, 0);
  1544 |         pos[1] = gridPos(i, 1);
  1545 |         pos[2] = gridPos(i, 2);
  1546 |         for (int j = 0; j < 3; j++) {
  1547 |             out[i](j, j) = xcOUT(i, 0) - rhoGrid(i) * std::get<1>(xc_pots[0])->evalf(pos);
  1548 |         }
  1549 |         for (int j1 = 0; j1 < 3; j1++) {
  1550 |             for (int j2 = 0; j2 < 3; j2++) {
  1551 |                 out[i](j1, j2) = out[i](j1, j2) - xcOUT(i, 2 + j1) * nablaRhoGrid(i, j2);
  1552 |             }
  1553 |         }
  1554 |     }
  1555 |     return out;
  1556 | }
  1557 | 
  1558 | /**
  1559 |  * @brief Compute the exchange-correlation stress tensor for GGA functional for open shell systems
  1560 |  * 
  1561 |  * @param mrdft_p MRDFT object
  1562 |  * @param rhoGridAlpha MatrixXd with alpha density values, shape (nGrid, 1)
  1563 |  * @param rhoGridBeta MatrixXd with beta density values, shape (nGrid, 1)
  1564 |  * @param nablaRhoGridAlpha MatrixXd with gradient of alpha density values, shape (nGrid, 3)
  1565 |  * @param nablaRhoGridBeta MatrixXd with gradient of beta density values, shape (nGrid, 3)
  1566 |  * @return std::vector<Eigen::Matrix3d> vector of 3x3 matrices with stress tensor at each grid point
  1567 |  */
  1568 | std::vector<Matrix3d> xcGGASpinStress(unique_ptr<mrdft::MRDFT> &mrdft_p, mrcpp::FunctionTreeVector<3> &xc_pots, MatrixXd &rhoGridAlpha, MatrixXd &rhoGridBeta, MatrixXd &nablaRhoGridAlpha, MatrixXd &nablaRhoGridBeta, Eigen::MatrixXd &gridPos){
  1569 |     int nGrid = rhoGridAlpha.rows();
  1570 |     Eigen::MatrixXd inp(rhoGridAlpha.rows(), 8);
  1571 |     std::vector<Matrix3d> out = std::vector<Eigen::Matrix3d>(nGrid);
  1572 |     inp.col(0) = rhoGridAlpha.col(0);
  1573 |     inp.col(1) = rhoGridBeta.col(0);
  1574 |     inp.col(2) = nablaRhoGridAlpha.col(0);
  1575 |     inp.col(3) = nablaRhoGridAlpha.col(1);
  1576 |     inp.col(4) = nablaRhoGridAlpha.col(2);
  1577 |     inp.col(5) = nablaRhoGridBeta.col(0);
  1578 |     inp.col(6) = nablaRhoGridBeta.col(1);
  1579 |     inp.col(7) = nablaRhoGridBeta.col(2);
  1580 |     Eigen::MatrixXd xc = mrdft_p->functional().evaluate_transposed(inp);
  1581 |     std::array<double, 3> pos;
  1582 |     for (int i = 0; i < rhoGridAlpha.rows(); i++) {
  1583 |         out[i] = Matrix3d::Zero();
  1584 |         pos[0] = gridPos(i, 0);
  1585 |         pos[1] = gridPos(i, 1);
  1586 |         pos[2] = gridPos(i, 2);
  1587 |         for (int j = 0; j < 3; j++) {
  1588 |             out[i](j, j) = xc(i, 0) - std::get<1>(xc_pots[0])->evalf(pos) * rhoGridAlpha(i) - std::get<1>(xc_pots[1])->evalf(pos) * rhoGridBeta(i);
  1589 |         }
  1590 |         for (int j1 = 0; j1 < 3; j1++) {
  1591 |             for (int j2 = 0; j2 < 3; j2++) {
  1592 |                 out[i](j1, j2) = out[i](j1, j2) 
  1593 |                     - xc(i, 3 + j1) * nablaRhoGridAlpha(i, j2) - xc(i, 6 + j1) * nablaRhoGridBeta(i, j2);
  1594 |             }
  1595 |         }
  1596 |     }
  1597 |     return out;
  1598 | }
  1599 | 
  1600 | /**
  1601 |  * @brief Compute the exchange-correlation stress tensor on a grid
  1602 |  * 
  1603 |  * @param mrdft_p MRDFT object
  1604 |  * @param phi OrbitalVector
  1605 |  * @param nabla NablaOperator (must be set up prior to calling this function)
  1606 |  * @param gridPos MatrixXd with grid positions, shape (nGrid, 3)
  1607 |  * @param isOpenShell bool, true if open shell calculation
  1608 |  * @param prec precision to use in density representation
  1609 |  */
  1610 | std::vector<Eigen::Matrix3d> getXCStress(unique_ptr<mrdft::MRDFT> &mrdft_p, mrcpp::FunctionTreeVector<3> &xc_pots, std::shared_ptr<OrbitalVector> phi,
  1611 |         std::shared_ptr<NablaOperator> nabla, MatrixXd &gridPos, bool isOpenShell, double prec){
  1612 | 
  1613 |     bool isGGA = mrdft_p->functional().isGGA();
  1614 |     bool isHybrid = mrdft_p->functional().isHybrid();
  1615 |     if (isHybrid) {
  1616 |         MSG_ABORT("Exact exchange is not implemented for forces computed with surface integrals");
  1617 |     }
  1618 | 
  1619 |     std::array<double, 3> pos;
  1620 |     int nGrid = gridPos.rows();
  1621 | 
  1622 |     vector<Matrix3d> xcStress;
  1623 | 
  1624 |     if (isOpenShell) {
  1625 |         MatrixXd rhoGridAlpha(nGrid, 1);
  1626 |         MatrixXd rhoGridBeta(nGrid, 1);
  1627 |         mrchem::Density rhoA(false);
  1628 |         mrchem::Density rhoB(false);
  1629 |         mrchem::density::compute(prec, rhoA, *phi, DensityType::Alpha);
  1630 |         mrchem::density::compute(prec, rhoB, *phi, DensityType::Beta);
  1631 | 
  1632 |         for (int i = 0; i < nGrid; i++) { // compute density on grid
  1633 |             pos[0] = gridPos(i, 0);
  1634 |             pos[1] = gridPos(i, 1);
  1635 |             pos[2] = gridPos(i, 2);
  1636 |             rhoGridAlpha(i) = rhoA.real().evalf(pos);
  1637 |             rhoGridBeta(i) = rhoB.real().evalf(pos);
  1638 |         }
  1639 | 
  1640 |         if (isGGA) {
  1641 |             mrchem::NablaOperator nablaOP = *nabla;
  1642 |             std::vector<mrchem::Orbital> nablaRhoAlpha = nablaOP(rhoA);
  1643 |             std::vector<mrchem::Orbital> nablaRhoBeta = nablaOP(rhoB);
  1644 |             MatrixXd nablaRhoGridAlpha(nGrid, 3);
  1645 |             MatrixXd nablaRhoGridBeta(nGrid, 3);
  1646 |             for (int i = 0; i < nGrid; i++) {
  1647 |                 pos[0] = gridPos(i, 0);
  1648 |                 pos[1] = gridPos(i, 1);
  1649 |                 pos[2] = gridPos(i, 2);
  1650 |                 nablaRhoGridAlpha(i, 0) = nablaRhoAlpha[0].real().evalf(pos);
  1651 |                 nablaRhoGridAlpha(i, 1) = nablaRhoAlpha[1].real().evalf(pos);
  1652 |                 nablaRhoGridAlpha(i, 2) = nablaRhoAlpha[2].real().evalf(pos);
  1653 |                 nablaRhoGridBeta(i, 0) = nablaRhoBeta[0].real().evalf(pos);
  1654 |                 nablaRhoGridBeta(i, 1) = nablaRhoBeta[1].real().evalf(pos);
  1655 |                 nablaRhoGridBeta(i, 2) = nablaRhoBeta[2].real().evalf(pos);
  1656 |             }
  1657 | 
  1658 |             xcStress = xcGGASpinStress(mrdft_p, xc_pots, rhoGridAlpha, rhoGridBeta, nablaRhoGridAlpha, nablaRhoGridBeta, gridPos);
  1659 |         } else {
  1660 |             xcStress = xcLDASpinStress(mrdft_p, rhoGridAlpha, rhoGridBeta);
  1661 |         }
  1662 | 
  1663 |     } else { // closed shell
  1664 |         MatrixXd rhoGrid(nGrid, 1);
  1665 |         mrchem::Density rho(false);
  1666 |         mrchem::density::compute(prec, rho, *phi, DensityType::Total);
  1667 | 
  1668 |         for (int i = 0; i < nGrid; i++) { // compute density on grid
  1669 |             pos[0] = gridPos(i, 0);
  1670 |             pos[1] = gridPos(i, 1);
  1671 |             pos[2] = gridPos(i, 2);
  1672 |             rhoGrid(i) = rho.real().evalf(pos);
  1673 |         }
  1674 | 
  1675 |         if (isGGA) {
  1676 |             mrchem::NablaOperator nablaOP = *nabla;
  1677 |             std::vector<mrchem::Orbital> nablaRho = nablaOP(rho);
  1678 |             MatrixXd nablaRhoGrid(nGrid, 3);
  1679 |             for (int i = 0; i < nGrid; i++) {
  1680 |                 pos[0] = gridPos(i, 0);
  1681 |                 pos[1] = gridPos(i, 1);
  1682 |                 pos[2] = gridPos(i, 2);
  1683 |                 nablaRhoGrid(i, 0) = nablaRho[0].real().evalf(pos);
  1684 |                 nablaRhoGrid(i, 1) = nablaRho[1].real().evalf(pos);
  1685 |                 nablaRhoGrid(i, 2) = nablaRho[2].real().evalf(pos);
  1686 |             }
  1687 |             xcStress = xcGGAStress(mrdft_p, xc_pots, rhoGrid, nablaRhoGrid, gridPos);
  1688 |         } else {
  1689 |             xcStress = xcLDAStress(mrdft_p, rhoGrid);
  1690 |         }
  1691 |     }
  1692 |     return xcStress;
  1693 | }
  1694 | } // namespace surface_force
  1695 | ===== END src/surface_forces/xcStress.cpp =====
  1696 | 
  1697 | ===== BEGIN src/qmoperators/two_electron/XCPotential.h =====
  1698 | /*
  1699 |  * MRChem, a numerical real-space code for molecular electronic structure
  1700 |  * calculations within the self-consistent field (SCF) approximations of quantum
  1701 |  * chemistry (Hartree-Fock and Density Functional Theory).
  1702 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1703 |  *
  1704 |  * This file is part of MRChem.
  1705 |  *
  1706 |  * MRChem is free software: you can redistribute it and/or modify
  1707 |  * it under the terms of the GNU Lesser General Public License as published by
  1708 |  * the Free Software Foundation, either version 3 of the License, or
  1709 |  * (at your option) any later version.
  1710 |  *
  1711 |  * MRChem is distributed in the hope that it will be useful,
  1712 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  1713 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1714 |  * GNU Lesser General Public License for more details.
  1715 |  *
  1716 |  * You should have received a copy of the GNU Lesser General Public License
  1717 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  1718 |  *
  1719 |  * For information on the complete list of contributors to MRChem, see:
  1720 |  * <https://mrchem.readthedocs.io/>
  1721 |  */
  1722 | 
  1723 | #pragma once
  1724 | 
  1725 | #include "qmoperators/QMPotential.h"
  1726 | #include "qmfunctions/Density.h"
  1727 | 
  1728 | #include "mrdft/MRDFT.h"
  1729 | 
  1730 | /**
  1731 |  * @class XCPotential
  1732 |  * @brief Exchange-Correlation potential defined by a particular (spin) density
  1733 |  *
  1734 |  * The XC potential is computed by mapping of the density through a XC functional,
  1735 |  * provided by the XCFun library. There are two ways of defining the density:
  1736 |  *
  1737 |  *  1) Use getDensity() prior to setup() and build the density as you like.
  1738 |  *  2) Provide a default set of orbitals in the constructor that is used to
  1739 |  *     compute the density on-the-fly in setup().
  1740 |  *
  1741 |  * If a set of orbitals has NOT been given in the constructor, the density
  1742 |  * MUST be explicitly computed prior to setup(). The density will be computed
  1743 |  * on-the-fly in setup() ONLY if it is not already available. After setup() the
  1744 |  * operator will be fixed until clear(), which deletes both the density and the
  1745 |  * potential.
  1746 |  *
  1747 |  * LDA and GGA functionals are supported as well as two different ways to compute
  1748 |  * the XC potentials: either with explicit derivatives or gamma-type derivatives.
  1749 |  *
  1750 |  */
  1751 | 
  1752 | namespace mrchem {
  1753 | 
  1754 | class XCPotential : public QMPotential {
  1755 | public:
  1756 |     explicit XCPotential(std::unique_ptr<mrdft::MRDFT> &F, std::shared_ptr<OrbitalVector> Phi = nullptr, bool mpi_shared = false)
  1757 |             : QMPotential(1, mpi_shared)
  1758 |             , energy(0.0)
  1759 |             , orbitals(Phi)
  1760 |             , mrdft(std::move(F)) {}
  1761 |     ~XCPotential() override = default;
  1762 | 
  1763 |     /**
  1764 |      * @brief Get the XC potential. For unrestricted calculations, the potential is a vector of two functions.
  1765 |      */
  1766 |     std::shared_ptr<mrcpp::FunctionTreeVector<3>> getPotentialVector() { 
  1767 |         return std::make_shared<mrcpp::FunctionTreeVector<3>>(potentials); 
  1768 |     }
  1769 | 
  1770 |     friend class XCOperator;
  1771 | 
  1772 | protected:
  1773 |     double energy;                           ///< XC energy
  1774 |     std::vector<Density> densities;          ///< XC densities (total or alpha/beta)
  1775 |     mrcpp::FunctionTreeVector<3> potentials; ///< XC Potential functions collected in a vector
  1776 |     std::shared_ptr<mrcpp::FunctionTree<3>> v_tot{nullptr};            ///< Total XC potential
  1777 |     std::shared_ptr<OrbitalVector> orbitals; ///< External set of orbitals used to build the density
  1778 |     std::unique_ptr<mrdft::MRDFT> mrdft;     ///< External XC functional to be used
  1779 | 
  1780 |     double getEnergy() const { return this->energy; }
  1781 |     Density &getDensity(DensityType spin, int pert_idx);
  1782 |     mrcpp::FunctionTree<3> &getPotential(int spin);
  1783 | 
  1784 |     void setup(double prec) override;
  1785 |     void clear() override;
  1786 | 
  1787 |     virtual mrcpp::FunctionTreeVector<3> setupDensities(double prec, mrcpp::FunctionTree<3> &grid) = 0;
  1788 | 
  1789 |     Orbital apply(Orbital phi) override;
  1790 |     Orbital dagger(Orbital phi) override;
  1791 |     QMOperatorVector apply(std::shared_ptr<QMOperator> &O) override;
  1792 | };
  1793 | 
  1794 | } // namespace mrchem
  1795 | ===== END src/qmoperators/two_electron/XCPotential.h =====
  1796 | 
  1797 | ===== BEGIN src/qmoperators/two_electron/XCPotential.cpp =====
  1798 | /*
  1799 |  * MRChem, a numerical real-space code for molecular electronic structure
  1800 |  * calculations within the self-consistent field (SCF) approximations of quantum
  1801 |  * chemistry (Hartree-Fock and Density Functional Theory).
  1802 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1803 |  *
  1804 |  * This file is part of MRChem.
  1805 |  *
  1806 |  * MRChem is free software: you can redistribute it and/or modify
  1807 |  * it under the terms of the GNU Lesser General Public License as published by
  1808 |  * the Free Software Foundation, either version 3 of the License, or
  1809 |  * (at your option) any later version.
  1810 |  *
  1811 |  * MRChem is distributed in the hope that it will be useful,
  1812 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  1813 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1814 |  * GNU Lesser General Public License for more details.
  1815 |  *
  1816 |  * You should have received a copy of the GNU Lesser General Public License
  1817 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  1818 |  *
  1819 |  * For information on the complete list of contributors to MRChem, see:
  1820 |  * <https://mrchem.readthedocs.io/>
  1821 |  */
  1822 | 
  1823 | #include <MRCPP/Printer>
  1824 | #include <MRCPP/Timer>
  1825 | 
  1826 | #include "XCPotential.h"
  1827 | #include "qmfunctions/density_utils.h"
  1828 | #include "qmfunctions/orbital_utils.h"
  1829 | 
  1830 | using mrcpp::FunctionTree;
  1831 | using mrcpp::Printer;
  1832 | using mrcpp::Timer;
  1833 | 
  1834 | using QMOperator_p = std::shared_ptr<mrchem::QMOperator>;
  1835 | 
  1836 | namespace mrchem {
  1837 | 
  1838 | /** @brief Prepare the operator for application
  1839 |  *
  1840 |  * @param[in] prec Apply precision
  1841 |  *
  1842 |  * Sequence of steps required to compute the XC potentials:
  1843 |  *
  1844 |  * 1) Compute density
  1845 |  * 2) Setup xcfun input functions (gradients etc.)
  1846 |  * 3) Evaluate xcfun
  1847 |  * 4) Compute XC energy by integrating energy density
  1848 |  * 5) Compute XC potential(s) from xcfun output functions
  1849 |  *
  1850 |  */
  1851 | void XCPotential::setup(double prec) {
  1852 |     if (isSetup(prec)) return;
  1853 |     setApplyPrec(prec);
  1854 |     Timer timer;
  1855 |     auto plevel = Printer::getPrintLevel();
  1856 |     mrcpp::print::header(3, "Building XC operator");
  1857 |     mrcpp::print::value(3, "Precision", prec, "(rel)", 5);
  1858 |     mrcpp::print::separator(3, '-');
  1859 |     if (this->mrdft == nullptr) MSG_ERROR("XCFunctional not initialized");
  1860 |     if (this->potentials.size() != 0) MSG_ERROR("Potential not properly cleared");
  1861 | 
  1862 |     auto &grid = this->mrdft->grid().get();
  1863 |     mrcpp::FunctionTreeVector<3> xc_inp = setupDensities(prec, grid);
  1864 |     mrcpp::FunctionTreeVector<3> xc_out = this->mrdft->evaluate(xc_inp);
  1865 | 
  1866 |     // Fetch energy
  1867 |     this->energy = this->mrdft->functional().XCenergy;
  1868 | 
  1869 |     // Fetch potential
  1870 |     auto &v_local = mrcpp::get_func(xc_out, 1);
  1871 |     auto *v_global = new mrcpp::FunctionTree<3>(v_local.getMRA());
  1872 |     mrcpp::copy_grid(*v_global, v_local);
  1873 |     mrcpp::copy_func(*v_global, v_local);
  1874 |     this->potentials.push_back(std::make_tuple(1.0, v_global));
  1875 | 
  1876 |     // Fetch potential
  1877 |     if (this->mrdft->functional().isSpin()) {
  1878 |         auto &v_local = mrcpp::get_func(xc_out, 2);
  1879 |         auto *v_global = new mrcpp::FunctionTree<3>(v_local.getMRA());
  1880 |         mrcpp::copy_grid(*v_global, v_local);
  1881 |         mrcpp::copy_func(*v_global, v_local);
  1882 |         this->potentials.push_back(std::make_tuple(1.0, v_global));
  1883 |     }
  1884 | 
  1885 | 
  1886 |     if (plevel == 2) {
  1887 |         int totNodes = 0;
  1888 |         int totSize = 0;
  1889 |         for (auto i = 0; i < this->potentials.size(); i++) {
  1890 |             auto &f_i = mrcpp::get_func(this->potentials, i);
  1891 |             totNodes += f_i.getNNodes();
  1892 |             totSize += f_i.getSizeNodes();
  1893 |         }
  1894 |         auto t = timer.elapsed();
  1895 |         mrcpp::print::tree(2, "XC operator", totNodes, totSize, t);
  1896 |     }
  1897 |     mrcpp::clear(xc_out, true);
  1898 |     mrcpp::print::footer(3, timer, 2);
  1899 | }
  1900 | 
  1901 | /** @brief Clears all data in the XCPotential object */
  1902 | void XCPotential::clear() {
  1903 |     this->energy = 0.0;
  1904 |     for (auto &rho : this->densities) rho.free(NUMBER::Total);
  1905 |     mrcpp::clear(this->potentials, true);
  1906 |     clearApplyPrec();
  1907 | }
  1908 | 
  1909 | Density &XCPotential::getDensity(DensityType spin, int pert_idx) {
  1910 |     int dens_idx = -1;
  1911 |     if (spin == DensityType::Total) {
  1912 |         if (pert_idx == 0) dens_idx = 0;
  1913 |         if (pert_idx == 1) dens_idx = 3;
  1914 |     } else if (spin == DensityType::Alpha) {
  1915 |         if (pert_idx == 0) dens_idx = 1;
  1916 |         if (pert_idx == 1) dens_idx = 4;
  1917 |     } else if (spin == DensityType::Beta) {
  1918 |         if (pert_idx == 0) dens_idx = 2;
  1919 |         if (pert_idx == 1) dens_idx = 5;
  1920 |     } else {
  1921 |         NOT_IMPLEMENTED_ABORT;
  1922 |     }
  1923 |     if (dens_idx < 0) MSG_ABORT("Invalid density index");
  1924 |     if (dens_idx > densities.size()) MSG_ABORT("Invalid density index");
  1925 |     return densities[dens_idx];
  1926 | }
  1927 | 
  1928 | /** @brief Return FunctionTree for the XC spin potential
  1929 |  *
  1930 |  * @param[in] type Which spin potential to return (alpha, beta or total)
  1931 |  */
  1932 | FunctionTree<3> &XCPotential::getPotential(int spin) {
  1933 |     int nPots = this->potentials.size();
  1934 |     if (nPots < 1 or nPots > 2) MSG_ERROR("Invalid potential");
  1935 | 
  1936 |     bool spinFunctional = this->mrdft->functional().isSpin();
  1937 |     int pot_idx = -1;
  1938 |     if (spinFunctional and spin == SPIN::Alpha) {
  1939 |         pot_idx = 0;
  1940 |     } else if (spinFunctional and spin == SPIN::Beta) {
  1941 |         pot_idx = 1;
  1942 |     } else if (not spinFunctional) {
  1943 |         pot_idx = 0;
  1944 |     } else if (spinFunctional and spin == SPIN::Paired) {
  1945 |         this->v_tot = std::make_shared<FunctionTree<3>>(*MRA);
  1946 |         mrcpp::add(prec(), *this->v_tot, this->potentials);
  1947 |         return *this->v_tot;
  1948 |     } else {
  1949 |         NOT_IMPLEMENTED_ABORT;
  1950 |     }
  1951 |     return mrcpp::get_func(this->potentials, pot_idx);
  1952 | }
  1953 | 
  1954 | /** @brief XCPotentialD1 application
  1955 |  *
  1956 |  * @param[in] phi Orbital to which the potential is applied
  1957 |  *
  1958 |  * The operator is applied by choosing the correct potential function
  1959 |  * which is then assigned to the real function part of the operator
  1960 |  * base-class before the base class function is called.
  1961 |  */
  1962 | Orbital XCPotential::apply(Orbital phi) {
  1963 |     QMPotential &V = *this;
  1964 |     if (V.hasImag()) MSG_ERROR("Imaginary part of XC potential non-zero");
  1965 | 
  1966 |     FunctionTree<3> &pot = getPotential(phi.spin());
  1967 |     V.setReal(&pot);
  1968 |     Orbital Vphi = QMPotential::apply(phi);
  1969 |     V.setReal(nullptr);
  1970 |     return Vphi;
  1971 | }
  1972 | 
  1973 | Orbital XCPotential::dagger(Orbital phi) {
  1974 |     QMPotential &V = *this;
  1975 |     if (V.hasImag()) MSG_ERROR("Imaginary part of XC potential non-zero");
  1976 | 
  1977 |     FunctionTree<3> &pot = getPotential(phi.spin());
  1978 |     V.setReal(&pot);
  1979 |     Orbital Vphi = QMPotential::dagger(phi);
  1980 |     V.setReal(nullptr);
  1981 |     return Vphi;
  1982 | }
  1983 | 
  1984 | QMOperatorVector XCPotential::apply(QMOperator_p &O) {
  1985 |     NOT_IMPLEMENTED_ABORT;
  1986 | }
  1987 | 
  1988 | } // namespace mrchem
  1989 | ===== END src/qmoperators/two_electron/XCPotential.cpp =====
  1990 | 
  1991 | ===== BEGIN src/qmoperators/two_electron/XCPotentialD1.h =====
  1992 | /*
  1993 |  * MRChem, a numerical real-space code for molecular electronic structure
  1994 |  * calculations within the self-consistent field (SCF) approximations of quantum
  1995 |  * chemistry (Hartree-Fock and Density Functional Theory).
  1996 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  1997 |  *
  1998 |  * This file is part of MRChem.
  1999 |  *
  2000 |  * MRChem is free software: you can redistribute it and/or modify
  2001 |  * it under the terms of the GNU Lesser General Public License as published by
  2002 |  * the Free Software Foundation, either version 3 of the License, or
  2003 |  * (at your option) any later version.
  2004 |  *
  2005 |  * MRChem is distributed in the hope that it will be useful,
  2006 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  2007 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2008 |  * GNU Lesser General Public License for more details.
  2009 |  *
  2010 |  * You should have received a copy of the GNU Lesser General Public License
  2011 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  2012 |  *
  2013 |  * For information on the complete list of contributors to MRChem, see:
  2014 |  * <https://mrchem.readthedocs.io/>
  2015 |  */
  2016 | 
  2017 | #pragma once
  2018 | 
  2019 | #include "XCPotential.h"
  2020 | 
  2021 | /** @class XCPotential
  2022 |  *
  2023 |  * @brief Exchange-Correlation potential defined by a particular (spin) density
  2024 |  *
  2025 |  * The XC potential is computed by mapping of the density through a XC functional,
  2026 |  * provided by the XCFun library. There are two ways of defining the density:
  2027 |  *
  2028 |  *  1) Use getDensity() prior to setup() and build the density as you like.
  2029 |  *  2) Provide a default set of orbitals in the constructor that is used to
  2030 |  *     compute the density on-the-fly in setup().
  2031 |  *
  2032 |  * If a set of orbitals has NOT been given in the constructor, the density
  2033 |  * MUST be explicitly computed prior to setup(). The density will be computed
  2034 |  * on-the-fly in setup() ONLY if it is not already available. After setup() the
  2035 |  * operator will be fixed until clear(), which deletes both the density and the
  2036 |  * potential.
  2037 |  *
  2038 |  * LDA and GGA functionals are supported as well as two different ways to compute
  2039 |  * the XC potentials: either with explicit derivatives or gamma-type derivatives.
  2040 |  */
  2041 | 
  2042 | namespace mrchem {
  2043 | 
  2044 | class XCPotentialD1 final : public XCPotential {
  2045 | public:
  2046 |     explicit XCPotentialD1(std::unique_ptr<mrdft::MRDFT> &F, std::shared_ptr<OrbitalVector> Phi = nullptr, bool mpi_shared = false);
  2047 | 
  2048 | private:
  2049 |     mrcpp::FunctionTreeVector<3> setupDensities(double prec, mrcpp::FunctionTree<3> &grid) override;
  2050 | };
  2051 | 
  2052 | } // namespace mrchem
  2053 | 
  2054 | ===== END src/qmoperators/two_electron/XCPotentialD1.h =====
  2055 | 
  2056 | ===== BEGIN src/qmoperators/two_electron/XCPotentialD1.cpp =====
  2057 | /*
  2058 |  * MRChem, a numerical real-space code for molecular electronic structure
  2059 |  * calculations within the self-consistent field (SCF) approximations of quantum
  2060 |  * chemistry (Hartree-Fock and Density Functional Theory).
  2061 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  2062 |  *
  2063 |  * This file is part of MRChem.
  2064 |  *
  2065 |  * MRChem is free software: you can redistribute it and/or modify
  2066 |  * it under the terms of the GNU Lesser General Public License as published by
  2067 |  * the Free Software Foundation, either version 3 of the License, or
  2068 |  * (at your option) any later version.
  2069 |  *
  2070 |  * MRChem is distributed in the hope that it will be useful,
  2071 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  2072 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2073 |  * GNU Lesser General Public License for more details.
  2074 |  *
  2075 |  * You should have received a copy of the GNU Lesser General Public License
  2076 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  2077 |  *
  2078 |  * For information on the complete list of contributors to MRChem, see:
  2079 |  * <https://mrchem.readthedocs.io/>
  2080 |  */
  2081 | 
  2082 | #include "MRCPP/Printer"
  2083 | #include "MRCPP/Timer"
  2084 | 
  2085 | #include "XCPotential.h"
  2086 | #include "XCPotentialD1.h"
  2087 | #include "qmfunctions/Density.h"
  2088 | #include "qmfunctions/Orbital.h"
  2089 | #include "qmfunctions/density_utils.h"
  2090 | #include "qmfunctions/orbital_utils.h"
  2091 | #include "utils/print_utils.h"
  2092 | 
  2093 | using mrcpp::Printer;
  2094 | using mrcpp::Timer;
  2095 | 
  2096 | namespace mrchem {
  2097 | 
  2098 | XCPotentialD1::XCPotentialD1(std::unique_ptr<mrdft::MRDFT> &F, std::shared_ptr<OrbitalVector> Phi, bool mpi_shared)
  2099 |         : XCPotential(F, Phi, mpi_shared) {
  2100 |     densities.push_back(Density(false)); // rho_0 total
  2101 |     densities.push_back(Density(false)); // rho_0 alpha
  2102 |     densities.push_back(Density(false)); // rho_0 beta
  2103 | }
  2104 | 
  2105 | mrcpp::FunctionTreeVector<3> XCPotentialD1::setupDensities(double prec, mrcpp::FunctionTree<3> &grid) {
  2106 |     mrcpp::FunctionTreeVector<3> dens_vec;
  2107 |     if (not this->mrdft->functional().isSpin()) {
  2108 |         { // Unperturbed total density
  2109 |             Timer timer;
  2110 |             Density &rho = getDensity(DensityType::Total, 0);
  2111 |             if (not rho.hasReal()) {
  2112 |                 rho.alloc(NUMBER::Real);
  2113 |                 mrcpp::copy_grid(rho.real(), grid);
  2114 |                 density::compute(prec, rho, *orbitals, DensityType::Total);
  2115 |             }
  2116 |             print_utils::qmfunction(3, "Compute rho", rho, timer);
  2117 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2118 |         }
  2119 |     } else {
  2120 |         { // Unperturbed alpha density
  2121 |             Timer timer;
  2122 |             Density &rho = getDensity(DensityType::Alpha, 0);
  2123 |             if (not rho.hasReal()) {
  2124 |                 rho.alloc(NUMBER::Real);
  2125 |                 mrcpp::copy_grid(rho.real(), grid);
  2126 |                 density::compute(prec, rho, *orbitals, DensityType::Alpha);
  2127 |             }
  2128 |             print_utils::qmfunction(3, "Compute rho (alpha)", rho, timer);
  2129 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2130 |         }
  2131 |         { // Unperturbed beta density
  2132 |             Timer timer;
  2133 |             Density &rho = getDensity(DensityType::Beta, 0);
  2134 |             if (not rho.hasReal()) {
  2135 |                 rho.alloc(NUMBER::Real);
  2136 |                 mrcpp::copy_grid(rho.real(), grid);
  2137 |                 density::compute(prec, rho, *orbitals, DensityType::Beta);
  2138 |             }
  2139 |             print_utils::qmfunction(3, "Compute rho (beta)", rho, timer);
  2140 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2141 |         }
  2142 |     }
  2143 |     return dens_vec;
  2144 | }
  2145 | 
  2146 | } // namespace mrchem
  2147 | 
  2148 | ===== END src/qmoperators/two_electron/XCPotentialD1.cpp =====
  2149 | 
  2150 | ===== BEGIN src/qmoperators/two_electron/XCPotentialD2.h =====
  2151 | /*
  2152 |  * MRChem, a numerical real-space code for molecular electronic structure
  2153 |  * calculations within the self-consistent field (SCF) approximations of quantum
  2154 |  * chemistry (Hartree-Fock and Density Functional Theory).
  2155 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  2156 |  *
  2157 |  * This file is part of MRChem.
  2158 |  *
  2159 |  * MRChem is free software: you can redistribute it and/or modify
  2160 |  * it under the terms of the GNU Lesser General Public License as published by
  2161 |  * the Free Software Foundation, either version 3 of the License, or
  2162 |  * (at your option) any later version.
  2163 |  *
  2164 |  * MRChem is distributed in the hope that it will be useful,
  2165 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  2166 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2167 |  * GNU Lesser General Public License for more details.
  2168 |  *
  2169 |  * You should have received a copy of the GNU Lesser General Public License
  2170 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  2171 |  *
  2172 |  * For information on the complete list of contributors to MRChem, see:
  2173 |  * <https://mrchem.readthedocs.io/>
  2174 |  */
  2175 | 
  2176 | #pragma once
  2177 | 
  2178 | #include "qmoperators/two_electron/XCPotential.h"
  2179 | 
  2180 | /** @class XCPotential
  2181 |  *
  2182 |  * @brief Exchange-Correlation potential defined by a particular (spin) density
  2183 |  *
  2184 |  * The XC potential is computed by mapping of the density through a XC functional,
  2185 |  * provided by the XCFun library. There are two ways of defining the density:
  2186 |  *
  2187 |  *  1) Use getDensity() prior to setup() and build the density as you like.
  2188 |  *  2) Provide a default set of orbitals in the constructor that is used to
  2189 |  *     compute the density on-the-fly in setup().
  2190 |  *
  2191 |  * If a set of orbitals has NOT been given in the constructor, the density
  2192 |  * MUST be explicitly computed prior to setup(). The density will be computed
  2193 |  * on-the-fly in setup() ONLY if it is not already available. After setup() the
  2194 |  * operator will be fixed until clear(), which deletes both the density and the
  2195 |  * potential.
  2196 |  *
  2197 |  * LDA and GGA functionals are supported as well as two different ways to compute
  2198 |  * the XC potentials: either with explicit derivatives or gamma-type derivatives.
  2199 |  */
  2200 | 
  2201 | namespace mrchem {
  2202 | 
  2203 | class XCPotentialD2 final : public XCPotential {
  2204 | public:
  2205 |     XCPotentialD2(std::unique_ptr<mrdft::MRDFT> &F, std::shared_ptr<OrbitalVector> Phi, std::shared_ptr<OrbitalVector> X, std::shared_ptr<OrbitalVector> Y, bool mpi_shared = false);
  2206 | 
  2207 | private:
  2208 |     std::shared_ptr<OrbitalVector> orbitals_x; ///< 1st external set of perturbed orbitals used to build the density
  2209 |     std::shared_ptr<OrbitalVector> orbitals_y; ///< 2nd external set of perturbed orbitals used to build the density
  2210 | 
  2211 |     mrcpp::FunctionTreeVector<3> setupDensities(double prec, mrcpp::FunctionTree<3> &grid);
  2212 | };
  2213 | 
  2214 | } // namespace mrchem
  2215 | 
  2216 | ===== END src/qmoperators/two_electron/XCPotentialD2.h =====
  2217 | 
  2218 | ===== BEGIN src/qmoperators/two_electron/XCPotentialD2.cpp =====
  2219 | /*
  2220 |  * MRChem, a numerical real-space code for molecular electronic structure
  2221 |  * calculations within the self-consistent field (SCF) approximations of quantum
  2222 |  * chemistry (Hartree-Fock and Density Functional Theory).
  2223 |  * Copyright (C) 2023 Stig Rune Jensen, Luca Frediani, Peter Wind and contributors.
  2224 |  *
  2225 |  * This file is part of MRChem.
  2226 |  *
  2227 |  * MRChem is free software: you can redistribute it and/or modify
  2228 |  * it under the terms of the GNU Lesser General Public License as published by
  2229 |  * the Free Software Foundation, either version 3 of the License, or
  2230 |  * (at your option) any later version.
  2231 |  *
  2232 |  * MRChem is distributed in the hope that it will be useful,
  2233 |  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  2234 |  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  2235 |  * GNU Lesser General Public License for more details.
  2236 |  *
  2237 |  * You should have received a copy of the GNU Lesser General Public License
  2238 |  * along with MRChem.  If not, see <https://www.gnu.org/licenses/>.
  2239 |  *
  2240 |  * For information on the complete list of contributors to MRChem, see:
  2241 |  * <https://mrchem.readthedocs.io/>
  2242 |  */
  2243 | 
  2244 | #include "MRCPP/MWOperators"
  2245 | #include "MRCPP/Printer"
  2246 | #include "MRCPP/Timer"
  2247 | 
  2248 | #include "XCPotential.h"
  2249 | #include "XCPotentialD2.h"
  2250 | #include "qmfunctions/Density.h"
  2251 | #include "qmfunctions/density_utils.h"
  2252 | #include "qmfunctions/orbital_utils.h"
  2253 | #include "utils/print_utils.h"
  2254 | 
  2255 | using mrcpp::FunctionTree;
  2256 | using mrcpp::Printer;
  2257 | using mrcpp::Timer;
  2258 | 
  2259 | namespace mrchem {
  2260 | 
  2261 | XCPotentialD2::XCPotentialD2(std::unique_ptr<mrdft::MRDFT> &F, std::shared_ptr<OrbitalVector> Phi, std::shared_ptr<OrbitalVector> X, std::shared_ptr<OrbitalVector> Y, bool mpi_shared)
  2262 |         : XCPotential(F, Phi, mpi_shared)
  2263 |         , orbitals_x(X)
  2264 |         , orbitals_y(Y) {
  2265 |     densities.push_back(Density(false)); // rho_0 total
  2266 |     densities.push_back(Density(false)); // rho_0 alpha
  2267 |     densities.push_back(Density(false)); // rho_0 beta
  2268 |     densities.push_back(Density(false)); // rho_1 total
  2269 |     densities.push_back(Density(false)); // rho_1 alpha
  2270 |     densities.push_back(Density(false)); // rho_1 beta
  2271 | }
  2272 | 
  2273 | /** @brief Prepare the operator for application
  2274 |  *
  2275 |  * @param[in] prec Apply precision
  2276 |  *
  2277 |  * Sequence of steps required to compute the XC potentials:
  2278 |  *
  2279 |  * 1) Compute density
  2280 |  * 2) Setup xcfun input functions (gradients etc.)
  2281 |  * 3) Evaluate xcfun
  2282 |  * 4) Compute XC energy by integrating energy density
  2283 |  * 5) Compute XC potential(s) from xcfun output functions
  2284 |  * 6) Remove excess grid nodes based on precision
  2285 |  * 7) Add extra grid nodes based on precision
  2286 |  * 8) Clear internal functions in XCFunctional (density grid is kept)
  2287 |  *
  2288 |  */
  2289 | mrcpp::FunctionTreeVector<3> XCPotentialD2::setupDensities(double prec, mrcpp::FunctionTree<3> &grid) {
  2290 |     mrcpp::FunctionTreeVector<3> dens_vec;
  2291 |     if (not this->mrdft->functional().isSpin()) {
  2292 |         { // Unperturbed total density
  2293 |             Timer timer;
  2294 |             Density &rho = getDensity(DensityType::Total, 0);
  2295 |             if (not rho.hasReal()) {
  2296 |                 rho.alloc(NUMBER::Real);
  2297 |                 mrcpp::copy_grid(rho.real(), grid);
  2298 |                 density::compute(prec, rho, *orbitals, DensityType::Total);
  2299 |             }
  2300 |             print_utils::qmfunction(3, "Compute rho_0", rho, timer);
  2301 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2302 |         }
  2303 |         { // Perturbed total density
  2304 |             Timer timer;
  2305 |             Density &rho = getDensity(DensityType::Total, 1);
  2306 |             if (not rho.hasReal()) {
  2307 |                 rho.alloc(NUMBER::Real);
  2308 |                 mrcpp::copy_grid(rho.real(), grid);
  2309 |                 density::compute(prec, rho, *orbitals, *orbitals_x, *orbitals_y, DensityType::Total);
  2310 |             }
  2311 |             print_utils::qmfunction(3, "Compute rho_1", rho, timer);
  2312 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2313 |         }
  2314 |     } else {
  2315 |         { // Unperturbed alpha density
  2316 |             Timer timer;
  2317 |             Density &rho = getDensity(DensityType::Alpha, 0);
  2318 |             if (not rho.hasReal()) {
  2319 |                 rho.alloc(NUMBER::Real);
  2320 |                 mrcpp::copy_grid(rho.real(), grid);
  2321 |                 density::compute(prec, rho, *orbitals, DensityType::Alpha);
  2322 |             }
  2323 |             print_utils::qmfunction(3, "Compute rho_0 (alpha)", rho, timer);
  2324 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2325 |         }
  2326 |         { // Unperturbed beta density
  2327 |             Timer timer;
  2328 |             Density &rho = getDensity(DensityType::Beta, 0);
  2329 |             if (not rho.hasReal()) {
  2330 |                 rho.alloc(NUMBER::Real);
  2331 |                 mrcpp::copy_grid(rho.real(), grid);
  2332 |                 density::compute(prec, rho, *orbitals, DensityType::Beta);
  2333 |             }
  2334 |             print_utils::qmfunction(3, "Compute rho_0 (beta)", rho, timer);
  2335 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2336 |         }
  2337 |         { // Perturbed alpha density
  2338 |             Timer timer;
  2339 |             Density &rho = getDensity(DensityType::Alpha, 1);
  2340 |             if (not rho.hasReal()) {
  2341 |                 rho.alloc(NUMBER::Real);
  2342 |                 mrcpp::copy_grid(rho.real(), grid);
  2343 |                 density::compute(prec, rho, *orbitals, *orbitals_x, *orbitals_y, DensityType::Alpha);
  2344 |             }
  2345 |             print_utils::qmfunction(3, "Compute rho_1 (alpha)", rho, timer);
  2346 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2347 |         }
  2348 |         { // Perturbed beta density
  2349 |             Timer timer;
  2350 |             Density &rho = getDensity(DensityType::Beta, 1);
  2351 |             if (not rho.hasReal()) {
  2352 |                 rho.alloc(NUMBER::Real);
  2353 |                 mrcpp::copy_grid(rho.real(), grid);
  2354 |                 density::compute(prec, rho, *orbitals, *orbitals_x, *orbitals_y, DensityType::Beta);
  2355 |             }
  2356 |             print_utils::qmfunction(3, "Compute rho_1 (beta)", rho, timer);
  2357 |             dens_vec.push_back(std::make_tuple(1.0, &rho.real()));
  2358 |         }
  2359 |     }
  2360 |     return dens_vec;
  2361 | }
  2362 | 
  2363 | } // namespace mrchem
  2364 | 
  2365 | ===== END src/qmoperators/two_electron/XCPotentialD2.cpp =====
  2366 | 
  2367 | ===== BEGIN CMakeLists.txt =====
  2368 | # This file is autogenerated by Autocmake v1.0.0 http://autocmake.org
  2369 | # Copyright (c) 2015-2020 by Radovan Bast, Roberto Di Remigio, Jonas Juselius, and contributors.
  2370 | 
  2371 | # set minimum cmake version
  2372 | cmake_minimum_required(VERSION 3.14 FATAL_ERROR)
  2373 | 
  2374 | # project name
  2375 | project(MRChem LANGUAGES CXX)
  2376 | 
  2377 | # do not rebuild if rules (compiler flags) change
  2378 | set(CMAKE_SKIP_RULE_DEPENDENCY TRUE)
  2379 | 
  2380 | # if CMAKE_BUILD_TYPE undefined, we set it to Release
  2381 | if(NOT CMAKE_BUILD_TYPE)
  2382 |     set(CMAKE_BUILD_TYPE "Release")
  2383 | endif()
  2384 | 
  2385 | # Options handling utilities
  2386 | include(CMakeDependentOption)
  2387 | # Macro for printing an option in a consistent manner
  2388 | # Written by Lori A. Burns (@loriab) and Ryan M. Richard (@ryanmrichard)
  2389 | # Syntax: print_option(<option to print> <was specified>)
  2390 | macro(print_option variable default)
  2391 |   if(NOT DEFINED ${variable} OR "${${variable}}" STREQUAL "")
  2392 |     message(STATUS "Setting (unspecified) option ${variable}: ${default}")
  2393 |   else()
  2394 |     message(STATUS "Setting option ${variable}: ${${variable}}")
  2395 |   endif()
  2396 | endmacro()
  2397 | 
  2398 | # Wraps an option with default ON/OFF. Adds nice messaging to option()
  2399 | # Written by Lori A. Burns (@loriab) and Ryan M. Richard (@ryanmrichard)
  2400 | # Syntax: option_with_print(<option name> <description> <default value>)
  2401 | macro(option_with_print variable msge default)
  2402 |   print_option(${variable} ${default})
  2403 |   option(${variable} ${msge} ${default})
  2404 | endmacro()
  2405 | 
  2406 | # Wraps an option with a default other than ON/OFF and prints it
  2407 | # Written by Lori A. Burns (@loriab) and Ryan M. Richard (@ryanmrichard)
  2408 | # NOTE: Can't combine with above b/c CMake handles ON/OFF options specially
  2409 | # NOTE2: CMake variables are always defined so need to further check for if
  2410 | #       they are the NULL string. This is also why we need the force
  2411 | # Syntax: option_with_default(<option name> <description> <default value>)
  2412 | macro(option_with_default variable msge default)
  2413 |   print_option(${variable} "${default}")
  2414 |   if(NOT DEFINED ${variable} OR "${${variable}}" STREQUAL "")
  2415 |     set(${variable} "${default}" CACHE STRING ${msge} FORCE)
  2416 |   endif()
  2417 | endmacro()
  2418 | 
  2419 | # included cmake modules
  2420 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_cxx.cmake)
  2421 | include(${PROJECT_SOURCE_DIR}/cmake/compiler_flags/CXXFlags.cmake)
  2422 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_default_build_paths.cmake)
  2423 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_safeguards.cmake)
  2424 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_code_coverage.cmake)
  2425 | include(${PROJECT_SOURCE_DIR}/cmake/custom/mpi.cmake)
  2426 | include(${PROJECT_SOURCE_DIR}/cmake/custom/omp.cmake)
  2427 | include(${PROJECT_SOURCE_DIR}/cmake/custom/sad_basis.cmake)
  2428 | include(${PROJECT_SOURCE_DIR}/cmake/custom/hirshfeld.cmake)
  2429 | include(${PROJECT_SOURCE_DIR}/cmake/custom/azora_potentials.cmake)
  2430 | include(${PROJECT_SOURCE_DIR}/cmake/custom/main.cmake)
  2431 | include(${PROJECT_SOURCE_DIR}/cmake/custom/feature_summary.cmake)
  2432 | include(${PROJECT_SOURCE_DIR}/cmake/custom/tests.cmake)
  2433 | include(${PROJECT_SOURCE_DIR}/cmake/downloaded/autocmake_save_flags.cmake)
  2434 | 
  2435 | ===== END CMakeLists.txt =====
  2436 | 
  2437 | ===== BEGIN src/mrdft/CMakeLists.txt =====
  2438 | target_sources(mrchem PRIVATE
  2439 |     ${CMAKE_CURRENT_SOURCE_DIR}/Factory.cpp
  2440 |     ${CMAKE_CURRENT_SOURCE_DIR}/MRDFT.cpp
  2441 |     ${CMAKE_CURRENT_SOURCE_DIR}/Functional.cpp
  2442 |     ${CMAKE_CURRENT_SOURCE_DIR}/LDA.cpp
  2443 |     ${CMAKE_CURRENT_SOURCE_DIR}/SpinLDA.cpp
  2444 |     ${CMAKE_CURRENT_SOURCE_DIR}/GGA.cpp
  2445 |     ${CMAKE_CURRENT_SOURCE_DIR}/SpinGGA.cpp
  2446 |     ${CMAKE_CURRENT_SOURCE_DIR}/xc_utils.cpp
  2447 | )
  2448 | 
  2449 | if(MRCHEM_ENABLE_LIBXC AND HAVE_LIBXC)
  2450 |     target_sources(mrchem PRIVATE
  2451 |         ${CMAKE_CURRENT_SOURCE_DIR}/LibXCBackend.cpp
  2452 |     )
  2453 |     target_compile_definitions(mrchem PRIVATE MRCHEM_ENABLE_LIBXC)
  2454 |     target_link_libraries(mrchem PRIVATE Libxc::xc)
  2455 | endif()
  2456 | 
  2457 | ===== END src/mrdft/CMakeLists.txt =====
  2458 | 
  2459 | ===== BEGIN external/upstream/fetch_xcfun.cmake =====
  2460 | find_package(XCFun CONFIG QUIET
  2461 |   NO_CMAKE_PATH
  2462 |   NO_CMAKE_PACKAGE_REGISTRY
  2463 |   NO_CMAKE_SYSTEM_PACKAGE_REGISTRY
  2464 |   )
  2465 | if(TARGET XCFun::xcfun)
  2466 |   get_property(_loc TARGET XCFun::xcfun PROPERTY LOCATION)
  2467 |   message(STATUS "Found XCFun: ${_loc} (found version ${XCFun_VERSION})")
  2468 | else()
  2469 |   message(STATUS "Suitable XCFun could not be located. Fetching and building!")
  2470 |   include(FetchContent)
  2471 |   FetchContent_Declare(xcfun_sources
  2472 |     QUIET
  2473 |     URL
  2474 |       https://github.com/dftlibs/xcfun/archive/v2.1.0.tar.gz
  2475 |     )
  2476 | 
  2477 |   FetchContent_GetProperties(xcfun_sources)
  2478 | 
  2479 |   set(CMAKE_BUILD_TYPE Release)
  2480 |   set(ENABLE_TESTALL FALSE CACHE BOOL "")
  2481 |   set(XCFUN_MAX_ORDER 3)  # TODO Maybe as a user-facing option?
  2482 |   set(XCFUN_PYTHON_INTERFACE FALSE CACHE BOOL "")
  2483 | 
  2484 |   if(NOT xcfun_sources_POPULATED)
  2485 |     FetchContent_Populate(xcfun_sources)
  2486 | 
  2487 |     add_subdirectory(
  2488 |       ${xcfun_sources_SOURCE_DIR}
  2489 |       ${xcfun_sources_BINARY_DIR}
  2490 |       )
  2491 |   endif()
  2492 | endif()
  2493 | 
  2494 | ===== END external/upstream/fetch_xcfun.cmake =====
  2495 | 
  2496 | ===== BEGIN cmake/custom/main.cmake =====
  2497 | file(MAKE_DIRECTORY ${PROJECT_BINARY_DIR}/${CMAKE_INSTALL_INCLUDEDIR}/${PROJECT_NAME})
  2498 | 
  2499 | file(READ "${PROJECT_SOURCE_DIR}/VERSION" MRCHEM_VERSION)
  2500 | string(STRIP "${MRCHEM_VERSION}" MRCHEM_VERSION)
  2501 | 
  2502 | string(REPLACE "." ";" VERSION_LIST ${MRCHEM_VERSION})
  2503 | list(GET VERSION_LIST 0 MRCHEM_VERSION_MAJOR)
  2504 | list(GET VERSION_LIST 1 MRCHEM_VERSION_MINOR)
  2505 | 
  2506 | configure_file (
  2507 |   ${PROJECT_SOURCE_DIR}/config.h.in
  2508 |   ${PROJECT_BINARY_DIR}/config.h
  2509 |   @ONLY
  2510 |   )
  2511 | 
  2512 | add_custom_command(
  2513 |   OUTPUT
  2514 |     ${PROJECT_BINARY_DIR}/version.h
  2515 |   COMMAND
  2516 |     ${CMAKE_COMMAND} -DINPUT_DIR=${PROJECT_SOURCE_DIR}
  2517 |                      -DTARGET_DIR=${PROJECT_BINARY_DIR}
  2518 |                      -DCMAKE_SYSTEM=${CMAKE_SYSTEM}
  2519 |                      -DCMAKE_SYSTEM_PROCESSOR=${CMAKE_SYSTEM_PROCESSOR}
  2520 |                      -DCMAKE_GENERATOR=${CMAKE_GENERATOR}
  2521 |                      -DCMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
  2522 |                      -DCMAKE_CXX_COMPILER=${CMAKE_CXX_COMPILER}
  2523 |                      -DCMAKE_CXX_COMPILER_VERSION=${CMAKE_CXX_COMPILER_VERSION}
  2524 |                      -DMRCHEM_VERSION=${MRCHEM_VERSION}
  2525 |                      -DMW_FILTER_SOURCE_DIR=${MW_FILTER_SOURCE_DIR}
  2526 |                      -DMW_FILTER_INSTALL_DIR=${MW_FILTER_INSTALL_DIR}
  2527 |                      -P ${CMAKE_CURRENT_LIST_DIR}/binary-info.cmake
  2528 |   MAIN_DEPENDENCY
  2529 |     ${PROJECT_SOURCE_DIR}/version.h.in
  2530 |   WORKING_DIRECTORY
  2531 |     ${CMAKE_CURRENT_LIST_DIR}
  2532 |   )
  2533 | 
  2534 | # rebuild version_info.h every time
  2535 | add_custom_target(
  2536 |   mrchem-info
  2537 |   ALL
  2538 |   COMMAND
  2539 |     ${CMAKE_COMMAND} -E touch_nocreate ${PROJECT_SOURCE_DIR}/version.h.in
  2540 |   DEPENDS
  2541 |     ${PROJECT_BINARY_DIR}/version.h
  2542 |   )
  2543 | 
  2544 | # See here for the reason why: https://gitlab.kitware.com/cmake/cmake/issues/18399
  2545 | set_source_files_properties(${PROJECT_BINARY_DIR}/version.h
  2546 |   PROPERTIES
  2547 |     GENERATED 1
  2548 |   )
  2549 | 
  2550 | # We save CMAKE_BUILD_TYPE, as we will set it to Release for externals
  2551 | 
  2552 | # === LibXC backend switch (OFF by default, XCFun remains the default backend) ===
  2553 | option(MRCHEM_ENABLE_LIBXC "Enable experimental LibXC backend (in addition to XCFun)" OFF)
  2554 | 
  2555 | 
  2556 | set(_build_type ${CMAKE_BUILD_TYPE})
  2557 | # Order IS important here!
  2558 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_nlohmann_json.cmake)
  2559 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_xcfun.cmake)
  2560 | # Optional LibXC (only used if MRCHEM_ENABLE_LIBXC=ON and LibXC is found)
  2561 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_libxc.cmake)
  2562 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_eigen3.cmake)
  2563 | include(${PROJECT_SOURCE_DIR}/external/upstream/fetch_mrcpp.cmake)
  2564 | # reset CMAKE_BUILD_TYPE to whatever it was for MRChem
  2565 | set(CMAKE_BUILD_TYPE ${_build_type})
  2566 | 
  2567 | add_subdirectory(src)
  2568 | add_subdirectory(python)
  2569 | add_subdirectory(pilot)
  2570 | 
  2571 | ===== END cmake/custom/main.cmake =====
  2572 | 

=== FILE: your_b3lyp.inp | 181.0 B ===
     1 | {
     2 |   "world_prec": 1.0e-4,
     3 |   "WaveFunction": { "method": "B3LYP" },
     4 |   "Molecule": {
     5 |     "coords": "O  0.0000  0.000 -0.125\nH -1.4375  0.000  1.025\nH  1.4375  0.000  1.025\n"
     6 |   }
     7 | }

=== FILE: your_b3lyp.json | 4.5 KB ===
     1 | launch command:  /home/saikia/MRChem/mrchem/build/bin/mrchem.x your_b3lyp.json
     2 | "mpi": {
     3 |       "numerically_exact": false,
     4 |       "shared_memory_size": 10000,
     5 |       "bank_size": -1,
     6 |       "omp_threads": -1
     7 |     },
     8 |     "mra": {
     9 |       "basis_type": "interpolating",
    10 |       "basis_order": 6,
    11 |       "boxes": [
    12 |         2,
    13 |         2,
    14 |         2
    15 |       ],
    16 |       "corner": [
    17 |         -1,
    18 |         -1,
    19 |         -1
    20 |       ],
    21 |       "min_scale": -5,
    22 |       "max_scale": 20
    23 |     },
    24 |     "printer": {
    25 |       "print_level": 0,
    26 |       "print_mpi": false,
    27 |       "print_prec": 6,
    28 |       "print_width": 75,
    29 |       "print_constants": false,
    30 |       "file_name": "your_b3lyp"
    31 |     },
    32 |     "molecule": {
    33 |       "multiplicity": 1,
    34 |       "charge": 0,
    35 |       "coords": [
    36 |         {
    37 |           "atom": "o",
    38 |           "xyz": [
    39 |             0.0,
    40 |             0.0,
    41 |             -0.125
    42 |           ],
    43 |           "r_rms": 5.0580178957e-05
    44 |         },
    45 |         {
    46 |           "atom": "h",
    47 |           "xyz": [
    48 |             -1.4375,
    49 |             0.0,
    50 |             1.025
    51 |           ],
    52 |           "r_rms": 2.6569547399e-05
    53 |         },
    54 |         {
    55 |           "atom": "h",
    56 |           "xyz": [
    57 |             1.4375,
    58 |             0.0,
    59 |             1.025
    60 |           ],
    61 |           "r_rms": 2.6569547399e-05
    62 |         }
    63 |       ]
    64 |     },
    65 |     "scf_calculation": {
    66 |       "fock_operator": {
    67 |         "kinetic_operator": {
    68 |           "derivative": "abgv_55"
    69 |         },
    70 |         "nuclear_operator": {
    71 |           "proj_prec": 0.0001,
    72 |           "smooth_prec": 0.0001,
    73 |           "nuclear_model": "point_like",
    74 |           "shared_memory": false
    75 |         },
    76 |         "coulomb_operator": {
    77 |           "poisson_prec": 0.0001,
    78 |           "shared_memory": false
    79 |         },
    80 |         "exchange_operator": {
    81 |           "poisson_prec": 0.0001,
    82 |           "exchange_prec": -1.0
    83 |         },
    84 |         "xc_operator": {
    85 |           "shared_memory": false,
    86 |           "xc_functional": {
    87 |             "spin": false,
    88 |             "cutoff": 0.0,
    89 |             "functionals": [
    90 |               {
    91 |                 "name": "b3lyp",
    92 |                 "coef": 1.0
    93 |               }
    94 |             ]
    95 |           }
    96 |         }
    97 |       },
    98 |       "initial_guess": {
    99 |         "zeta": 0,
   100 |         "prec": 0.001,
   101 |         "type": "sad_gto",
   102 |         "method": "DFT (B3LYP)",
   103 |         "relativity": "None",
   104 |         "environment": "None",
   105 |         "external_field": "None",
   106 |         "screen": 12.0,
   107 |         "localize": false,
   108 |         "rotate": true,
   109 |         "restricted": true,
   110 |         "file_chk": "checkpoint/phi_scf",
   111 |         "file_basis": "initial_guess/mrchem.bas",
   112 |         "file_gto_p": "initial_guess/mrchem.mop",
   113 |         "file_gto_a": "initial_guess/mrchem.moa",
   114 |         "file_gto_b": "initial_guess/mrchem.mob",
   115 |         "file_phi_p": "initial_guess/phi_p_scf",
   116 |         "file_phi_a": "initial_guess/phi_a_scf",
   117 |         "file_phi_b": "initial_guess/phi_b_scf",
   118 |         "file_CUBE_p": "cube_vectors/CUBE_p_vector.json",
   119 |         "file_CUBE_a": "cube_vectors/CUBE_a_vector.json",
   120 |         "file_CUBE_b": "cube_vectors/CUBE_b_vector.json"
   121 |       },
   122 |       "scf_solver": {
   123 |         "method": "DFT (B3LYP)",
   124 |         "relativity": "None",
   125 |         "environment": "None",
   126 |         "external_field": "None",
   127 |         "kain": 5,
   128 |         "max_iter": 100,
   129 |         "rotation": 0,
   130 |         "localize": false,
   131 |         "file_chk": "checkpoint/phi_scf",
   132 |         "checkpoint": false,
   133 |         "start_prec": 0.0001,
   134 |         "final_prec": 0.0001,
   135 |         "energy_thrs": -1.0,
   136 |         "orbital_thrs": 0.001,
   137 |         "helmholtz_prec": -1.0
   138 |       },
   139 |       "properties": {
   140 |         "dipole_moment": {
   141 |           "dip-1": {
   142 |             "operator": "h_e_dip",
   143 |             "precision": 0.0001,
   144 |             "r_O": [
   145 |               0.0,
   146 |               0.0,
   147 |               0.0
   148 |             ]
   149 |           }
   150 |         }
   151 |       }
   152 |     },
   153 |     "rsp_calculations": {},
   154 |     "geom_opt": {
   155 |       "run": false,
   156 |       "use_previous_guess": false,
   157 |       "init_step_size": -0.5,
   158 |       "minimal_step_size": 0.01,
   159 |       "max_history_length": 10,
   160 |       "subspace_tolerance": 0.001,
   161 |       "max_iter": 100,
   162 |       "max_force_component": 0.005
   163 |     },
   164 |     "constants": {
   165 |       "hartree2simagnetizability": 78.9451185,
   166 |       "light_speed": 137.035999084,
   167 |       "angstrom2bohrs": 1.8897261246257702,
   168 |       "hartree2kjmol": 2625.4996394798254,
   169 |       "hartree2kcalmol": 627.5094740630558,
   170 |       "hartree2ev": 27.211386245988,
   171 |       "hartree2wavenumbers": 219474.6313632,
   172 |       "fine_structure_constant": 0.0072973525693,
   173 |       "electron_g_factor": -2.00231930436256,
   174 |       "dipmom_au2debye": 2.5417464739297717,
   175 |       "boltzmann_constant": 1.380649e-23,
   176 |       "elementary_charge": 1.602176634e-19,
   177 |       "e0": 8.8541878128e-12,
   178 |       "N_a": 6.02214076e+23,
   179 |       "meter2bohr": 18897261246.2577
   180 |     }
   181 |   }
   182 | }

# Summary: 37 files, 10758 lines written. Skipped 1.
